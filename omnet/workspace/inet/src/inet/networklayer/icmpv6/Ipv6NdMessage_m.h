//
// Generated file, do not edit! Created by nedtool 5.6 from inet/networklayer/icmpv6/Ipv6NdMessage.msg.
//

#ifndef __INET_IPV6NDMESSAGE_M_H
#define __INET_IPV6NDMESSAGE_M_H

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0506
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif

// dll export symbol
#ifndef INET_API
#  if defined(INET_EXPORT)
#    define INET_API  OPP_DLLEXPORT
#  elif defined(INET_IMPORT)
#    define INET_API  OPP_DLLIMPORT
#  else
#    define INET_API
#  endif
#endif


namespace inet {

class Ipv6NdPrefixInformation;
class Mipv6NdAdvertisementInterval;
class Mipv6HaInformation;
class Ipv6NdMessage;
class Ipv6RouterSolicitation;
class Ipv6RouterAdvertisement;
class Ipv6NeighbourSolicitation;
class Ipv6NeighbourAdvertisement;
class Ipv6Redirect;
class Ipv6NdControlInfo;
} // namespace inet

#include "inet/common/INETDefs_m.h" // import inet.common.INETDefs

#include "inet/linklayer/common/MacAddress_m.h" // import inet.linklayer.common.MacAddress

#include "inet/networklayer/icmpv6/Icmpv6Header_m.h" // import inet.networklayer.icmpv6.Icmpv6Header

#include "inet/networklayer/contract/ipv6/Ipv6Address_m.h" // import inet.networklayer.contract.ipv6.Ipv6Address


namespace inet {

// cplusplus {{
const B IPv6ND_LINK_LAYER_ADDRESS_OPTION_LENGTH = B(8);    // RFC 2461, Section 4.6.1. Source/Target Link-layer Address
const B IPv6ND_PREFIX_INFORMATION_OPTION_LENGTH = B(32);   // RFC 2461, Section 4.6.2. Prefix Information
const B IPv6ND_REDIRECTED_HEADER_OPTION_LENGTH = B(8);     // 8 + redirected packet, RFC 2461, Section 4.6.3. Redirected Header.
                                                           // The original packet truncated to ensure that the size of the redirect message does not exceed 1280 octets.
const B IPv6ND_MTU_OPTION_LENGTH = B(8);                   // RFC 2461, Section 4.6.4. MTU
// }}

/**
 * Enum generated from <tt>inet/networklayer/icmpv6/Ipv6NdMessage.msg:38</tt> by nedtool.
 * <pre>
 * // TLB options (type, length, bytes), length must be divisible by eight, max value is 8*255
 * // Type codes:
 * enum Ipv6NdOptionTypes
 * {
 *     IPv6ND_SOURCE_LINK_LAYER_ADDR_OPTION = 1;          // RFC 2461
 *     IPv6ND_TARGET_LINK_LAYER_ADDR_OPTION = 2;          // RFC 2461
 * }
 * </pre>
 */
enum Ipv6NdOptionTypes {
    IPv6ND_SOURCE_LINK_LAYER_ADDR_OPTION = 1,
    IPv6ND_TARGET_LINK_LAYER_ADDR_OPTION = 2
};

/**
 * Class generated from <tt>inet/networklayer/icmpv6/Ipv6NdMessage.msg:48</tt> by nedtool.
 * <pre>
 * //
 * // IPv6ND Prefix Information
 * // RFC 2461 / RFC 4861 Section 4.6.2
 * // RFC 3775 Section 7.2 (routerAddressFlag)
 * //
 * class Ipv6NdPrefixInformation extends cObject
 * {
 *     unsigned short prefixLength;
 *     bool onlinkFlag;        //L-bit
 *     bool autoAddressConfFlag;    //A-bit
 *     bool routerAddressFlag;        //R-bit: used in case of MIPv6 when the H-bit is set
 *     unsigned int validLifetime;    // seconds
 *     unsigned int preferredLifetime;    // seconds
 *     Ipv6Address prefix;
 * }
 * </pre>
 */
class INET_API Ipv6NdPrefixInformation : public ::omnetpp::cObject
{
  protected:
    unsigned short prefixLength = 0;
    bool onlinkFlag = false;
    bool autoAddressConfFlag = false;
    bool routerAddressFlag = false;
    unsigned int validLifetime = 0;
    unsigned int preferredLifetime = 0;
    Ipv6Address prefix;

  private:
    void copy(const Ipv6NdPrefixInformation& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ipv6NdPrefixInformation&);

  public:
    Ipv6NdPrefixInformation();
    Ipv6NdPrefixInformation(const Ipv6NdPrefixInformation& other);
    virtual ~Ipv6NdPrefixInformation();
    Ipv6NdPrefixInformation& operator=(const Ipv6NdPrefixInformation& other);
    virtual Ipv6NdPrefixInformation *dup() const override {return new Ipv6NdPrefixInformation(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual unsigned short getPrefixLength() const;
    virtual void setPrefixLength(unsigned short prefixLength);
    virtual bool getOnlinkFlag() const;
    virtual void setOnlinkFlag(bool onlinkFlag);
    virtual bool getAutoAddressConfFlag() const;
    virtual void setAutoAddressConfFlag(bool autoAddressConfFlag);
    virtual bool getRouterAddressFlag() const;
    virtual void setRouterAddressFlag(bool routerAddressFlag);
    virtual unsigned int getValidLifetime() const;
    virtual void setValidLifetime(unsigned int validLifetime);
    virtual unsigned int getPreferredLifetime() const;
    virtual void setPreferredLifetime(unsigned int preferredLifetime);
    virtual const Ipv6Address& getPrefix() const;
    virtual Ipv6Address& getPrefixForUpdate() { return const_cast<Ipv6Address&>(const_cast<Ipv6NdPrefixInformation*>(this)->getPrefix());}
    virtual void setPrefix(const Ipv6Address& prefix);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ipv6NdPrefixInformation& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ipv6NdPrefixInformation& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/networklayer/icmpv6/Ipv6NdMessage.msg:62</tt> by nedtool.
 * <pre>
 * // MIPv6 New Advertisement Interval Option
 * // RFC 3775 Section 7.3
 * //
 * class Mipv6NdAdvertisementInterval extends cObject
 * {
 *     unsigned int advertisementInterval;    // milliseconds
 * }
 * </pre>
 */
class INET_API Mipv6NdAdvertisementInterval : public ::omnetpp::cObject
{
  protected:
    unsigned int advertisementInterval = 0;

  private:
    void copy(const Mipv6NdAdvertisementInterval& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Mipv6NdAdvertisementInterval&);

  public:
    Mipv6NdAdvertisementInterval();
    Mipv6NdAdvertisementInterval(const Mipv6NdAdvertisementInterval& other);
    virtual ~Mipv6NdAdvertisementInterval();
    Mipv6NdAdvertisementInterval& operator=(const Mipv6NdAdvertisementInterval& other);
    virtual Mipv6NdAdvertisementInterval *dup() const override {return new Mipv6NdAdvertisementInterval(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual unsigned int getAdvertisementInterval() const;
    virtual void setAdvertisementInterval(unsigned int advertisementInterval);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Mipv6NdAdvertisementInterval& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Mipv6NdAdvertisementInterval& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/networklayer/icmpv6/Ipv6NdMessage.msg:69</tt> by nedtool.
 * <pre>
 * //MIPv6 Home Agent Information Option
 * //RFC 3775 Section 7.4
 * class Mipv6HaInformation extends cObject
 * {
 *     unsigned int homeAgentPreference;
 *     unsigned int homeAgentLifetime;    // seconds
 * }
 * </pre>
 */
class INET_API Mipv6HaInformation : public ::omnetpp::cObject
{
  protected:
    unsigned int homeAgentPreference = 0;
    unsigned int homeAgentLifetime = 0;

  private:
    void copy(const Mipv6HaInformation& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Mipv6HaInformation&);

  public:
    Mipv6HaInformation();
    Mipv6HaInformation(const Mipv6HaInformation& other);
    virtual ~Mipv6HaInformation();
    Mipv6HaInformation& operator=(const Mipv6HaInformation& other);
    virtual Mipv6HaInformation *dup() const override {return new Mipv6HaInformation(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual unsigned int getHomeAgentPreference() const;
    virtual void setHomeAgentPreference(unsigned int homeAgentPreference);
    virtual unsigned int getHomeAgentLifetime() const;
    virtual void setHomeAgentLifetime(unsigned int homeAgentLifetime);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Mipv6HaInformation& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Mipv6HaInformation& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/networklayer/icmpv6/Ipv6NdMessage.msg:86</tt> by nedtool.
 * <pre>
 * //
 * // Neighbour Discovery for Ipv6.
 * // RFC 2461
 * //
 * // ICMP fields inherited from ~Icmpv6Header:
 * //    - Type
 * //
 * // ICMP fields not implemented:
 * //    - Checksum
 * //    - Reserved
 * //
 * class Ipv6NdMessage extends Icmpv6Header
 * {
 *     //customize(true);
 *     int code = 0;
 * }
 * </pre>
 */
class INET_API Ipv6NdMessage : public ::inet::Icmpv6Header
{
  protected:
    int code = 0;

  private:
    void copy(const Ipv6NdMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ipv6NdMessage&);

  public:
    Ipv6NdMessage();
    Ipv6NdMessage(const Ipv6NdMessage& other);
    virtual ~Ipv6NdMessage();
    Ipv6NdMessage& operator=(const Ipv6NdMessage& other);
    virtual Ipv6NdMessage *dup() const override {return new Ipv6NdMessage(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getCode() const;
    virtual void setCode(int code);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ipv6NdMessage& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ipv6NdMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/networklayer/icmpv6/Ipv6NdMessage.msg:96</tt> by nedtool.
 * <pre>
 * //
 * // Router Solicitation Message Format
 * // RFC 4861 Section 4.1
 * //
 * class Ipv6RouterSolicitation extends Ipv6NdMessage
 * {
 *     type = ICMPv6_ROUTER_SOL;
 *     //Possible Options   //FIXME these fields are TLV options!
 * 
 *     // The link-layer address of the sender, if known.
 *     // MUST NOT be included if the Source Address is the unspecified address.
 *     // Otherwise, it SHOULD be included on link layers that have addresses.
 *     MacAddress sourceLinkLayerAddress;
 * }
 * </pre>
 */
class INET_API Ipv6RouterSolicitation : public ::inet::Ipv6NdMessage
{
  protected:
    MacAddress sourceLinkLayerAddress;

  private:
    void copy(const Ipv6RouterSolicitation& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ipv6RouterSolicitation&);

  public:
    Ipv6RouterSolicitation();
    Ipv6RouterSolicitation(const Ipv6RouterSolicitation& other);
    virtual ~Ipv6RouterSolicitation();
    Ipv6RouterSolicitation& operator=(const Ipv6RouterSolicitation& other);
    virtual Ipv6RouterSolicitation *dup() const override {return new Ipv6RouterSolicitation(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const MacAddress& getSourceLinkLayerAddress() const;
    virtual MacAddress& getSourceLinkLayerAddressForUpdate() { handleChange();return const_cast<MacAddress&>(const_cast<Ipv6RouterSolicitation*>(this)->getSourceLinkLayerAddress());}
    virtual void setSourceLinkLayerAddress(const MacAddress& sourceLinkLayerAddress);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ipv6RouterSolicitation& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ipv6RouterSolicitation& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/networklayer/icmpv6/Ipv6NdMessage.msg:112</tt> by nedtool.
 * <pre>
 * //
 * // Router Advertisement Message Format
 * // RFC 2461 Section 4.2
 * // RFC 3775 Section 7.1, RFC 5175 Section 3. (homeAgentFlag)
 * //
 * class Ipv6RouterAdvertisement extends Ipv6NdMessage
 * {
 *     type = ICMPv6_ROUTER_AD;
 *     //Additional ICMP fields
 *     unsigned short curHopLimit;
 *     bool managedAddrConfFlag;    //M-bit
 *     bool otherStatefulConfFlag;    //O-bit
 *     bool homeAgentFlag = false;        //H-bit
 *     unsigned short routerLifetime;  // 0 indicates router is not a default router
 *     unsigned int reachableTime;
 *     unsigned int retransTimer;
 * 
 *     //Possible Options   //FIXME these fields are TLV options!
 * 
 *     MacAddress sourceLinkLayerAddress;        //source link layer option
 *     unsigned int MTU;                //MTU option
 *     Ipv6NdPrefixInformation prefixInformation[];    //Prefix Information Option
 *     Mipv6NdAdvertisementInterval advInterval;    //New Advertisement Interval Option (MIPv6)
 *     Mipv6HaInformation haInformation;    //New Home Agent Information Option (MIPv6)
 * }
 * </pre>
 */
class INET_API Ipv6RouterAdvertisement : public ::inet::Ipv6NdMessage
{
  protected:
    unsigned short curHopLimit = 0;
    bool managedAddrConfFlag = false;
    bool otherStatefulConfFlag = false;
    bool homeAgentFlag = false;
    unsigned short routerLifetime = 0;
    unsigned int reachableTime = 0;
    unsigned int retransTimer = 0;
    MacAddress sourceLinkLayerAddress;
    unsigned int MTU = 0;
    Ipv6NdPrefixInformation *prefixInformation = nullptr;
    size_t prefixInformation_arraysize = 0;
    Mipv6NdAdvertisementInterval advInterval;
    Mipv6HaInformation haInformation;

  private:
    void copy(const Ipv6RouterAdvertisement& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ipv6RouterAdvertisement&);

  public:
    Ipv6RouterAdvertisement();
    Ipv6RouterAdvertisement(const Ipv6RouterAdvertisement& other);
    virtual ~Ipv6RouterAdvertisement();
    Ipv6RouterAdvertisement& operator=(const Ipv6RouterAdvertisement& other);
    virtual Ipv6RouterAdvertisement *dup() const override {return new Ipv6RouterAdvertisement(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual unsigned short getCurHopLimit() const;
    virtual void setCurHopLimit(unsigned short curHopLimit);
    virtual bool getManagedAddrConfFlag() const;
    virtual void setManagedAddrConfFlag(bool managedAddrConfFlag);
    virtual bool getOtherStatefulConfFlag() const;
    virtual void setOtherStatefulConfFlag(bool otherStatefulConfFlag);
    virtual bool getHomeAgentFlag() const;
    virtual void setHomeAgentFlag(bool homeAgentFlag);
    virtual unsigned short getRouterLifetime() const;
    virtual void setRouterLifetime(unsigned short routerLifetime);
    virtual unsigned int getReachableTime() const;
    virtual void setReachableTime(unsigned int reachableTime);
    virtual unsigned int getRetransTimer() const;
    virtual void setRetransTimer(unsigned int retransTimer);
    virtual const MacAddress& getSourceLinkLayerAddress() const;
    virtual MacAddress& getSourceLinkLayerAddressForUpdate() { handleChange();return const_cast<MacAddress&>(const_cast<Ipv6RouterAdvertisement*>(this)->getSourceLinkLayerAddress());}
    virtual void setSourceLinkLayerAddress(const MacAddress& sourceLinkLayerAddress);
    virtual unsigned int getMTU() const;
    virtual void setMTU(unsigned int MTU);
    virtual void setPrefixInformationArraySize(size_t size);
    virtual size_t getPrefixInformationArraySize() const;
    virtual const Ipv6NdPrefixInformation& getPrefixInformation(size_t k) const;
    virtual Ipv6NdPrefixInformation& getPrefixInformationForUpdate(size_t k) { handleChange();return const_cast<Ipv6NdPrefixInformation&>(const_cast<Ipv6RouterAdvertisement*>(this)->getPrefixInformation(k));}
    virtual void setPrefixInformation(size_t k, const Ipv6NdPrefixInformation& prefixInformation);
    virtual void insertPrefixInformation(const Ipv6NdPrefixInformation& prefixInformation);
    virtual void insertPrefixInformation(size_t k, const Ipv6NdPrefixInformation& prefixInformation);
    virtual void erasePrefixInformation(size_t k);
    virtual const Mipv6NdAdvertisementInterval& getAdvInterval() const;
    virtual Mipv6NdAdvertisementInterval& getAdvIntervalForUpdate() { handleChange();return const_cast<Mipv6NdAdvertisementInterval&>(const_cast<Ipv6RouterAdvertisement*>(this)->getAdvInterval());}
    virtual void setAdvInterval(const Mipv6NdAdvertisementInterval& advInterval);
    virtual const Mipv6HaInformation& getHaInformation() const;
    virtual Mipv6HaInformation& getHaInformationForUpdate() { handleChange();return const_cast<Mipv6HaInformation&>(const_cast<Ipv6RouterAdvertisement*>(this)->getHaInformation());}
    virtual void setHaInformation(const Mipv6HaInformation& haInformation);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ipv6RouterAdvertisement& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ipv6RouterAdvertisement& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/networklayer/icmpv6/Ipv6NdMessage.msg:137</tt> by nedtool.
 * <pre>
 * //
 * // Neighbour Solicitation Message Format
 * // RFC 4861 Section 4.3
 * //
 * class Ipv6NeighbourSolicitation extends Ipv6NdMessage
 * {
 *     type = ICMPv6_NEIGHBOUR_SOL;
 *     //Additional ICMP fields
 *     Ipv6Address targetAddress;// MUST NOT be a multicast address.
 * 
 *     //Possible Options   //FIXME these fields are TLV options!
 * 
 *     // The link-layer address for the sender.
 *     // MUST NOT be included when the source IP address is the unspecified address.
 *     // Otherwise, on link layers that have addresses this option MUST be included in multicast
 *     // solicitations and SHOULD be included in unicast solicitations.
 *     MacAddress sourceLinkLayerAddress;
 * }
 * </pre>
 */
class INET_API Ipv6NeighbourSolicitation : public ::inet::Ipv6NdMessage
{
  protected:
    Ipv6Address targetAddress;
    MacAddress sourceLinkLayerAddress;

  private:
    void copy(const Ipv6NeighbourSolicitation& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ipv6NeighbourSolicitation&);

  public:
    Ipv6NeighbourSolicitation();
    Ipv6NeighbourSolicitation(const Ipv6NeighbourSolicitation& other);
    virtual ~Ipv6NeighbourSolicitation();
    Ipv6NeighbourSolicitation& operator=(const Ipv6NeighbourSolicitation& other);
    virtual Ipv6NeighbourSolicitation *dup() const override {return new Ipv6NeighbourSolicitation(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const Ipv6Address& getTargetAddress() const;
    virtual Ipv6Address& getTargetAddressForUpdate() { handleChange();return const_cast<Ipv6Address&>(const_cast<Ipv6NeighbourSolicitation*>(this)->getTargetAddress());}
    virtual void setTargetAddress(const Ipv6Address& targetAddress);
    virtual const MacAddress& getSourceLinkLayerAddress() const;
    virtual MacAddress& getSourceLinkLayerAddressForUpdate() { handleChange();return const_cast<MacAddress&>(const_cast<Ipv6NeighbourSolicitation*>(this)->getSourceLinkLayerAddress());}
    virtual void setSourceLinkLayerAddress(const MacAddress& sourceLinkLayerAddress);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ipv6NeighbourSolicitation& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ipv6NeighbourSolicitation& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/networklayer/icmpv6/Ipv6NdMessage.msg:156</tt> by nedtool.
 * <pre>
 * //
 * // Neighbour Advertisement Message Format
 * // RFC 2461 Section 4.4
 * //
 * class Ipv6NeighbourAdvertisement extends Ipv6NdMessage
 * {
 *     type = ICMPv6_NEIGHBOUR_AD;
 *     //Additional ICMP fields
 *     bool routerFlag;    //R-flag
 *     bool solicitedFlag;    //S-flag
 *     bool overrideFlag;    //O-flag
 *     Ipv6Address targetAddress;// MUST NOT be a multicast address.
 * 
 *     //Possible Options   //FIXME these fields are TLV options!
 * 
 *     MacAddress targetLinkLayerAddress;    //Target Link Layer Address option
 * }
 * </pre>
 */
class INET_API Ipv6NeighbourAdvertisement : public ::inet::Ipv6NdMessage
{
  protected:
    bool routerFlag = false;
    bool solicitedFlag = false;
    bool overrideFlag = false;
    Ipv6Address targetAddress;
    MacAddress targetLinkLayerAddress;

  private:
    void copy(const Ipv6NeighbourAdvertisement& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ipv6NeighbourAdvertisement&);

  public:
    Ipv6NeighbourAdvertisement();
    Ipv6NeighbourAdvertisement(const Ipv6NeighbourAdvertisement& other);
    virtual ~Ipv6NeighbourAdvertisement();
    Ipv6NeighbourAdvertisement& operator=(const Ipv6NeighbourAdvertisement& other);
    virtual Ipv6NeighbourAdvertisement *dup() const override {return new Ipv6NeighbourAdvertisement(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual bool getRouterFlag() const;
    virtual void setRouterFlag(bool routerFlag);
    virtual bool getSolicitedFlag() const;
    virtual void setSolicitedFlag(bool solicitedFlag);
    virtual bool getOverrideFlag() const;
    virtual void setOverrideFlag(bool overrideFlag);
    virtual const Ipv6Address& getTargetAddress() const;
    virtual Ipv6Address& getTargetAddressForUpdate() { handleChange();return const_cast<Ipv6Address&>(const_cast<Ipv6NeighbourAdvertisement*>(this)->getTargetAddress());}
    virtual void setTargetAddress(const Ipv6Address& targetAddress);
    virtual const MacAddress& getTargetLinkLayerAddress() const;
    virtual MacAddress& getTargetLinkLayerAddressForUpdate() { handleChange();return const_cast<MacAddress&>(const_cast<Ipv6NeighbourAdvertisement*>(this)->getTargetLinkLayerAddress());}
    virtual void setTargetLinkLayerAddress(const MacAddress& targetLinkLayerAddress);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ipv6NeighbourAdvertisement& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ipv6NeighbourAdvertisement& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/networklayer/icmpv6/Ipv6NdMessage.msg:174</tt> by nedtool.
 * <pre>
 * //
 * // Redirect Message Format
 * // RFC 2461 Section 4.5
 * //
 * class Ipv6Redirect extends Ipv6NdMessage
 * {
 *     type = ICMPv6_REDIRECT;
 *     //Additional ICMP fields
 *     Ipv6Address targetAddress;
 *     Ipv6Address destinationAddress;
 * 
 *     //Possible Options   //FIXME these fields are TLV options!
 * 
 *     MacAddress targetLinkLayerAddress;
 *         //Redirected Header Encapsulated Msg
 * }
 * </pre>
 */
class INET_API Ipv6Redirect : public ::inet::Ipv6NdMessage
{
  protected:
    Ipv6Address targetAddress;
    Ipv6Address destinationAddress;
    MacAddress targetLinkLayerAddress;

  private:
    void copy(const Ipv6Redirect& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ipv6Redirect&);

  public:
    Ipv6Redirect();
    Ipv6Redirect(const Ipv6Redirect& other);
    virtual ~Ipv6Redirect();
    Ipv6Redirect& operator=(const Ipv6Redirect& other);
    virtual Ipv6Redirect *dup() const override {return new Ipv6Redirect(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const Ipv6Address& getTargetAddress() const;
    virtual Ipv6Address& getTargetAddressForUpdate() { handleChange();return const_cast<Ipv6Address&>(const_cast<Ipv6Redirect*>(this)->getTargetAddress());}
    virtual void setTargetAddress(const Ipv6Address& targetAddress);
    virtual const Ipv6Address& getDestinationAddress() const;
    virtual Ipv6Address& getDestinationAddressForUpdate() { handleChange();return const_cast<Ipv6Address&>(const_cast<Ipv6Redirect*>(this)->getDestinationAddress());}
    virtual void setDestinationAddress(const Ipv6Address& destinationAddress);
    virtual const MacAddress& getTargetLinkLayerAddress() const;
    virtual MacAddress& getTargetLinkLayerAddressForUpdate() { handleChange();return const_cast<MacAddress&>(const_cast<Ipv6Redirect*>(this)->getTargetLinkLayerAddress());}
    virtual void setTargetLinkLayerAddress(const MacAddress& targetLinkLayerAddress);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ipv6Redirect& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ipv6Redirect& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/networklayer/icmpv6/Ipv6NdMessage.msg:187</tt> by nedtool.
 * <pre>
 * class Ipv6NdControlInfo extends cObject
 * {
 *     Ipv6Address nextHop;   // next hop address
 *     int interfaceId = -1; // interface on which the datagram should be sent
 *     bool fromHL = false;    // packet came from higher layer
 * }
 * </pre>
 */
class INET_API Ipv6NdControlInfo : public ::omnetpp::cObject
{
  protected:
    Ipv6Address nextHop;
    int interfaceId = -1;
    bool fromHL = false;

  private:
    void copy(const Ipv6NdControlInfo& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ipv6NdControlInfo&);

  public:
    Ipv6NdControlInfo();
    Ipv6NdControlInfo(const Ipv6NdControlInfo& other);
    virtual ~Ipv6NdControlInfo();
    Ipv6NdControlInfo& operator=(const Ipv6NdControlInfo& other);
    virtual Ipv6NdControlInfo *dup() const override {return new Ipv6NdControlInfo(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const Ipv6Address& getNextHop() const;
    virtual Ipv6Address& getNextHopForUpdate() { return const_cast<Ipv6Address&>(const_cast<Ipv6NdControlInfo*>(this)->getNextHop());}
    virtual void setNextHop(const Ipv6Address& nextHop);
    virtual int getInterfaceId() const;
    virtual void setInterfaceId(int interfaceId);
    virtual bool getFromHL() const;
    virtual void setFromHL(bool fromHL);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ipv6NdControlInfo& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ipv6NdControlInfo& obj) {obj.parsimUnpack(b);}

} // namespace inet

#endif // ifndef __INET_IPV6NDMESSAGE_M_H

