//
// Generated file, do not edit! Created by nedtool 5.6 from inet/linklayer/ethernet/EtherPhyFrame.msg.
//

#ifndef __INET_ETHERPHYFRAME_M_H
#define __INET_ETHERPHYFRAME_M_H

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0506
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif

// dll export symbol
#ifndef INET_API
#  if defined(INET_EXPORT)
#    define INET_API  OPP_DLLEXPORT
#  elif defined(INET_IMPORT)
#    define INET_API  OPP_DLLIMPORT
#  else
#    define INET_API
#  endif
#endif


namespace inet {

class EthernetSignal;
class EthernetJamSignal;
class EthernetFilledIfgSignal;
class EthernetPhyHeader;
} // namespace inet

#include "inet/common/INETDefs_m.h" // import inet.common.INETDefs

#include "inet/common/TagBase_m.h" // import inet.common.TagBase

#include "inet/common/packet/chunk/Chunk_m.h" // import inet.common.packet.chunk.Chunk

#include "inet/linklayer/common/MacAddress_m.h" // import inet.linklayer.common.MacAddress

// cplusplus {{
#include "inet/linklayer/ethernet/Ethernet.h"
// }}


namespace inet {

/**
 * Class generated from <tt>inet/linklayer/ethernet/EtherPhyFrame.msg:36</tt> by nedtool.
 * <pre>
 * //
 * // Abstract base class for various Ethernet traffic types:
 * // EtherJam, EtherFilledIfg and EtherPhyFrame.
 * //
 * packet EthernetSignal
 * {
 * }
 * </pre>
 */
class INET_API EthernetSignal : public ::omnetpp::cPacket
{
  protected:

  private:
    void copy(const EthernetSignal& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const EthernetSignal&);

  public:
    EthernetSignal(const char *name=nullptr, short kind=0);
    EthernetSignal(const EthernetSignal& other);
    virtual ~EthernetSignal();
    EthernetSignal& operator=(const EthernetSignal& other);
    virtual EthernetSignal *dup() const override {return new EthernetSignal(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const EthernetSignal& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, EthernetSignal& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ethernet/EtherPhyFrame.msg:43</tt> by nedtool.
 * <pre>
 * //
 * // Represents jam on the Ethernet.
 * //
 * packet EthernetJamSignal extends EthernetSignal
 * {
 *     long abortedPkTreeID = 0;  // this field stores the packetTreeId of the aborted packet
 * }
 * </pre>
 */
class INET_API EthernetJamSignal : public ::inet::EthernetSignal
{
  protected:
    long abortedPkTreeID = 0;

  private:
    void copy(const EthernetJamSignal& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const EthernetJamSignal&);

  public:
    EthernetJamSignal(const char *name=nullptr, short kind=0);
    EthernetJamSignal(const EthernetJamSignal& other);
    virtual ~EthernetJamSignal();
    EthernetJamSignal& operator=(const EthernetJamSignal& other);
    virtual EthernetJamSignal *dup() const override {return new EthernetJamSignal(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual long getAbortedPkTreeID() const;
    virtual void setAbortedPkTreeID(long abortedPkTreeID);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const EthernetJamSignal& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, EthernetJamSignal& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ethernet/EtherPhyFrame.msg:52</tt> by nedtool.
 * <pre>
 * //
 * // Represents a filled inter-frame gap in burst mode.
 * // Also used for calculating IFG times.
 * //
 * packet EthernetFilledIfgSignal extends EthernetSignal
 * {
 *     bitLength = b(INTERFRAME_GAP_BITS).get();
 * }
 * </pre>
 */
class INET_API EthernetFilledIfgSignal : public ::inet::EthernetSignal
{
  protected:

  private:
    void copy(const EthernetFilledIfgSignal& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const EthernetFilledIfgSignal&);

  public:
    EthernetFilledIfgSignal(const char *name=nullptr, short kind=0);
    EthernetFilledIfgSignal(const EthernetFilledIfgSignal& other);
    virtual ~EthernetFilledIfgSignal();
    EthernetFilledIfgSignal& operator=(const EthernetFilledIfgSignal& other);
    virtual EthernetFilledIfgSignal *dup() const override {return new EthernetFilledIfgSignal(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const EthernetFilledIfgSignal& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, EthernetFilledIfgSignal& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ethernet/EtherPhyFrame.msg:65</tt> by nedtool.
 * <pre>
 * //
 * // Represents an Ethernet PHY frame.
 * //
 * // Contains:
 * //  - preamble: not stored (only contributes to length)
 * //  - SFD: not stored (only contributes to length)
 * //  - encapsulated EtherFrame with padding and FCS
 * //
 * class EthernetPhyHeader extends FieldsChunk
 * {
 *     chunkLength = PREAMBLE_BYTES + SFD_BYTES;
 *     bool srcMacFullDuplex;  // meta-info, for detecting model misconfiguration 
 * }
 * </pre>
 */
class INET_API EthernetPhyHeader : public ::inet::FieldsChunk
{
  protected:
    bool srcMacFullDuplex = false;

  private:
    void copy(const EthernetPhyHeader& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const EthernetPhyHeader&);

  public:
    EthernetPhyHeader();
    EthernetPhyHeader(const EthernetPhyHeader& other);
    virtual ~EthernetPhyHeader();
    EthernetPhyHeader& operator=(const EthernetPhyHeader& other);
    virtual EthernetPhyHeader *dup() const override {return new EthernetPhyHeader(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual bool getSrcMacFullDuplex() const;
    virtual void setSrcMacFullDuplex(bool srcMacFullDuplex);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const EthernetPhyHeader& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, EthernetPhyHeader& obj) {obj.parsimUnpack(b);}

} // namespace inet

#endif // ifndef __INET_ETHERPHYFRAME_M_H

