//
// Generated file, do not edit! Created by nedtool 5.6 from inet/linklayer/ieee80211/mac/Ieee80211Frame.msg.
//

#ifndef __INET_IEEE80211FRAME_M_H
#define __INET_IEEE80211FRAME_M_H

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0506
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif

// dll export symbol
#ifndef INET_API
#  if defined(INET_EXPORT)
#    define INET_API  OPP_DLLEXPORT
#  elif defined(INET_IMPORT)
#    define INET_API  OPP_DLLIMPORT
#  else
#    define INET_API
#  endif
#endif


namespace inet {

} // namespace inet


namespace inet {
namespace ieee80211 {

class Ieee80211MacTrailer;
class Ieee80211MacHeader;
class Ieee80211OneAddressHeader;
class Ieee80211AckFrame;
class Ieee80211TwoAddressHeader;
class Ieee80211RtsFrame;
class Ieee80211CtsFrame;
class Ieee80211DataOrMgmtHeader;
class Ieee80211DataHeader;
class Ieee80211MgmtHeader;
class Ieee80211ActionFrame;
class Ieee80211MsduSubframeHeader;
class Ieee80211MpduSubframeHeader;
class Ieee80211AddbaRequest;
class Ieee80211AddbaResponse;
class Ieee80211Delba;
class Ieee80211BlockAckReq;
class Ieee80211BasicBlockAckReq;
class Ieee80211CompressedBlockAckReq;
class Ieee80211MultiTidBlockAckReq;
class Ieee80211BlockAck;
class Ieee80211BasicBlockAck;
class Ieee80211CompressedBlockAck;
class Ieee80211MultiTidBlockAck;
} // namespace ieee80211
} // namespace inet

#include "inet/common/INETDefs_m.h" // import inet.common.INETDefs

#include "inet/common/packet/chunk/Chunk_m.h" // import inet.common.packet.chunk.Chunk

#include "inet/linklayer/common/FcsMode_m.h" // import inet.linklayer.common.FcsMode

#include "inet/linklayer/common/MacAddress_m.h" // import inet.linklayer.common.MacAddress

// cplusplus {{
#include "inet/common/BitVector.h"
#include "inet/linklayer/ieee80211/mac/common/Ieee80211Defs.h"
// }}


namespace inet {

} // namespace inet


namespace inet {
namespace ieee80211 {

// cplusplus {{
const b LENGTH_RTS = b(160);    //bits
const b LENGTH_CTS = b(112);    //bits
const b LENGTH_ACK = b(112);    //bits
const b LENGTH_MGMT = B(28);    //bits
const b LENGTH_ADDBAREQ = LENGTH_MGMT + B(9); // mgmt length + action body length
const b LENGTH_BASIC_BLOCKACK = B(16 + 2 + (2 + 128) + 4); // header + ba control + ba information + fcs
const b DATAFRAME_HEADER_MINLENGTH = B(2 + 2 + 3 * 6 + 2);    //bits without QoS, without Address4: 2 + 2 + 3*6(addresses) + 2
const b QOSCONTROL_PART_LENGTH = b(2 * 8);    // QoS Control field length (bits)
const short int MAX_NUM_FRAGMENTS = 16;
const b LENGTH_A_MSDU_SUBFRAME_HEADER = B(14); //48 + 48 + 16 bits
const b LENGTH_A_MPDU_SUBFRAME_HEADER = b(4 + 12 + 8 + 8);
// }}

/**
 * Enum generated from <tt>inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:64</tt> by nedtool.
 * <pre>
 * //
 * // 802.11 frame type constants (type+subtype), for the "type" field of
 * // Ieee80211FrameControl
 * //
 * enum Ieee80211FrameType
 * {
 *     // management:
 *     ST_ASSOCIATIONREQUEST = 0x00;
 *     ST_ASSOCIATIONRESPONSE = 0x01;
 *     ST_REASSOCIATIONREQUEST = 0x02;
 *     ST_REASSOCIATIONRESPONSE = 0x03;
 *     ST_PROBEREQUEST = 0x04;
 *     ST_PROBERESPONSE = 0x05;
 *     ST_BEACON = 0x08;
 *     ST_ATIM = 0x09;
 *     ST_DISASSOCIATION = 0x0a;
 *     ST_AUTHENTICATION = 0x0b;
 *     ST_DEAUTHENTICATION = 0x0c;
 *     ST_ACTION = 0x0d;
 *     ST_NOACKACTION = 0x0e;
 * 
 *     // control (CFEND/CFEND_CFACK omitted):
 *     ST_PSPOLL = 0x1a;
 *     ST_RTS = 0x1b;
 *     ST_CTS = 0x1c;
 *     ST_ACK = 0x1d;
 *     ST_BLOCKACK_REQ = 0x18;
 *     ST_BLOCKACK = 0x19;
 * 
 *     // data (CFPOLL/CFACK subtypes omitted):
 *     ST_DATA = 0x20;
 *     ST_DATA_WITH_QOS = 0x28;
 *     //Feedback frame for multicast tramsmission
 *     ST_LBMS_REQUEST = 0x30;
 *     ST_LBMS_REPORT = 0x31;
 * }
 * </pre>
 */
enum Ieee80211FrameType {
    ST_ASSOCIATIONREQUEST = 0x00,
    ST_ASSOCIATIONRESPONSE = 0x01,
    ST_REASSOCIATIONREQUEST = 0x02,
    ST_REASSOCIATIONRESPONSE = 0x03,
    ST_PROBEREQUEST = 0x04,
    ST_PROBERESPONSE = 0x05,
    ST_BEACON = 0x08,
    ST_ATIM = 0x09,
    ST_DISASSOCIATION = 0x0a,
    ST_AUTHENTICATION = 0x0b,
    ST_DEAUTHENTICATION = 0x0c,
    ST_ACTION = 0x0d,
    ST_NOACKACTION = 0x0e,
    ST_PSPOLL = 0x1a,
    ST_RTS = 0x1b,
    ST_CTS = 0x1c,
    ST_ACK = 0x1d,
    ST_BLOCKACK_REQ = 0x18,
    ST_BLOCKACK = 0x19,
    ST_DATA = 0x20,
    ST_DATA_WITH_QOS = 0x28,
    ST_LBMS_REQUEST = 0x30,
    ST_LBMS_REPORT = 0x31
};

/**
 * Enum generated from <tt>inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:100</tt> by nedtool.
 * <pre>
 * //
 * // Ack policy values for the 802.11 QoS control field
 * //
 * enum AckPolicy
 * {
 *     NORMAL_ACK = 0;
 *     NO_ACK = 1;
 *     NO_EXPLICIT_ACK = 2;
 *     BLOCK_ACK = 3;
 * }
 * </pre>
 */
enum AckPolicy {
    NORMAL_ACK = 0,
    NO_ACK = 1,
    NO_EXPLICIT_ACK = 2,
    BLOCK_ACK = 3
};

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:108</tt> by nedtool.
 * <pre>
 * class Ieee80211MacTrailer extends FieldsChunk
 * {
 *     chunkLength = B(4);
 *     uint32_t fcs = 0;
 *     FcsMode fcsMode = FCS_MODE_UNDEFINED;
 * }
 * </pre>
 */
class INET_API Ieee80211MacTrailer : public ::inet::FieldsChunk
{
  protected:
    uint32_t fcs = 0;
    inet::FcsMode fcsMode = FCS_MODE_UNDEFINED;

  private:
    void copy(const Ieee80211MacTrailer& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211MacTrailer&);

  public:
    Ieee80211MacTrailer();
    Ieee80211MacTrailer(const Ieee80211MacTrailer& other);
    virtual ~Ieee80211MacTrailer();
    Ieee80211MacTrailer& operator=(const Ieee80211MacTrailer& other);
    virtual Ieee80211MacTrailer *dup() const override {return new Ieee80211MacTrailer(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint32_t getFcs() const;
    virtual void setFcs(uint32_t fcs);
    virtual inet::FcsMode getFcsMode() const;
    virtual void setFcsMode(inet::FcsMode fcsMode);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211MacTrailer& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211MacTrailer& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:123</tt> by nedtool.
 * <pre>
 * //
 * // The common part of 802.11 frames.
 * //
 * // NOTE:
 * // FCS value is not explicitly modeled, but it is included in the length.
 * // Frame control format fields not supported by this model are omitted:
 * // MoreFlag, PowerMgmt, MoreData, WEP, Order.
 * //
 * class Ieee80211MacHeader extends FieldsChunk
 * {
 *     chunkLength = LENGTH_ACK - B(4);
 *     Ieee80211FrameType type; // type and subtype
 *     bool toDS;
 *     bool fromDS;
 *     bool retry;
 *     bool moreFragments;
 *     // TODO: rename to durationField (levy)
 *     simtime_t duration = -1; // "duration" in the Duration/ID field (-1=no duration)
 *     short AID = -1;          // "id" (Association ID) in the Duration/ID field (-1=no ID)
 *     MacAddress receiverAddress; // aka address1
 *     simtime_t MACArrive;    // FIXME remove it, technical data, used inside of MAC module
 * }
 * </pre>
 */
class INET_API Ieee80211MacHeader : public ::inet::FieldsChunk
{
  protected:
    inet::ieee80211::Ieee80211FrameType type = static_cast<inet::ieee80211::Ieee80211FrameType>(-1);
    bool toDS = false;
    bool fromDS = false;
    bool retry = false;
    bool moreFragments = false;
    omnetpp::simtime_t duration = -1;
    short AID = -1;
    MacAddress receiverAddress;
    omnetpp::simtime_t MACArrive = SIMTIME_ZERO;

  private:
    void copy(const Ieee80211MacHeader& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211MacHeader&);

  public:
    Ieee80211MacHeader();
    Ieee80211MacHeader(const Ieee80211MacHeader& other);
    virtual ~Ieee80211MacHeader();
    Ieee80211MacHeader& operator=(const Ieee80211MacHeader& other);
    virtual Ieee80211MacHeader *dup() const override {return new Ieee80211MacHeader(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual inet::ieee80211::Ieee80211FrameType getType() const;
    virtual void setType(inet::ieee80211::Ieee80211FrameType type);
    virtual bool getToDS() const;
    virtual void setToDS(bool toDS);
    virtual bool getFromDS() const;
    virtual void setFromDS(bool fromDS);
    virtual bool getRetry() const;
    virtual void setRetry(bool retry);
    virtual bool getMoreFragments() const;
    virtual void setMoreFragments(bool moreFragments);
    virtual omnetpp::simtime_t getDuration() const;
    virtual void setDuration(omnetpp::simtime_t duration);
    virtual short getAID() const;
    virtual void setAID(short AID);
    virtual const MacAddress& getReceiverAddress() const;
    virtual MacAddress& getReceiverAddressForUpdate() { handleChange();return const_cast<MacAddress&>(const_cast<Ieee80211MacHeader*>(this)->getReceiverAddress());}
    virtual void setReceiverAddress(const MacAddress& receiverAddress);
    virtual omnetpp::simtime_t getMACArrive() const;
    virtual void setMACArrive(omnetpp::simtime_t MACArrive);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211MacHeader& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211MacHeader& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:141</tt> by nedtool.
 * <pre>
 * //
 * // Format of a 802.11 frame with address1 present, like ACK and CTS
 * //
 * class Ieee80211OneAddressHeader extends Ieee80211MacHeader
 * {
 * }
 * </pre>
 */
class INET_API Ieee80211OneAddressHeader : public ::inet::ieee80211::Ieee80211MacHeader
{
  protected:

  private:
    void copy(const Ieee80211OneAddressHeader& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211OneAddressHeader&);

  public:
    Ieee80211OneAddressHeader();
    Ieee80211OneAddressHeader(const Ieee80211OneAddressHeader& other);
    virtual ~Ieee80211OneAddressHeader();
    Ieee80211OneAddressHeader& operator=(const Ieee80211OneAddressHeader& other);
    virtual Ieee80211OneAddressHeader *dup() const override {return new Ieee80211OneAddressHeader(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211OneAddressHeader& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211OneAddressHeader& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:148</tt> by nedtool.
 * <pre>
 * //
 * // Format of the 802.11 ACK frame
 * //
 * class Ieee80211AckFrame extends Ieee80211OneAddressHeader
 * {
 *     chunkLength = LENGTH_ACK - B(4);
 *     type = ST_ACK;
 * }
 * </pre>
 */
class INET_API Ieee80211AckFrame : public ::inet::ieee80211::Ieee80211OneAddressHeader
{
  protected:

  private:
    void copy(const Ieee80211AckFrame& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211AckFrame&);

  public:
    Ieee80211AckFrame();
    Ieee80211AckFrame(const Ieee80211AckFrame& other);
    virtual ~Ieee80211AckFrame();
    Ieee80211AckFrame& operator=(const Ieee80211AckFrame& other);
    virtual Ieee80211AckFrame *dup() const override {return new Ieee80211AckFrame(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211AckFrame& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211AckFrame& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:157</tt> by nedtool.
 * <pre>
 * //
 * // Format of a 802.11 frame with address1 and address2 present
 * //
 * class Ieee80211TwoAddressHeader extends Ieee80211OneAddressHeader
 * {
 *     chunkLength = LENGTH_RTS - B(4);
 *     MacAddress transmitterAddress; // aka address2
 * }
 * </pre>
 */
class INET_API Ieee80211TwoAddressHeader : public ::inet::ieee80211::Ieee80211OneAddressHeader
{
  protected:
    MacAddress transmitterAddress;

  private:
    void copy(const Ieee80211TwoAddressHeader& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211TwoAddressHeader&);

  public:
    Ieee80211TwoAddressHeader();
    Ieee80211TwoAddressHeader(const Ieee80211TwoAddressHeader& other);
    virtual ~Ieee80211TwoAddressHeader();
    Ieee80211TwoAddressHeader& operator=(const Ieee80211TwoAddressHeader& other);
    virtual Ieee80211TwoAddressHeader *dup() const override {return new Ieee80211TwoAddressHeader(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const MacAddress& getTransmitterAddress() const;
    virtual MacAddress& getTransmitterAddressForUpdate() { handleChange();return const_cast<MacAddress&>(const_cast<Ieee80211TwoAddressHeader*>(this)->getTransmitterAddress());}
    virtual void setTransmitterAddress(const MacAddress& transmitterAddress);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211TwoAddressHeader& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211TwoAddressHeader& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:166</tt> by nedtool.
 * <pre>
 * //
 * // Format of the 802.11 RTS frame
 * //
 * class Ieee80211RtsFrame extends Ieee80211TwoAddressHeader
 * {
 *     chunkLength = LENGTH_RTS - B(4);
 *     type = ST_RTS;
 * }
 * </pre>
 */
class INET_API Ieee80211RtsFrame : public ::inet::ieee80211::Ieee80211TwoAddressHeader
{
  protected:

  private:
    void copy(const Ieee80211RtsFrame& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211RtsFrame&);

  public:
    Ieee80211RtsFrame();
    Ieee80211RtsFrame(const Ieee80211RtsFrame& other);
    virtual ~Ieee80211RtsFrame();
    Ieee80211RtsFrame& operator=(const Ieee80211RtsFrame& other);
    virtual Ieee80211RtsFrame *dup() const override {return new Ieee80211RtsFrame(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211RtsFrame& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211RtsFrame& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:175</tt> by nedtool.
 * <pre>
 * //
 * // Format of the 802.11 CTS frame
 * //
 * class Ieee80211CtsFrame extends Ieee80211OneAddressHeader
 * {
 *     chunkLength = LENGTH_CTS - B(4);
 *     type = ST_CTS;
 * }
 * </pre>
 */
class INET_API Ieee80211CtsFrame : public ::inet::ieee80211::Ieee80211OneAddressHeader
{
  protected:

  private:
    void copy(const Ieee80211CtsFrame& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211CtsFrame&);

  public:
    Ieee80211CtsFrame();
    Ieee80211CtsFrame(const Ieee80211CtsFrame& other);
    virtual ~Ieee80211CtsFrame();
    Ieee80211CtsFrame& operator=(const Ieee80211CtsFrame& other);
    virtual Ieee80211CtsFrame *dup() const override {return new Ieee80211CtsFrame(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211CtsFrame& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211CtsFrame& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:184</tt> by nedtool.
 * <pre>
 * //
 * // Common base class for 802.11 data and management frames
 * //
 * class Ieee80211DataOrMgmtHeader extends Ieee80211TwoAddressHeader
 * {
 *     chunkLength = LENGTH_MGMT - B(4);
 *     MacAddress address3;
 *     short fragmentNumber;
 *     SequenceNumber sequenceNumber;
 * }
 * </pre>
 */
class INET_API Ieee80211DataOrMgmtHeader : public ::inet::ieee80211::Ieee80211TwoAddressHeader
{
  protected:
    MacAddress address3;
    short fragmentNumber = 0;
    SequenceNumber sequenceNumber;

  private:
    void copy(const Ieee80211DataOrMgmtHeader& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211DataOrMgmtHeader&);

  public:
    Ieee80211DataOrMgmtHeader();
    Ieee80211DataOrMgmtHeader(const Ieee80211DataOrMgmtHeader& other);
    virtual ~Ieee80211DataOrMgmtHeader();
    Ieee80211DataOrMgmtHeader& operator=(const Ieee80211DataOrMgmtHeader& other);
    virtual Ieee80211DataOrMgmtHeader *dup() const override {return new Ieee80211DataOrMgmtHeader(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const MacAddress& getAddress3() const;
    virtual MacAddress& getAddress3ForUpdate() { handleChange();return const_cast<MacAddress&>(const_cast<Ieee80211DataOrMgmtHeader*>(this)->getAddress3());}
    virtual void setAddress3(const MacAddress& address3);
    virtual short getFragmentNumber() const;
    virtual void setFragmentNumber(short fragmentNumber);
    virtual const SequenceNumber& getSequenceNumber() const;
    virtual SequenceNumber& getSequenceNumberForUpdate() { handleChange();return const_cast<SequenceNumber&>(const_cast<Ieee80211DataOrMgmtHeader*>(this)->getSequenceNumber());}
    virtual void setSequenceNumber(const SequenceNumber& sequenceNumber);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211DataOrMgmtHeader& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211DataOrMgmtHeader& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:195</tt> by nedtool.
 * <pre>
 * //
 * // Format of the 802.11 data frame
 * //
 * class Ieee80211DataHeader extends Ieee80211DataOrMgmtHeader
 * {
 *     //  The presence of the Address 4 field is determined by the setting of the To DS and From DS subfields of
 *     //  the Frame Control field (see below). The QoS Control field is present when the QoS subfield of the Subtype
 *     //  field is set to 1 (8.3.2.1 Data frame format)
 *     //  FIXME: chunkLength is not a constant value DATAFRAME_HEADER_MINLENGTH (24 bytes).
 *     //  For example, with Address 4 and without QoS the correct length is 30 bytes.
 *     //  Without Address 4 and QoS the correct value is indeed 24 bytes.
 *     //  With Address 4 and QoS the correct value is indeed 32 bytes.
 *     chunkLength = DATAFRAME_HEADER_MINLENGTH;
 *     type = ST_DATA;         // or ST_DATA_WITH_QOS
 *     MacAddress address4;    // optional field, exists when toDS and fromDS are true
 *     AckPolicy ackPolicy = NORMAL_ACK;
 *     uint8 tid;              // optional field, exists when type == ST_DATA_WITH_QOS
 *     bool aMsduPresent = false; // 8.2.4.5.9 A-MSDU Present subfield
 * }
 * 
 * //TODO this can be introduced when the SNAP header 
 * //class Ieee80211QoSDataHeader extends Ieee80211DataHeader
 * //{
 * //    type = ST_DATA_WITH_QOS;
 * //    chunkLength = DATAFRAME_HEADER_MINLENGTH + QOSCONTROL_PART_LENGTH;
 * //    AckPolicy ackPolicy = NORMAL_ACK; //FIXME in real life this is part of the optional qos field above...
 * //    uint8 tid;
 * //    // TODO: other QoS control field parts
 * //}
 * </pre>
 */
class INET_API Ieee80211DataHeader : public ::inet::ieee80211::Ieee80211DataOrMgmtHeader
{
  protected:
    MacAddress address4;
    inet::ieee80211::AckPolicy ackPolicy = NORMAL_ACK;
    uint8_t tid = 0;
    bool aMsduPresent = false;

  private:
    void copy(const Ieee80211DataHeader& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211DataHeader&);

  public:
    Ieee80211DataHeader();
    Ieee80211DataHeader(const Ieee80211DataHeader& other);
    virtual ~Ieee80211DataHeader();
    Ieee80211DataHeader& operator=(const Ieee80211DataHeader& other);
    virtual Ieee80211DataHeader *dup() const override {return new Ieee80211DataHeader(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const MacAddress& getAddress4() const;
    virtual MacAddress& getAddress4ForUpdate() { handleChange();return const_cast<MacAddress&>(const_cast<Ieee80211DataHeader*>(this)->getAddress4());}
    virtual void setAddress4(const MacAddress& address4);
    virtual inet::ieee80211::AckPolicy getAckPolicy() const;
    virtual void setAckPolicy(inet::ieee80211::AckPolicy ackPolicy);
    virtual uint8_t getTid() const;
    virtual void setTid(uint8_t tid);
    virtual bool getAMsduPresent() const;
    virtual void setAMsduPresent(bool aMsduPresent);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211DataHeader& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211DataHeader& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:225</tt> by nedtool.
 * <pre>
 * //
 * // Base class for 802.11 management frames (subclasses will add frame body contents)
 * //
 * class Ieee80211MgmtHeader extends Ieee80211DataOrMgmtHeader
 * {
 * }
 * </pre>
 */
class INET_API Ieee80211MgmtHeader : public ::inet::ieee80211::Ieee80211DataOrMgmtHeader
{
  protected:

  private:
    void copy(const Ieee80211MgmtHeader& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211MgmtHeader&);

  public:
    Ieee80211MgmtHeader();
    Ieee80211MgmtHeader(const Ieee80211MgmtHeader& other);
    virtual ~Ieee80211MgmtHeader();
    Ieee80211MgmtHeader& operator=(const Ieee80211MgmtHeader& other);
    virtual Ieee80211MgmtHeader *dup() const override {return new Ieee80211MgmtHeader(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211MgmtHeader& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211MgmtHeader& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:230</tt> by nedtool.
 * <pre>
 * // 8.3.3.13 Action frame format -- mgmt frame with subtype action
 * class Ieee80211ActionFrame extends Ieee80211MgmtHeader
 * {
 *     type = ST_ACTION;
 *     short category;
 *     // TODO: subclasses will add action subfield contents
 *     //WirelessNetworkManagementAction action; // action TODO: remove it
 * }
 * </pre>
 */
class INET_API Ieee80211ActionFrame : public ::inet::ieee80211::Ieee80211MgmtHeader
{
  protected:
    short category = 0;

  private:
    void copy(const Ieee80211ActionFrame& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211ActionFrame&);

  public:
    Ieee80211ActionFrame();
    Ieee80211ActionFrame(const Ieee80211ActionFrame& other);
    virtual ~Ieee80211ActionFrame();
    Ieee80211ActionFrame& operator=(const Ieee80211ActionFrame& other);
    virtual Ieee80211ActionFrame *dup() const override {return new Ieee80211ActionFrame(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual short getCategory() const;
    virtual void setCategory(short category);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211ActionFrame& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211ActionFrame& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:238</tt> by nedtool.
 * <pre>
 * class Ieee80211MsduSubframeHeader extends FieldsChunk
 * {
 *     chunkLength = LENGTH_A_MSDU_SUBFRAME_HEADER;
 *     MacAddress sa; // source addr.
 *     MacAddress da; // destination addr.
 *     int length;
 * }
 * </pre>
 */
class INET_API Ieee80211MsduSubframeHeader : public ::inet::FieldsChunk
{
  protected:
    MacAddress sa;
    MacAddress da;
    int length = 0;

  private:
    void copy(const Ieee80211MsduSubframeHeader& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211MsduSubframeHeader&);

  public:
    Ieee80211MsduSubframeHeader();
    Ieee80211MsduSubframeHeader(const Ieee80211MsduSubframeHeader& other);
    virtual ~Ieee80211MsduSubframeHeader();
    Ieee80211MsduSubframeHeader& operator=(const Ieee80211MsduSubframeHeader& other);
    virtual Ieee80211MsduSubframeHeader *dup() const override {return new Ieee80211MsduSubframeHeader(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const MacAddress& getSa() const;
    virtual MacAddress& getSaForUpdate() { handleChange();return const_cast<MacAddress&>(const_cast<Ieee80211MsduSubframeHeader*>(this)->getSa());}
    virtual void setSa(const MacAddress& sa);
    virtual const MacAddress& getDa() const;
    virtual MacAddress& getDaForUpdate() { handleChange();return const_cast<MacAddress&>(const_cast<Ieee80211MsduSubframeHeader*>(this)->getDa());}
    virtual void setDa(const MacAddress& da);
    virtual int getLength() const;
    virtual void setLength(int length);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211MsduSubframeHeader& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211MsduSubframeHeader& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:246</tt> by nedtool.
 * <pre>
 * class Ieee80211MpduSubframeHeader extends FieldsChunk
 * {
 *     chunkLength = LENGTH_A_MPDU_SUBFRAME_HEADER;
 *     int length;
 * }
 * </pre>
 */
class INET_API Ieee80211MpduSubframeHeader : public ::inet::FieldsChunk
{
  protected:
    int length = 0;

  private:
    void copy(const Ieee80211MpduSubframeHeader& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211MpduSubframeHeader&);

  public:
    Ieee80211MpduSubframeHeader();
    Ieee80211MpduSubframeHeader(const Ieee80211MpduSubframeHeader& other);
    virtual ~Ieee80211MpduSubframeHeader();
    Ieee80211MpduSubframeHeader& operator=(const Ieee80211MpduSubframeHeader& other);
    virtual Ieee80211MpduSubframeHeader *dup() const override {return new Ieee80211MpduSubframeHeader(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getLength() const;
    virtual void setLength(int length);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211MpduSubframeHeader& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211MpduSubframeHeader& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:255</tt> by nedtool.
 * <pre>
 * //
 * // Table 8-203—ADDBA Request frame Action field format -- 736p.
 * //
 * class Ieee80211AddbaRequest extends Ieee80211ActionFrame
 * {
 *     chunkLength = LENGTH_ADDBAREQ - B(4);
 *     category = 3; // representing Block Ack
 *     int blockAckAction = 0; // representing ADDBA request
 *     int dialogToken = 1; // nonzero, arbitrary
 * 
 *     // Block Ack Parameter Set field
 *     bool aMsduSupported; // The A-MSDU Supported subfield determines whether an A-MSDU may be carried in a QoS data MPDU sent under this Block Ack agreement.
 *     bool blockAckPolicy; // The Block Ack Policy subfield is set to 1 for immediate Block Ack and 0 for delayed Block Ack.
 *     int tid; // The TID subfield contains the value of the TC or TS for which the BlockAck is being requested.
 *     int bufferSize; // The Buffer Size subfield indicates the number of buffers available for this particular TID
 * 
 *     // Block Ack Timeout Value field
 *     // The Block Ack Timeout Value field contains the duration, in TUs, after which the Block Ack setup is
 *     // terminated, if there are no frame exchanges (see 10.5.4) within this duration using this Block Ack
 *     //  agreement. A value of 0 disables the timeout.
 *     simtime_t blockAckTimeoutValue;
 * 
 *     // Block Ack Starting Sequence Control
 *     // The Starting Sequence Number subfield of the Block Ack Starting Sequence Control subfield contains the sequence number of the first MSDU for which this Basic
 *     // BlockAckReq frame is sent. The Fragment Number subfield is set to 0.
 *     int _fragmentNumber = 0; // FIXME: DataOrMgmtFreme has a fragmentNumber
 *     SequenceNumber startingSequenceNumber; // the sequence number of the first MSDU
 * 
 * }
 * </pre>
 */
class INET_API Ieee80211AddbaRequest : public ::inet::ieee80211::Ieee80211ActionFrame
{
  protected:
    int blockAckAction = 0;
    int dialogToken = 1;
    bool aMsduSupported = false;
    bool blockAckPolicy = false;
    int tid = 0;
    int bufferSize = 0;
    omnetpp::simtime_t blockAckTimeoutValue = SIMTIME_ZERO;
    int _fragmentNumber = 0;
    SequenceNumber startingSequenceNumber;

  private:
    void copy(const Ieee80211AddbaRequest& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211AddbaRequest&);

  public:
    Ieee80211AddbaRequest();
    Ieee80211AddbaRequest(const Ieee80211AddbaRequest& other);
    virtual ~Ieee80211AddbaRequest();
    Ieee80211AddbaRequest& operator=(const Ieee80211AddbaRequest& other);
    virtual Ieee80211AddbaRequest *dup() const override {return new Ieee80211AddbaRequest(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getBlockAckAction() const;
    virtual void setBlockAckAction(int blockAckAction);
    virtual int getDialogToken() const;
    virtual void setDialogToken(int dialogToken);
    virtual bool getAMsduSupported() const;
    virtual void setAMsduSupported(bool aMsduSupported);
    virtual bool getBlockAckPolicy() const;
    virtual void setBlockAckPolicy(bool blockAckPolicy);
    virtual int getTid() const;
    virtual void setTid(int tid);
    virtual int getBufferSize() const;
    virtual void setBufferSize(int bufferSize);
    virtual omnetpp::simtime_t getBlockAckTimeoutValue() const;
    virtual void setBlockAckTimeoutValue(omnetpp::simtime_t blockAckTimeoutValue);
    virtual int get_fragmentNumber() const;
    virtual void set_fragmentNumber(int _fragmentNumber);
    virtual const SequenceNumber& getStartingSequenceNumber() const;
    virtual SequenceNumber& getStartingSequenceNumberForUpdate() { handleChange();return const_cast<SequenceNumber&>(const_cast<Ieee80211AddbaRequest*>(this)->getStartingSequenceNumber());}
    virtual void setStartingSequenceNumber(const SequenceNumber& startingSequenceNumber);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211AddbaRequest& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211AddbaRequest& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:282</tt> by nedtool.
 * <pre>
 * class Ieee80211AddbaResponse extends Ieee80211ActionFrame
 * {
 *     // chunkLength TODO
 *     category = 3; // representing Block Ack
 *     int blockAckAction = 1; // representing ADDBA response
 *     int dialogToken = 1; // The Dialog Token field value is copied from the corresponding received ADDBA Request frame.
 *     int statusCode; // The Status Code field is used in a response management frame to indicate the success or failure of a requested operation.
 * 
 *     // Block Ack Parameter Set field
 *     bool aMsduSupported; // The A-MSDU Supported subfield determines whether an A-MSDU may be carried in a QoS data MPDU sent under this Block Ack agreement.
 *     bool blockAckPolicy; // The Block Ack Policy subfield is set to 1 for immediate Block Ack and 0 for delayed Block Ack.
 *     int tid; // The TID subfield contains the value of the TC or TS for which the BlockAck is being requested.
 *     int bufferSize; // The Buffer Size subfield indicates the number of buffers available for this particular TID
 * 
 *     // Block Ack Timeout Value field
 *     // The Block Ack Timeout Value field contains the duration, in TUs, after which the Block Ack setup is
 *     // terminated, if there are no frame exchanges (see 10.5.4) within this duration using this Block Ack
 *     //  agreement. A value of 0 disables the timeout.
 *     simtime_t blockAckTimeoutValue;
 * }
 * </pre>
 */
class INET_API Ieee80211AddbaResponse : public ::inet::ieee80211::Ieee80211ActionFrame
{
  protected:
    int blockAckAction = 1;
    int dialogToken = 1;
    int statusCode = 0;
    bool aMsduSupported = false;
    bool blockAckPolicy = false;
    int tid = 0;
    int bufferSize = 0;
    omnetpp::simtime_t blockAckTimeoutValue = SIMTIME_ZERO;

  private:
    void copy(const Ieee80211AddbaResponse& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211AddbaResponse&);

  public:
    Ieee80211AddbaResponse();
    Ieee80211AddbaResponse(const Ieee80211AddbaResponse& other);
    virtual ~Ieee80211AddbaResponse();
    Ieee80211AddbaResponse& operator=(const Ieee80211AddbaResponse& other);
    virtual Ieee80211AddbaResponse *dup() const override {return new Ieee80211AddbaResponse(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getBlockAckAction() const;
    virtual void setBlockAckAction(int blockAckAction);
    virtual int getDialogToken() const;
    virtual void setDialogToken(int dialogToken);
    virtual int getStatusCode() const;
    virtual void setStatusCode(int statusCode);
    virtual bool getAMsduSupported() const;
    virtual void setAMsduSupported(bool aMsduSupported);
    virtual bool getBlockAckPolicy() const;
    virtual void setBlockAckPolicy(bool blockAckPolicy);
    virtual int getTid() const;
    virtual void setTid(int tid);
    virtual int getBufferSize() const;
    virtual void setBufferSize(int bufferSize);
    virtual omnetpp::simtime_t getBlockAckTimeoutValue() const;
    virtual void setBlockAckTimeoutValue(omnetpp::simtime_t blockAckTimeoutValue);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211AddbaResponse& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211AddbaResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:306</tt> by nedtool.
 * <pre>
 * //
 * // 8.5.5.4 DELBA frame format
 * //
 * class Ieee80211Delba extends Ieee80211ActionFrame
 * {
 *     // chunkLength TODO
 *     category = 3;
 *     int blockAckAction = 2; // representing DELBA
 * 
 *     // DELBA Parameter Set
 *     // It is set to 1 to indicate the originator and is set to 0 to indicate the recipient.
 *     // The Initiator subfield indicates if the originator or the recipient of the data is sending this frame.
 *     bool initiator;
 * 
 *     // The TID subfield indicates the TSID or the UP for which the Block Ack has been originally set up.
 *     int tid;
 * 
 *     // This Reason Code field is used to indicate the reason that an unsolicited notification management frame of
 *     // type Disassociation, Deauthentication, DELTS, DELBA, DLS Teardown, or Mesh Peering Close was
 *     // generated.
 *     int reasonCode;
 * }
 * </pre>
 */
class INET_API Ieee80211Delba : public ::inet::ieee80211::Ieee80211ActionFrame
{
  protected:
    int blockAckAction = 2;
    bool initiator = false;
    int tid = 0;
    int reasonCode = 0;

  private:
    void copy(const Ieee80211Delba& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211Delba&);

  public:
    Ieee80211Delba();
    Ieee80211Delba(const Ieee80211Delba& other);
    virtual ~Ieee80211Delba();
    Ieee80211Delba& operator=(const Ieee80211Delba& other);
    virtual Ieee80211Delba *dup() const override {return new Ieee80211Delba(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getBlockAckAction() const;
    virtual void setBlockAckAction(int blockAckAction);
    virtual bool getInitiator() const;
    virtual void setInitiator(bool initiator);
    virtual int getTid() const;
    virtual void setTid(int tid);
    virtual int getReasonCode() const;
    virtual void setReasonCode(int reasonCode);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211Delba& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211Delba& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:329</tt> by nedtool.
 * <pre>
 * //
 * // 8.3.1.8 BlockAckReq frame format
 * //
 * class Ieee80211BlockAckReq extends Ieee80211TwoAddressHeader
 * {
 *     // chunkLength TODO
 *     // The RA field of the BlockAck frame is the address of the recipient STA that requested the Block Ack.
 *     // The TA field is the address of the STA transmitting the BlockAck frame.
 *     type = ST_BLOCKACK_REQ;
 * 
 *     bool multiTid;
 *     bool compressedBitmap;
 *     bool barAckPolicy; // 0-Normal Acknowledgment, 1-No Acknowledgment.
 * }
 * </pre>
 */
class INET_API Ieee80211BlockAckReq : public ::inet::ieee80211::Ieee80211TwoAddressHeader
{
  protected:
    bool multiTid = false;
    bool compressedBitmap = false;
    bool barAckPolicy = false;

  private:
    void copy(const Ieee80211BlockAckReq& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211BlockAckReq&);

  public:
    Ieee80211BlockAckReq();
    Ieee80211BlockAckReq(const Ieee80211BlockAckReq& other);
    virtual ~Ieee80211BlockAckReq();
    Ieee80211BlockAckReq& operator=(const Ieee80211BlockAckReq& other);
    virtual Ieee80211BlockAckReq *dup() const override {return new Ieee80211BlockAckReq(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual bool getMultiTid() const;
    virtual void setMultiTid(bool multiTid);
    virtual bool getCompressedBitmap() const;
    virtual void setCompressedBitmap(bool compressedBitmap);
    virtual bool getBarAckPolicy() const;
    virtual void setBarAckPolicy(bool barAckPolicy);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211BlockAckReq& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211BlockAckReq& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:341</tt> by nedtool.
 * <pre>
 * class Ieee80211BasicBlockAckReq extends Ieee80211BlockAckReq
 * {
 *     int tidInfo; //  The TID_INFO subfield of the BAR Control field of the Basic BlockAckReq frame contains the TID for which a Basic BlockAck frame is requested.
 * 
 *     // The BAR Information field of the Basic BlockAckReq frame contains the Block Ack Starting Sequence
 *     // Control subfield, as shown in Figure 8-21. The Starting Sequence Number subfield of the Block Ack
 *     // Starting Sequence Control subfield contains the sequence number of the first MSDU for which this Basic
 *     // BlockAckReq frame is sent. The Fragment Number subfield is set to 0.
 *     int fragmentNumber = 0;
 *     SequenceNumber startingSequenceNumber;
 * 
 *     multiTid = 0;
 *     compressedBitmap = 0;
 * }
 * </pre>
 */
class INET_API Ieee80211BasicBlockAckReq : public ::inet::ieee80211::Ieee80211BlockAckReq
{
  protected:
    int tidInfo = 0;
    int fragmentNumber = 0;
    SequenceNumber startingSequenceNumber;

  private:
    void copy(const Ieee80211BasicBlockAckReq& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211BasicBlockAckReq&);

  public:
    Ieee80211BasicBlockAckReq();
    Ieee80211BasicBlockAckReq(const Ieee80211BasicBlockAckReq& other);
    virtual ~Ieee80211BasicBlockAckReq();
    Ieee80211BasicBlockAckReq& operator=(const Ieee80211BasicBlockAckReq& other);
    virtual Ieee80211BasicBlockAckReq *dup() const override {return new Ieee80211BasicBlockAckReq(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getTidInfo() const;
    virtual void setTidInfo(int tidInfo);
    virtual int getFragmentNumber() const;
    virtual void setFragmentNumber(int fragmentNumber);
    virtual const SequenceNumber& getStartingSequenceNumber() const;
    virtual SequenceNumber& getStartingSequenceNumberForUpdate() { handleChange();return const_cast<SequenceNumber&>(const_cast<Ieee80211BasicBlockAckReq*>(this)->getStartingSequenceNumber());}
    virtual void setStartingSequenceNumber(const SequenceNumber& startingSequenceNumber);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211BasicBlockAckReq& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211BasicBlockAckReq& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:358</tt> by nedtool.
 * <pre>
 * class Ieee80211CompressedBlockAckReq extends Ieee80211BlockAckReq
 * {
 *     int tidInfo; // The TID_INFO subfield of the BAR Control field of the Compressed BlockAckReq frame contains the TID for which a BlockAck frame is requested.
 * 
 *     // The RA field of the BlockAck frame is the address of the recipient STA that requested the Block Ack.
 *     // The TA field is the address of the STA transmitting the BlockAck frame.
 *     type = ST_BLOCKACK_REQ;
 *     // The BAR Information field of the Compressed BlockAckReq frame contains the Block Ack Starting
 *     // Sequence Control subfield, as shown in Figure 8-21. The Starting Sequence Number subfield of the Block
 *     // Ack Starting Sequence Control subfield contains the sequence number of the first MSDU or A-MSDU for
 *     // which this BlockAckReq frame is sent. The Fragment Number subfield of the Block Ack Starting Sequence
 *     // Control subfield is set to 0.
 * 
 *     int fragmentNumber = 0;
 *     SequenceNumber startingSequenceNumber;
 * 
 *     multiTid = 0;
 *     compressedBitmap = 1;
 * }
 * </pre>
 */
class INET_API Ieee80211CompressedBlockAckReq : public ::inet::ieee80211::Ieee80211BlockAckReq
{
  protected:
    int tidInfo = 0;
    int fragmentNumber = 0;
    SequenceNumber startingSequenceNumber;

  private:
    void copy(const Ieee80211CompressedBlockAckReq& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211CompressedBlockAckReq&);

  public:
    Ieee80211CompressedBlockAckReq();
    Ieee80211CompressedBlockAckReq(const Ieee80211CompressedBlockAckReq& other);
    virtual ~Ieee80211CompressedBlockAckReq();
    Ieee80211CompressedBlockAckReq& operator=(const Ieee80211CompressedBlockAckReq& other);
    virtual Ieee80211CompressedBlockAckReq *dup() const override {return new Ieee80211CompressedBlockAckReq(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getTidInfo() const;
    virtual void setTidInfo(int tidInfo);
    virtual int getFragmentNumber() const;
    virtual void setFragmentNumber(int fragmentNumber);
    virtual const SequenceNumber& getStartingSequenceNumber() const;
    virtual SequenceNumber& getStartingSequenceNumberForUpdate() { handleChange();return const_cast<SequenceNumber&>(const_cast<Ieee80211CompressedBlockAckReq*>(this)->getStartingSequenceNumber());}
    virtual void setStartingSequenceNumber(const SequenceNumber& startingSequenceNumber);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211CompressedBlockAckReq& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211CompressedBlockAckReq& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:380</tt> by nedtool.
 * <pre>
 * class Ieee80211MultiTidBlockAckReq extends Ieee80211BlockAckReq
 * {
 *     // chunkLength TODO
 *     // The RA field of the BlockAck frame is the address of the recipient STA that requested the Block Ack.
 *     // The TA field is the address of the STA transmitting the BlockAck frame.
 *     type = ST_BLOCKACK_REQ;
 *     // The BAR Information field of the Compressed BlockAckReq frame contains the Block Ack Starting
 *     // Sequence Control subfield, as shown in Figure 8-21. The Starting Sequence Number subfield of the Block
 *     // Ack Starting Sequence Control subfield contains the sequence number of the first MSDU or A-MSDU for
 *     // which this BlockAckReq frame is sent. The Fragment Number subfield of the Block Ack Starting Sequence
 *     // Control subfield is set to 0.
 * 
 *     multiTid = 1;
 *     compressedBitmap = 1;
 * 
 *     // TODO: unimplemented
 * }
 * </pre>
 */
class INET_API Ieee80211MultiTidBlockAckReq : public ::inet::ieee80211::Ieee80211BlockAckReq
{
  protected:

  private:
    void copy(const Ieee80211MultiTidBlockAckReq& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211MultiTidBlockAckReq&);

  public:
    Ieee80211MultiTidBlockAckReq();
    Ieee80211MultiTidBlockAckReq(const Ieee80211MultiTidBlockAckReq& other);
    virtual ~Ieee80211MultiTidBlockAckReq();
    Ieee80211MultiTidBlockAckReq& operator=(const Ieee80211MultiTidBlockAckReq& other);
    virtual Ieee80211MultiTidBlockAckReq *dup() const override {return new Ieee80211MultiTidBlockAckReq(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211MultiTidBlockAckReq& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211MultiTidBlockAckReq& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:401</tt> by nedtool.
 * <pre>
 * //
 * // 8.3.1.9 BlockAck frame format -- 410p.
 * //
 * class Ieee80211BlockAck extends Ieee80211TwoAddressHeader
 * {
 *     // chunkLength TODO
 *     // The RA field of the BlockAck frame is the address of the recipient STA that requested the Block Ack.
 *     // The TA field is the address of the STA transmitting the BlockAck frame.
 *     type = ST_BLOCKACK;
 * 
 *     // BA Control
 *     bool blockAckPolicy; // Table 8-17—BA Ack Policy subfield: 0-Normal Acknowledgment, 1-No Acknowledgment.
 * 
 *     // Table 8-18—BlockAck frame variant encoding
 *     bool multiTid;
 *     bool compressedBitmap;
 * }
 * </pre>
 */
class INET_API Ieee80211BlockAck : public ::inet::ieee80211::Ieee80211TwoAddressHeader
{
  protected:
    bool blockAckPolicy = false;
    bool multiTid = false;
    bool compressedBitmap = false;

  private:
    void copy(const Ieee80211BlockAck& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211BlockAck&);

  public:
    Ieee80211BlockAck();
    Ieee80211BlockAck(const Ieee80211BlockAck& other);
    virtual ~Ieee80211BlockAck();
    Ieee80211BlockAck& operator=(const Ieee80211BlockAck& other);
    virtual Ieee80211BlockAck *dup() const override {return new Ieee80211BlockAck(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual bool getBlockAckPolicy() const;
    virtual void setBlockAckPolicy(bool blockAckPolicy);
    virtual bool getMultiTid() const;
    virtual void setMultiTid(bool multiTid);
    virtual bool getCompressedBitmap() const;
    virtual void setCompressedBitmap(bool compressedBitmap);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211BlockAck& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211BlockAck& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:419</tt> by nedtool.
 * <pre>
 * //
 * // 8.3.1.9.2 Basic BlockAck variant -- 411p.
 * //
 * class Ieee80211BasicBlockAck extends Ieee80211BlockAck
 * {
 *     chunkLength = LENGTH_BASIC_BLOCKACK - B(4);
 *     multiTid = 0;
 *     compressedBitmap = 0;
 * 
 *     // The BA Information field of the Basic BlockAck frame comprises the Block Ack Starting Sequence Control
 *     // subfield and the Block Ack Bitmap subfield, as shown in Figure 8-26.
 * 
 *     int fragmentNumber = 0; // ??
 *     SequenceNumber startingSequenceNumber;
 *     // The Block Ack Bitmap subfield is 128 octets in length and is used to indicate the received status of up to
 *     // 64 MSDUs. Bit position n of the Block Ack bitmap, if equal to 1, acknowledges receipt of an MPDU with an
 *     // MPDU sequence control value equal to (Block Ack Starting Sequence Control + n). Bit position n of the
 *     // Block Ack bitmap, if equal to 0, indicates that an MPDU with MPDU sequence control value equal to
 *     // (Block Ack Starting Sequence Control + n) has not been received. Each of the MPDU Sequence Control
 *     // field and Block Ack Starting Sequence Control subfield values are treated as a 16-bit unsigned integer. For
 *     // unused fragment numbers of an MSDU, the corresponding bits in the bitmap are set to 0.
 *     BitVector blockAckBitmap[64]; // 64 * 16 bitmatrix
 * 
 *     // The TID_INFO subfield of the BA Control field of the Basic BlockAck frame contains the TID for which
 *     // this BlockAck frame is sent.
 *     int tidInfo;
 * }
 * </pre>
 */
class INET_API Ieee80211BasicBlockAck : public ::inet::ieee80211::Ieee80211BlockAck
{
  protected:
    int fragmentNumber = 0;
    SequenceNumber startingSequenceNumber;
    BitVector blockAckBitmap[64];
    int tidInfo = 0;

  private:
    void copy(const Ieee80211BasicBlockAck& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211BasicBlockAck&);

  public:
    Ieee80211BasicBlockAck();
    Ieee80211BasicBlockAck(const Ieee80211BasicBlockAck& other);
    virtual ~Ieee80211BasicBlockAck();
    Ieee80211BasicBlockAck& operator=(const Ieee80211BasicBlockAck& other);
    virtual Ieee80211BasicBlockAck *dup() const override {return new Ieee80211BasicBlockAck(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getFragmentNumber() const;
    virtual void setFragmentNumber(int fragmentNumber);
    virtual const SequenceNumber& getStartingSequenceNumber() const;
    virtual SequenceNumber& getStartingSequenceNumberForUpdate() { handleChange();return const_cast<SequenceNumber&>(const_cast<Ieee80211BasicBlockAck*>(this)->getStartingSequenceNumber());}
    virtual void setStartingSequenceNumber(const SequenceNumber& startingSequenceNumber);
    virtual size_t getBlockAckBitmapArraySize() const;
    virtual const BitVector& getBlockAckBitmap(size_t k) const;
    virtual BitVector& getBlockAckBitmapForUpdate(size_t k) { handleChange();return const_cast<BitVector&>(const_cast<Ieee80211BasicBlockAck*>(this)->getBlockAckBitmap(k));}
    virtual void setBlockAckBitmap(size_t k, const BitVector& blockAckBitmap);
    virtual int getTidInfo() const;
    virtual void setTidInfo(int tidInfo);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211BasicBlockAck& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211BasicBlockAck& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:447</tt> by nedtool.
 * <pre>
 * //
 * // 8.3.1.9.3 Compressed BlockAck variant
 * //
 * class Ieee80211CompressedBlockAck extends Ieee80211BlockAck
 * {
 *     // chunkLength TODO
 *     multiTid = 0;
 *     compressedBitmap = 1;
 * 
 *     // The BA Information field of the Compressed BlockAck frame comprises the Block Ack Starting Sequence
 *     // Control subfield and the Block Ack Bitmap subfield, as shown in Figure 8-27.
 * 
 *     int fragmentNumber = 0;
 *     SequenceNumber startingSequenceNumber;
 *     BitVector blockAckBitmap; // 64 bits
 * 
 *     // The TID_INFO subfield of the BA Control field of the Compressed BlockAck frame contains the TID for
 *     // which this BlockAck frame is sent.
 *     int tidInfo;
 * }
 * </pre>
 */
class INET_API Ieee80211CompressedBlockAck : public ::inet::ieee80211::Ieee80211BlockAck
{
  protected:
    int fragmentNumber = 0;
    SequenceNumber startingSequenceNumber;
    BitVector blockAckBitmap;
    int tidInfo = 0;

  private:
    void copy(const Ieee80211CompressedBlockAck& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211CompressedBlockAck&);

  public:
    Ieee80211CompressedBlockAck();
    Ieee80211CompressedBlockAck(const Ieee80211CompressedBlockAck& other);
    virtual ~Ieee80211CompressedBlockAck();
    Ieee80211CompressedBlockAck& operator=(const Ieee80211CompressedBlockAck& other);
    virtual Ieee80211CompressedBlockAck *dup() const override {return new Ieee80211CompressedBlockAck(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getFragmentNumber() const;
    virtual void setFragmentNumber(int fragmentNumber);
    virtual const SequenceNumber& getStartingSequenceNumber() const;
    virtual SequenceNumber& getStartingSequenceNumberForUpdate() { handleChange();return const_cast<SequenceNumber&>(const_cast<Ieee80211CompressedBlockAck*>(this)->getStartingSequenceNumber());}
    virtual void setStartingSequenceNumber(const SequenceNumber& startingSequenceNumber);
    virtual const BitVector& getBlockAckBitmap() const;
    virtual BitVector& getBlockAckBitmapForUpdate() { handleChange();return const_cast<BitVector&>(const_cast<Ieee80211CompressedBlockAck*>(this)->getBlockAckBitmap());}
    virtual void setBlockAckBitmap(const BitVector& blockAckBitmap);
    virtual int getTidInfo() const;
    virtual void setTidInfo(int tidInfo);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211CompressedBlockAck& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211CompressedBlockAck& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:468</tt> by nedtool.
 * <pre>
 * //
 * // 8.3.1.9.4 Multi-TID BlockAck variant
 * //
 * class Ieee80211MultiTidBlockAck extends Ieee80211BlockAck
 * {
 *     // chunkLength TODO
 *     multiTid = 1;
 *     compressedBitmap = 1;
 * 
 *     // TODO: unimplemented
 * }
 * </pre>
 */
class INET_API Ieee80211MultiTidBlockAck : public ::inet::ieee80211::Ieee80211BlockAck
{
  protected:

  private:
    void copy(const Ieee80211MultiTidBlockAck& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211MultiTidBlockAck&);

  public:
    Ieee80211MultiTidBlockAck();
    Ieee80211MultiTidBlockAck(const Ieee80211MultiTidBlockAck& other);
    virtual ~Ieee80211MultiTidBlockAck();
    Ieee80211MultiTidBlockAck& operator=(const Ieee80211MultiTidBlockAck& other);
    virtual Ieee80211MultiTidBlockAck *dup() const override {return new Ieee80211MultiTidBlockAck(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211MultiTidBlockAck& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211MultiTidBlockAck& obj) {obj.parsimUnpack(b);}

} // namespace ieee80211
} // namespace inet

#endif // ifndef __INET_IEEE80211FRAME_M_H

