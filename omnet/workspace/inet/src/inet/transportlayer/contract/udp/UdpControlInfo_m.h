//
// Generated file, do not edit! Created by nedtool 5.6 from inet/transportlayer/contract/udp/UdpControlInfo.msg.
//

#ifndef __INET_UDPCONTROLINFO_M_H
#define __INET_UDPCONTROLINFO_M_H

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0506
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif

// dll export symbol
#ifndef INET_API
#  if defined(INET_EXPORT)
#    define INET_API  OPP_DLLEXPORT
#  elif defined(INET_IMPORT)
#    define INET_API  OPP_DLLIMPORT
#  else
#    define INET_API
#  endif
#endif


namespace inet {

class UdpControlInfo;
class UdpBindCommand;
class UdpConnectCommand;
class UdpCloseCommand;
class UdpSocketClosedIndication;
class UdpDestroyCommand;
class UdpErrorIndication;
class UdpSetOptionCommand;
class UdpSetTimeToLiveCommand;
class UdpSetTypeOfServiceCommand;
class UdpSetBroadcastCommand;
class UdpSetMulticastInterfaceCommand;
class UdpSetMulticastLoopCommand;
class UdpSetReuseAddressCommand;
class UdpJoinMulticastGroupsCommand;
class UdpLeaveMulticastGroupsCommand;
class UdpBlockMulticastSourcesCommand;
class UdpUnblockMulticastSourcesCommand;
class UdpJoinMulticastSourcesCommand;
class UdpLeaveMulticastSourcesCommand;
class UdpSetMulticastSourceFilterCommand;
} // namespace inet

#include "inet/common/INETDefs_m.h" // import inet.common.INETDefs

#include "inet/networklayer/common/IpProtocolId_m.h" // import inet.networklayer.common.IpProtocolId

#include "inet/networklayer/common/L3Address_m.h" // import inet.networklayer.common.L3Address


namespace inet {

/**
 * Enum generated from <tt>inet/transportlayer/contract/udp/UdpControlInfo.msg:32</tt> by nedtool.
 * <pre>
 * //
 * // Udp command codes, sent by the application to ~Udp. These constants
 * // should be set as message kind on messages sent to the ~Udp entity.
 * //
 * // \@see ~UdpControlInfo, ~UdpStatusInd, ~Udp
 * //
 * enum UdpCommandCode
 * {
 *     UDP_C_DATA = 0;      // send()/sendTo(); see ~UDPSendCommand
 *     UDP_C_BIND = 1;      // bind(); see ~UdpBindCommand
 *     UDP_C_CONNECT = 2;   // connect(); see ~UdpConnectCommand
 *     UDP_C_SETOPTION = 3; // setsockopt(); see ~UdpSetTimeToLiveCommand,...
 *     UDP_C_CLOSE = 4;     // close(); see ~UdpCloseCommand
 *     UDP_C_DESTROY = 5;   // destroy(); see ~UdpDestroyCommand
 * }
 * </pre>
 */
enum UdpCommandCode {
    UDP_C_DATA = 0,
    UDP_C_BIND = 1,
    UDP_C_CONNECT = 2,
    UDP_C_SETOPTION = 3,
    UDP_C_CLOSE = 4,
    UDP_C_DESTROY = 5
};

/**
 * Enum generated from <tt>inet/transportlayer/contract/udp/UdpControlInfo.msg:49</tt> by nedtool.
 * <pre>
 * //
 * // Udp indications, sent by ~Udp to the application. ~Udp will set these
 * // constants as message kind on messages it sends to the application.
 * //
 * // \@see ~UdpControlInfo, ~UdpCommandCode, ~Udp
 * //
 * enum UdpStatusInd
 * {
 *     UDP_I_DATA = 0;  // ~Udp attaches ~UDPIndication to received data packet
 *     UDP_I_ERROR = 1;
 *     UDP_I_SOCKET_CLOSED = 2;
 * }
 * </pre>
 */
enum UdpStatusInd {
    UDP_I_DATA = 0,
    UDP_I_ERROR = 1,
    UDP_I_SOCKET_CLOSED = 2
};

/**
 * Class generated from <tt>inet/transportlayer/contract/udp/UdpControlInfo.msg:63</tt> by nedtool.
 * <pre>
 * //
 * // Base class for UDP control info classes. The most convenient way to handle
 * // ~Udp is the UdpSocket class, which hides control info from you.
 * //
 * // \@see ~UdpCommandCode
 * //
 * class UdpControlInfo extends cObject
 * {
 * }
 * </pre>
 */
class INET_API UdpControlInfo : public ::omnetpp::cObject
{
  protected:

  private:
    void copy(const UdpControlInfo& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UdpControlInfo&);

  public:
    UdpControlInfo();
    UdpControlInfo(const UdpControlInfo& other);
    virtual ~UdpControlInfo();
    UdpControlInfo& operator=(const UdpControlInfo& other);
    virtual UdpControlInfo *dup() const override {return new UdpControlInfo(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UdpControlInfo& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UdpControlInfo& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/contract/udp/UdpControlInfo.msg:77</tt> by nedtool.
 * <pre>
 * //
 * // Control info for binding an UDP socket. To create and bind a socket,
 * // send a message to the ~Udp module with kind=UDP_C_BIND and an
 * // ~UdpBindCommand attached.
 * //
 * // Both the address and the port may be left unset. If the port is
 * // unset, ~Udp will assign an ephemeral port.
 * //
 * // \@see ~UdpCommandCode
 * //
 * class UdpBindCommand extends UdpControlInfo
 * {
 *     L3Address localAddr;
 *     int localPort = -1;
 * }
 * </pre>
 */
class INET_API UdpBindCommand : public ::inet::UdpControlInfo
{
  protected:
    L3Address localAddr;
    int localPort = -1;

  private:
    void copy(const UdpBindCommand& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UdpBindCommand&);

  public:
    UdpBindCommand();
    UdpBindCommand(const UdpBindCommand& other);
    virtual ~UdpBindCommand();
    UdpBindCommand& operator=(const UdpBindCommand& other);
    virtual UdpBindCommand *dup() const override {return new UdpBindCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const L3Address& getLocalAddr() const;
    virtual L3Address& getLocalAddrForUpdate() { return const_cast<L3Address&>(const_cast<UdpBindCommand*>(this)->getLocalAddr());}
    virtual void setLocalAddr(const L3Address& localAddr);
    virtual int getLocalPort() const;
    virtual void setLocalPort(int localPort);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UdpBindCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UdpBindCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/contract/udp/UdpControlInfo.msg:93</tt> by nedtool.
 * <pre>
 * //
 * // Control info for connecting an UDP socket. To connect a socket,
 * // send a message to the ~Udp module with kind=UDP_C_CONNECT and an
 * // ~UdpConnectCommand attached. If the socket does not exist,
 * // it will be created.
 * //
 * // Both the address and the port must be filled in.
 * //
 * // \@see ~UdpCommandCode
 * //
 * class UdpConnectCommand extends UdpControlInfo
 * {
 *     L3Address remoteAddr;
 *     int remotePort = -1;
 * }
 * 
 * 
 * //
 * // Control info for sending data via UDP. To send a packet, send it to
 * // the ~Udp module with kind=UDP_C_SEND and an ~UDPSendCommand attached.
 * //
 * // UDP_C_SEND/~UDPSendCommand models both the Unix send() and sendto() calls.
 * // If the socket is connected, tags not required, or destAddr/destPort may be left blank (send()),
 * // otherwise it must contain the destination for the packet (sendto()).
 * //
 * // \@see ~UdpCommandCode, ~PortsReq, ~L3AddressReq, ~InterfaceReq
 * //
 * </pre>
 */
class INET_API UdpConnectCommand : public ::inet::UdpControlInfo
{
  protected:
    L3Address remoteAddr;
    int remotePort = -1;

  private:
    void copy(const UdpConnectCommand& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UdpConnectCommand&);

  public:
    UdpConnectCommand();
    UdpConnectCommand(const UdpConnectCommand& other);
    virtual ~UdpConnectCommand();
    UdpConnectCommand& operator=(const UdpConnectCommand& other);
    virtual UdpConnectCommand *dup() const override {return new UdpConnectCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const L3Address& getRemoteAddr() const;
    virtual L3Address& getRemoteAddrForUpdate() { return const_cast<L3Address&>(const_cast<UdpConnectCommand*>(this)->getRemoteAddr());}
    virtual void setRemoteAddr(const L3Address& remoteAddr);
    virtual int getRemotePort() const;
    virtual void setRemotePort(int remotePort);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UdpConnectCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UdpConnectCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/contract/udp/UdpControlInfo.msg:119</tt> by nedtool.
 * <pre>
 * //
 * // Control info for closing an UDP socket. To close a socket, send a message
 * // to the ~Udp module with kind=UDP_C_CLOSE and an ~UdpCloseCommand attached.
 * // The Udp module will send an ~UdpSocketClosedIndication answer.
 * //
 * // \@see ~UdpCommandCode
 * //
 * class UdpCloseCommand extends UdpControlInfo
 * {
 * }
 * </pre>
 */
class INET_API UdpCloseCommand : public ::inet::UdpControlInfo
{
  protected:

  private:
    void copy(const UdpCloseCommand& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UdpCloseCommand&);

  public:
    UdpCloseCommand();
    UdpCloseCommand(const UdpCloseCommand& other);
    virtual ~UdpCloseCommand();
    UdpCloseCommand& operator=(const UdpCloseCommand& other);
    virtual UdpCloseCommand *dup() const override {return new UdpCloseCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UdpCloseCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UdpCloseCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/contract/udp/UdpControlInfo.msg:129</tt> by nedtool.
 * <pre>
 * //
 * // Control info for inform app about an UDP socket closed.
 * // This is answer to an ~UdpCloseCommand.
 * //
 * // \@see ~UdpCommandCode
 * //
 * class UdpSocketClosedIndication extends UdpControlInfo
 * {
 * }
 * </pre>
 */
class INET_API UdpSocketClosedIndication : public ::inet::UdpControlInfo
{
  protected:

  private:
    void copy(const UdpSocketClosedIndication& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UdpSocketClosedIndication&);

  public:
    UdpSocketClosedIndication();
    UdpSocketClosedIndication(const UdpSocketClosedIndication& other);
    virtual ~UdpSocketClosedIndication();
    UdpSocketClosedIndication& operator=(const UdpSocketClosedIndication& other);
    virtual UdpSocketClosedIndication *dup() const override {return new UdpSocketClosedIndication(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UdpSocketClosedIndication& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UdpSocketClosedIndication& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/contract/udp/UdpControlInfo.msg:139</tt> by nedtool.
 * <pre>
 * //
 * // Control info for destroying an UDP socket. To destroy a socket, send a message
 * // to the ~Udp module with kind=UDP_C_DESTROY and an ~UdpDestroyCommand attached.
 * //
 * // \@see ~UdpCommandCode
 * //
 * class UdpDestroyCommand extends UdpControlInfo
 * {
 * }
 * 
 * //
 * // Control info that is attached to received data packets, sent up from the
 * // ~Udp module to the application with UDP_I_DATA as message kind.
 * //
 * // \@see ~UdpCommandCode, ~L3AddressInd, ~PortsInd
 * //
 * </pre>
 */
class INET_API UdpDestroyCommand : public ::inet::UdpControlInfo
{
  protected:

  private:
    void copy(const UdpDestroyCommand& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UdpDestroyCommand&);

  public:
    UdpDestroyCommand();
    UdpDestroyCommand(const UdpDestroyCommand& other);
    virtual ~UdpDestroyCommand();
    UdpDestroyCommand& operator=(const UdpDestroyCommand& other);
    virtual UdpDestroyCommand *dup() const override {return new UdpDestroyCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UdpDestroyCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UdpDestroyCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/contract/udp/UdpControlInfo.msg:157</tt> by nedtool.
 * <pre>
 * //
 * // Control info that is sent up from the ~Udp module to the application with
 * // UDP_I_ERROR as message kind when ~Udp receives an Icmp error for a packet
 * // previously sent from the socket.
 * //
 * // \@see ~UdpCommandCode
 * //
 * class UdpErrorIndication extends UdpControlInfo
 * {
 * }
 * </pre>
 */
class INET_API UdpErrorIndication : public ::inet::UdpControlInfo
{
  protected:

  private:
    void copy(const UdpErrorIndication& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UdpErrorIndication&);

  public:
    UdpErrorIndication();
    UdpErrorIndication(const UdpErrorIndication& other);
    virtual ~UdpErrorIndication();
    UdpErrorIndication& operator=(const UdpErrorIndication& other);
    virtual UdpErrorIndication *dup() const override {return new UdpErrorIndication(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UdpErrorIndication& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UdpErrorIndication& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/contract/udp/UdpControlInfo.msg:164</tt> by nedtool.
 * <pre>
 * //
 * // Base class for UDP socket option control info classes.
 * //
 * class UdpSetOptionCommand extends UdpControlInfo
 * {
 * }
 * </pre>
 */
class INET_API UdpSetOptionCommand : public ::inet::UdpControlInfo
{
  protected:

  private:
    void copy(const UdpSetOptionCommand& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UdpSetOptionCommand&);

  public:
    UdpSetOptionCommand();
    UdpSetOptionCommand(const UdpSetOptionCommand& other);
    virtual ~UdpSetOptionCommand();
    UdpSetOptionCommand& operator=(const UdpSetOptionCommand& other);
    virtual UdpSetOptionCommand *dup() const override {return new UdpSetOptionCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UdpSetOptionCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UdpSetOptionCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/contract/udp/UdpControlInfo.msg:176</tt> by nedtool.
 * <pre>
 * //
 * // Control info for setting the Time To Live (a.k.a. Hop Limit) option on an
 * // UDP socket. This option will affect both multicast and unicast packets.
 * // To set the option, send a message to the ~Udp module with kind=UDP_C_SETOPTION
 * // and an and instance of this control info class attached.
 * //
 * // \@see ~UdpCommandCode
 * //
 * class UdpSetTimeToLiveCommand extends UdpSetOptionCommand
 * {
 *     int ttl;
 * }
 * </pre>
 */
class INET_API UdpSetTimeToLiveCommand : public ::inet::UdpSetOptionCommand
{
  protected:
    int ttl = 0;

  private:
    void copy(const UdpSetTimeToLiveCommand& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UdpSetTimeToLiveCommand&);

  public:
    UdpSetTimeToLiveCommand();
    UdpSetTimeToLiveCommand(const UdpSetTimeToLiveCommand& other);
    virtual ~UdpSetTimeToLiveCommand();
    UdpSetTimeToLiveCommand& operator=(const UdpSetTimeToLiveCommand& other);
    virtual UdpSetTimeToLiveCommand *dup() const override {return new UdpSetTimeToLiveCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getTtl() const;
    virtual void setTtl(int ttl);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UdpSetTimeToLiveCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UdpSetTimeToLiveCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/contract/udp/UdpControlInfo.msg:191</tt> by nedtool.
 * <pre>
 * //
 * // Control info for setting the Type of Service (Ipv4) or Traffic Class (Ipv6)
 * // header field on outgoing Ipv4/Ipv6 packets sent from an Udp socket.
 * // This is an 8-bit field, the lowest 6 bits are the Dscp (DiffServ Code Point)
 * // and the highest 2 bits are the ECN (Explicit Congestion Notification).
 * // To set the option, send a message to  the ~Udp module with kind=UDP_C_SETOPTION
 * // and an and instance of this control info class attached.
 * //
 * // \@see ~UdpCommandCode
 * //
 * class UdpSetTypeOfServiceCommand extends UdpSetOptionCommand
 * {
 *     char tos;  // ToS byte for Ipv4/Ipv6
 * }
 * </pre>
 */
class INET_API UdpSetTypeOfServiceCommand : public ::inet::UdpSetOptionCommand
{
  protected:
    char tos = 0;

  private:
    void copy(const UdpSetTypeOfServiceCommand& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UdpSetTypeOfServiceCommand&);

  public:
    UdpSetTypeOfServiceCommand();
    UdpSetTypeOfServiceCommand(const UdpSetTypeOfServiceCommand& other);
    virtual ~UdpSetTypeOfServiceCommand();
    UdpSetTypeOfServiceCommand& operator=(const UdpSetTypeOfServiceCommand& other);
    virtual UdpSetTypeOfServiceCommand *dup() const override {return new UdpSetTypeOfServiceCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual char getTos() const;
    virtual void setTos(char tos);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UdpSetTypeOfServiceCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UdpSetTypeOfServiceCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/contract/udp/UdpControlInfo.msg:203</tt> by nedtool.
 * <pre>
 * //
 * // Control info for setting the Broadcast option on an UDP socket.
 * // To set the option, send a message to the ~Udp module with kind=UDP_C_SETOPTION
 * // and an and instance of this control info class attached.
 * //
 * // \@see ~UdpCommandCode
 * //
 * class UdpSetBroadcastCommand extends UdpSetOptionCommand
 * {
 *     bool broadcast;
 * }
 * </pre>
 */
class INET_API UdpSetBroadcastCommand : public ::inet::UdpSetOptionCommand
{
  protected:
    bool broadcast = false;

  private:
    void copy(const UdpSetBroadcastCommand& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UdpSetBroadcastCommand&);

  public:
    UdpSetBroadcastCommand();
    UdpSetBroadcastCommand(const UdpSetBroadcastCommand& other);
    virtual ~UdpSetBroadcastCommand();
    UdpSetBroadcastCommand& operator=(const UdpSetBroadcastCommand& other);
    virtual UdpSetBroadcastCommand *dup() const override {return new UdpSetBroadcastCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual bool getBroadcast() const;
    virtual void setBroadcast(bool broadcast);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UdpSetBroadcastCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UdpSetBroadcastCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/contract/udp/UdpControlInfo.msg:215</tt> by nedtool.
 * <pre>
 * //
 * // Control info for setting the multicast output interface for an UDP socket.
 * // To set the option, send a message to the ~Udp module with kind=UDP_C_SETOPTION
 * // and an and instance of this control info class attached.
 * //
 * // \@see ~UdpCommandCode
 * //
 * class UdpSetMulticastInterfaceCommand extends UdpSetOptionCommand
 * {
 *     int interfaceId;
 * }
 * </pre>
 */
class INET_API UdpSetMulticastInterfaceCommand : public ::inet::UdpSetOptionCommand
{
  protected:
    int interfaceId = 0;

  private:
    void copy(const UdpSetMulticastInterfaceCommand& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UdpSetMulticastInterfaceCommand&);

  public:
    UdpSetMulticastInterfaceCommand();
    UdpSetMulticastInterfaceCommand(const UdpSetMulticastInterfaceCommand& other);
    virtual ~UdpSetMulticastInterfaceCommand();
    UdpSetMulticastInterfaceCommand& operator=(const UdpSetMulticastInterfaceCommand& other);
    virtual UdpSetMulticastInterfaceCommand *dup() const override {return new UdpSetMulticastInterfaceCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getInterfaceId() const;
    virtual void setInterfaceId(int interfaceId);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UdpSetMulticastInterfaceCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UdpSetMulticastInterfaceCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/contract/udp/UdpControlInfo.msg:229</tt> by nedtool.
 * <pre>
 * //
 * // Control info for setting the multicast loop option for an UDP socket.
 * // When the option is true, a copy of the outgoing multicast packet
 * // is delivered locally via the loopback interface.
 * // To set the option, send a message to the ~Udp module with kind=UDP_C_SETOPTION
 * // and an instance of this control info class attached.
 * //
 * // \@see ~UdpCommandCode
 * //
 * class UdpSetMulticastLoopCommand extends UdpSetOptionCommand
 * {
 *     bool loop;
 * }
 * </pre>
 */
class INET_API UdpSetMulticastLoopCommand : public ::inet::UdpSetOptionCommand
{
  protected:
    bool loop = false;

  private:
    void copy(const UdpSetMulticastLoopCommand& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UdpSetMulticastLoopCommand&);

  public:
    UdpSetMulticastLoopCommand();
    UdpSetMulticastLoopCommand(const UdpSetMulticastLoopCommand& other);
    virtual ~UdpSetMulticastLoopCommand();
    UdpSetMulticastLoopCommand& operator=(const UdpSetMulticastLoopCommand& other);
    virtual UdpSetMulticastLoopCommand *dup() const override {return new UdpSetMulticastLoopCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual bool getLoop() const;
    virtual void setLoop(bool loop);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UdpSetMulticastLoopCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UdpSetMulticastLoopCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/contract/udp/UdpControlInfo.msg:243</tt> by nedtool.
 * <pre>
 * //
 * // Control info for setting the ReuseAddress option on an UDP socket.
 * // When the option is true, then the socket is allowed to bind to an already bound
 * // local address.
 * // To set the option, send a message to the ~Udp module with kind=UDP_C_SETOPTION
 * // and an and instance of this control info class attached.
 * //
 * // \@see ~UdpCommandCode
 * //
 * class UdpSetReuseAddressCommand extends UdpSetOptionCommand
 * {
 *     bool reuseAddress;
 * }
 * </pre>
 */
class INET_API UdpSetReuseAddressCommand : public ::inet::UdpSetOptionCommand
{
  protected:
    bool reuseAddress = false;

  private:
    void copy(const UdpSetReuseAddressCommand& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UdpSetReuseAddressCommand&);

  public:
    UdpSetReuseAddressCommand();
    UdpSetReuseAddressCommand(const UdpSetReuseAddressCommand& other);
    virtual ~UdpSetReuseAddressCommand();
    UdpSetReuseAddressCommand& operator=(const UdpSetReuseAddressCommand& other);
    virtual UdpSetReuseAddressCommand *dup() const override {return new UdpSetReuseAddressCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual bool getReuseAddress() const;
    virtual void setReuseAddress(bool reuseAddress);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UdpSetReuseAddressCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UdpSetReuseAddressCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/contract/udp/UdpControlInfo.msg:259</tt> by nedtool.
 * <pre>
 * //
 * // Control info for letting an UDP socket join multicast groups.
 * // To set the option, send a message to the ~Udp module with kind=UDP_C_SETOPTION
 * // and an and instance of this control info class attached.
 * //
 * // The address-interfaceId pairs are passed as two separate arrays.
 * // When there are less interfaceIds than multicast addresses,
 * // then -1 is assumed (meaning join on all interfaces).
 * //
 * // \@see ~UdpCommandCode
 * //
 * class UdpJoinMulticastGroupsCommand extends UdpSetOptionCommand
 * {
 *     L3Address multicastAddr[];
 *     int interfaceId[];
 * }
 * </pre>
 */
class INET_API UdpJoinMulticastGroupsCommand : public ::inet::UdpSetOptionCommand
{
  protected:
    L3Address *multicastAddr = nullptr;
    size_t multicastAddr_arraysize = 0;
    int *interfaceId = nullptr;
    size_t interfaceId_arraysize = 0;

  private:
    void copy(const UdpJoinMulticastGroupsCommand& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UdpJoinMulticastGroupsCommand&);

  public:
    UdpJoinMulticastGroupsCommand();
    UdpJoinMulticastGroupsCommand(const UdpJoinMulticastGroupsCommand& other);
    virtual ~UdpJoinMulticastGroupsCommand();
    UdpJoinMulticastGroupsCommand& operator=(const UdpJoinMulticastGroupsCommand& other);
    virtual UdpJoinMulticastGroupsCommand *dup() const override {return new UdpJoinMulticastGroupsCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual void setMulticastAddrArraySize(size_t size);
    virtual size_t getMulticastAddrArraySize() const;
    virtual const L3Address& getMulticastAddr(size_t k) const;
    virtual L3Address& getMulticastAddrForUpdate(size_t k) { return const_cast<L3Address&>(const_cast<UdpJoinMulticastGroupsCommand*>(this)->getMulticastAddr(k));}
    virtual void setMulticastAddr(size_t k, const L3Address& multicastAddr);
    virtual void insertMulticastAddr(const L3Address& multicastAddr);
    virtual void insertMulticastAddr(size_t k, const L3Address& multicastAddr);
    virtual void eraseMulticastAddr(size_t k);
    virtual void setInterfaceIdArraySize(size_t size);
    virtual size_t getInterfaceIdArraySize() const;
    virtual int getInterfaceId(size_t k) const;
    virtual void setInterfaceId(size_t k, int interfaceId);
    virtual void insertInterfaceId(int interfaceId);
    virtual void insertInterfaceId(size_t k, int interfaceId);
    virtual void eraseInterfaceId(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UdpJoinMulticastGroupsCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UdpJoinMulticastGroupsCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/contract/udp/UdpControlInfo.msg:272</tt> by nedtool.
 * <pre>
 * //
 * // Control info for letting an UDP socket leave multicast groups.
 * // To set the option, send a message to the ~Udp module with kind=UDP_C_SETOPTION
 * // and an and instance of this control info class attached.
 * //
 * // \@see ~UdpCommandCode
 * //
 * class UdpLeaveMulticastGroupsCommand extends UdpSetOptionCommand
 * {
 *     L3Address multicastAddr[];
 * }
 * </pre>
 */
class INET_API UdpLeaveMulticastGroupsCommand : public ::inet::UdpSetOptionCommand
{
  protected:
    L3Address *multicastAddr = nullptr;
    size_t multicastAddr_arraysize = 0;

  private:
    void copy(const UdpLeaveMulticastGroupsCommand& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UdpLeaveMulticastGroupsCommand&);

  public:
    UdpLeaveMulticastGroupsCommand();
    UdpLeaveMulticastGroupsCommand(const UdpLeaveMulticastGroupsCommand& other);
    virtual ~UdpLeaveMulticastGroupsCommand();
    UdpLeaveMulticastGroupsCommand& operator=(const UdpLeaveMulticastGroupsCommand& other);
    virtual UdpLeaveMulticastGroupsCommand *dup() const override {return new UdpLeaveMulticastGroupsCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual void setMulticastAddrArraySize(size_t size);
    virtual size_t getMulticastAddrArraySize() const;
    virtual const L3Address& getMulticastAddr(size_t k) const;
    virtual L3Address& getMulticastAddrForUpdate(size_t k) { return const_cast<L3Address&>(const_cast<UdpLeaveMulticastGroupsCommand*>(this)->getMulticastAddr(k));}
    virtual void setMulticastAddr(size_t k, const L3Address& multicastAddr);
    virtual void insertMulticastAddr(const L3Address& multicastAddr);
    virtual void insertMulticastAddr(size_t k, const L3Address& multicastAddr);
    virtual void eraseMulticastAddr(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UdpLeaveMulticastGroupsCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UdpLeaveMulticastGroupsCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/contract/udp/UdpControlInfo.msg:282</tt> by nedtool.
 * <pre>
 * //
 * // Control info for letting an UDP socket to block multicast traffic from
 * // specific sources after joining a multicast group.
 * //
 * // see IP_BLOCK_SOURCE socket option
 * class UdpBlockMulticastSourcesCommand extends UdpSetOptionCommand
 * {
 *     int interfaceId;
 *     L3Address multicastAddr;
 *     L3Address sourceList[];
 * }
 * </pre>
 */
class INET_API UdpBlockMulticastSourcesCommand : public ::inet::UdpSetOptionCommand
{
  protected:
    int interfaceId = 0;
    L3Address multicastAddr;
    L3Address *sourceList = nullptr;
    size_t sourceList_arraysize = 0;

  private:
    void copy(const UdpBlockMulticastSourcesCommand& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UdpBlockMulticastSourcesCommand&);

  public:
    UdpBlockMulticastSourcesCommand();
    UdpBlockMulticastSourcesCommand(const UdpBlockMulticastSourcesCommand& other);
    virtual ~UdpBlockMulticastSourcesCommand();
    UdpBlockMulticastSourcesCommand& operator=(const UdpBlockMulticastSourcesCommand& other);
    virtual UdpBlockMulticastSourcesCommand *dup() const override {return new UdpBlockMulticastSourcesCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getInterfaceId() const;
    virtual void setInterfaceId(int interfaceId);
    virtual const L3Address& getMulticastAddr() const;
    virtual L3Address& getMulticastAddrForUpdate() { return const_cast<L3Address&>(const_cast<UdpBlockMulticastSourcesCommand*>(this)->getMulticastAddr());}
    virtual void setMulticastAddr(const L3Address& multicastAddr);
    virtual void setSourceListArraySize(size_t size);
    virtual size_t getSourceListArraySize() const;
    virtual const L3Address& getSourceList(size_t k) const;
    virtual L3Address& getSourceListForUpdate(size_t k) { return const_cast<L3Address&>(const_cast<UdpBlockMulticastSourcesCommand*>(this)->getSourceList(k));}
    virtual void setSourceList(size_t k, const L3Address& sourceList);
    virtual void insertSourceList(const L3Address& sourceList);
    virtual void insertSourceList(size_t k, const L3Address& sourceList);
    virtual void eraseSourceList(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UdpBlockMulticastSourcesCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UdpBlockMulticastSourcesCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/contract/udp/UdpControlInfo.msg:294</tt> by nedtool.
 * <pre>
 * //
 * // Control info for letting an UDP socket to permit multicast traffic from
 * // a previously blocked source.
 * //
 * // see IP_UNBLOCK_SOURCE socket option
 * class UdpUnblockMulticastSourcesCommand extends UdpSetOptionCommand
 * {
 *     int interfaceId;
 *     L3Address multicastAddr;
 *     L3Address sourceList[];
 * }
 * </pre>
 */
class INET_API UdpUnblockMulticastSourcesCommand : public ::inet::UdpSetOptionCommand
{
  protected:
    int interfaceId = 0;
    L3Address multicastAddr;
    L3Address *sourceList = nullptr;
    size_t sourceList_arraysize = 0;

  private:
    void copy(const UdpUnblockMulticastSourcesCommand& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UdpUnblockMulticastSourcesCommand&);

  public:
    UdpUnblockMulticastSourcesCommand();
    UdpUnblockMulticastSourcesCommand(const UdpUnblockMulticastSourcesCommand& other);
    virtual ~UdpUnblockMulticastSourcesCommand();
    UdpUnblockMulticastSourcesCommand& operator=(const UdpUnblockMulticastSourcesCommand& other);
    virtual UdpUnblockMulticastSourcesCommand *dup() const override {return new UdpUnblockMulticastSourcesCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getInterfaceId() const;
    virtual void setInterfaceId(int interfaceId);
    virtual const L3Address& getMulticastAddr() const;
    virtual L3Address& getMulticastAddrForUpdate() { return const_cast<L3Address&>(const_cast<UdpUnblockMulticastSourcesCommand*>(this)->getMulticastAddr());}
    virtual void setMulticastAddr(const L3Address& multicastAddr);
    virtual void setSourceListArraySize(size_t size);
    virtual size_t getSourceListArraySize() const;
    virtual const L3Address& getSourceList(size_t k) const;
    virtual L3Address& getSourceListForUpdate(size_t k) { return const_cast<L3Address&>(const_cast<UdpUnblockMulticastSourcesCommand*>(this)->getSourceList(k));}
    virtual void setSourceList(size_t k, const L3Address& sourceList);
    virtual void insertSourceList(const L3Address& sourceList);
    virtual void insertSourceList(size_t k, const L3Address& sourceList);
    virtual void eraseSourceList(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UdpUnblockMulticastSourcesCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UdpUnblockMulticastSourcesCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/contract/udp/UdpControlInfo.msg:306</tt> by nedtool.
 * <pre>
 * //
 * // Control info for letting an UDP socket to join a multicast group
 * // only for the selected sources.
 * //
 * // see IP_ADD_SOURCE_MEMBERSHIP socket option
 * class UdpJoinMulticastSourcesCommand extends UdpSetOptionCommand
 * {
 *     int interfaceId;
 *     L3Address multicastAddr;
 *     L3Address sourceList[];
 * }
 * </pre>
 */
class INET_API UdpJoinMulticastSourcesCommand : public ::inet::UdpSetOptionCommand
{
  protected:
    int interfaceId = 0;
    L3Address multicastAddr;
    L3Address *sourceList = nullptr;
    size_t sourceList_arraysize = 0;

  private:
    void copy(const UdpJoinMulticastSourcesCommand& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UdpJoinMulticastSourcesCommand&);

  public:
    UdpJoinMulticastSourcesCommand();
    UdpJoinMulticastSourcesCommand(const UdpJoinMulticastSourcesCommand& other);
    virtual ~UdpJoinMulticastSourcesCommand();
    UdpJoinMulticastSourcesCommand& operator=(const UdpJoinMulticastSourcesCommand& other);
    virtual UdpJoinMulticastSourcesCommand *dup() const override {return new UdpJoinMulticastSourcesCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getInterfaceId() const;
    virtual void setInterfaceId(int interfaceId);
    virtual const L3Address& getMulticastAddr() const;
    virtual L3Address& getMulticastAddrForUpdate() { return const_cast<L3Address&>(const_cast<UdpJoinMulticastSourcesCommand*>(this)->getMulticastAddr());}
    virtual void setMulticastAddr(const L3Address& multicastAddr);
    virtual void setSourceListArraySize(size_t size);
    virtual size_t getSourceListArraySize() const;
    virtual const L3Address& getSourceList(size_t k) const;
    virtual L3Address& getSourceListForUpdate(size_t k) { return const_cast<L3Address&>(const_cast<UdpJoinMulticastSourcesCommand*>(this)->getSourceList(k));}
    virtual void setSourceList(size_t k, const L3Address& sourceList);
    virtual void insertSourceList(const L3Address& sourceList);
    virtual void insertSourceList(size_t k, const L3Address& sourceList);
    virtual void eraseSourceList(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UdpJoinMulticastSourcesCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UdpJoinMulticastSourcesCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/contract/udp/UdpControlInfo.msg:318</tt> by nedtool.
 * <pre>
 * //
 * // Control info for letting an UDP socket to leave a multicast group
 * // for the selected sources.
 * //
 * // see IP_DROP_SOURCE_MEMBERSHIP socket option
 * class UdpLeaveMulticastSourcesCommand extends UdpSetOptionCommand
 * {
 *     int interfaceId;
 *     L3Address multicastAddr;
 *     L3Address sourceList[];
 * }
 * </pre>
 */
class INET_API UdpLeaveMulticastSourcesCommand : public ::inet::UdpSetOptionCommand
{
  protected:
    int interfaceId = 0;
    L3Address multicastAddr;
    L3Address *sourceList = nullptr;
    size_t sourceList_arraysize = 0;

  private:
    void copy(const UdpLeaveMulticastSourcesCommand& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UdpLeaveMulticastSourcesCommand&);

  public:
    UdpLeaveMulticastSourcesCommand();
    UdpLeaveMulticastSourcesCommand(const UdpLeaveMulticastSourcesCommand& other);
    virtual ~UdpLeaveMulticastSourcesCommand();
    UdpLeaveMulticastSourcesCommand& operator=(const UdpLeaveMulticastSourcesCommand& other);
    virtual UdpLeaveMulticastSourcesCommand *dup() const override {return new UdpLeaveMulticastSourcesCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getInterfaceId() const;
    virtual void setInterfaceId(int interfaceId);
    virtual const L3Address& getMulticastAddr() const;
    virtual L3Address& getMulticastAddrForUpdate() { return const_cast<L3Address&>(const_cast<UdpLeaveMulticastSourcesCommand*>(this)->getMulticastAddr());}
    virtual void setMulticastAddr(const L3Address& multicastAddr);
    virtual void setSourceListArraySize(size_t size);
    virtual size_t getSourceListArraySize() const;
    virtual const L3Address& getSourceList(size_t k) const;
    virtual L3Address& getSourceListForUpdate(size_t k) { return const_cast<L3Address&>(const_cast<UdpLeaveMulticastSourcesCommand*>(this)->getSourceList(k));}
    virtual void setSourceList(size_t k, const L3Address& sourceList);
    virtual void insertSourceList(const L3Address& sourceList);
    virtual void insertSourceList(size_t k, const L3Address& sourceList);
    virtual void eraseSourceList(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UdpLeaveMulticastSourcesCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UdpLeaveMulticastSourcesCommand& obj) {obj.parsimUnpack(b);}

/**
 * Enum generated from <tt>inet/transportlayer/contract/udp/UdpControlInfo.msg:324</tt> by nedtool.
 * <pre>
 * enum UdpSourceFilterMode
 * {
 *     UDP_INCLUDE_MCAST_SOURCES = 1;
 *     UDP_EXCLUDE_MCAST_SOURCES = 2;
 * }
 * </pre>
 */
enum UdpSourceFilterMode {
    UDP_INCLUDE_MCAST_SOURCES = 1,
    UDP_EXCLUDE_MCAST_SOURCES = 2
};

/**
 * Class generated from <tt>inet/transportlayer/contract/udp/UdpControlInfo.msg:334</tt> by nedtool.
 * <pre>
 * //
 * // Control info for letting an UDP socket to specify the excluded/included
 * // sources for a multicast group.
 * //
 * // Unlike Block/Unblock/Join/LeaveMulticastSource commands, this method is
 * // not incremental.
 * //
 * class UdpSetMulticastSourceFilterCommand extends UdpSetOptionCommand
 * {
 *     int interfaceId;
 *     L3Address multicastAddr;
 *     UdpSourceFilterMode filterMode;
 *     L3Address sourceList[];
 * }
 * </pre>
 */
class INET_API UdpSetMulticastSourceFilterCommand : public ::inet::UdpSetOptionCommand
{
  protected:
    int interfaceId = 0;
    L3Address multicastAddr;
    inet::UdpSourceFilterMode filterMode = static_cast<inet::UdpSourceFilterMode>(-1);
    L3Address *sourceList = nullptr;
    size_t sourceList_arraysize = 0;

  private:
    void copy(const UdpSetMulticastSourceFilterCommand& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UdpSetMulticastSourceFilterCommand&);

  public:
    UdpSetMulticastSourceFilterCommand();
    UdpSetMulticastSourceFilterCommand(const UdpSetMulticastSourceFilterCommand& other);
    virtual ~UdpSetMulticastSourceFilterCommand();
    UdpSetMulticastSourceFilterCommand& operator=(const UdpSetMulticastSourceFilterCommand& other);
    virtual UdpSetMulticastSourceFilterCommand *dup() const override {return new UdpSetMulticastSourceFilterCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getInterfaceId() const;
    virtual void setInterfaceId(int interfaceId);
    virtual const L3Address& getMulticastAddr() const;
    virtual L3Address& getMulticastAddrForUpdate() { return const_cast<L3Address&>(const_cast<UdpSetMulticastSourceFilterCommand*>(this)->getMulticastAddr());}
    virtual void setMulticastAddr(const L3Address& multicastAddr);
    virtual inet::UdpSourceFilterMode getFilterMode() const;
    virtual void setFilterMode(inet::UdpSourceFilterMode filterMode);
    virtual void setSourceListArraySize(size_t size);
    virtual size_t getSourceListArraySize() const;
    virtual const L3Address& getSourceList(size_t k) const;
    virtual L3Address& getSourceListForUpdate(size_t k) { return const_cast<L3Address&>(const_cast<UdpSetMulticastSourceFilterCommand*>(this)->getSourceList(k));}
    virtual void setSourceList(size_t k, const L3Address& sourceList);
    virtual void insertSourceList(const L3Address& sourceList);
    virtual void insertSourceList(size_t k, const L3Address& sourceList);
    virtual void eraseSourceList(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UdpSetMulticastSourceFilterCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UdpSetMulticastSourceFilterCommand& obj) {obj.parsimUnpack(b);}

} // namespace inet

#endif // ifndef __INET_UDPCONTROLINFO_M_H

