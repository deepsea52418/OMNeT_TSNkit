//
// Generated file, do not edit! Created by nedtool 5.6 from inet/transportlayer/sctp/SctpHeader.msg.
//

#ifndef __INET__SCTP_SCTPHEADER_M_H
#define __INET__SCTP_SCTPHEADER_M_H

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0506
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif

// dll export symbol
#ifndef INET_API
#  if defined(INET_EXPORT)
#    define INET_API  OPP_DLLEXPORT
#  elif defined(INET_IMPORT)
#    define INET_API  OPP_DLLIMPORT
#  else
#    define INET_API
#  endif
#endif


namespace inet {
namespace sctp {

class SctpHeader;
class SctpChunk;
class SctpInitChunk;
class SctpInitAckChunk;
class SctpCookieEchoChunk;
class SctpCookie;
class SctpCookieAckChunk;
class SctpDataMsg;
class SctpDataChunk;
class SctpForwardTsnChunk;
class SctpSackChunk;
class SctpAbortChunk;
class SctpHeartbeatChunk;
class SctpHeartbeatAckChunk;
class SctpShutdownChunk;
class SctpShutdownAckChunk;
class SctpShutdownCompleteChunk;
class SctpErrorChunk;
class SctpParameter;
class SctpPacketDropChunk;
class SctpStreamResetChunk;
class SctpOutgoingSsnResetRequestParameter;
class SctpIncomingSsnResetRequestParameter;
class SctpSsnTsnResetRequestParameter;
class SctpStreamResetResponseParameter;
class SctpAddStreamsRequestParameter;
class SctpResetTimer;
class SctpAuthenticationChunk;
class SctpAsconfChunk;
class SctpAsconfAckChunk;
class SctpAddIPParameter;
class SctpDeleteIPParameter;
class SctpSetPrimaryIPParameter;
class SctpSupportedExtensionsParameter;
class SctpErrorCauseParameter;
class SctpSimpleErrorCauseParameter;
class SctpSuccessIndication;
class NatMessage;
} // namespace sctp
} // namespace inet

#include "inet/common/INETDefs_m.h" // import inet.common.INETDefs

#include "inet/networklayer/common/L3Address_m.h" // import inet.networklayer.common.L3Address

#include "inet/transportlayer/contract/TransportHeaderBase_m.h" // import inet.transportlayer.contract.TransportHeaderBase

#include "inet/transportlayer/common/CrcMode_m.h" // import inet.transportlayer.common.CrcMode

#include "inet/common/packet/Message_m.h" // import inet.common.packet.Message


namespace inet {
namespace sctp {

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:28</tt> by nedtool.
 * <pre>
 * class SctpHeader extends TransportHeaderBase
 * {
 *     \@customize;
 *     // Source Port
 *     uint16 srcPort;
 *     // Destination Port
 *     uint16 destPort;
 *     // Verification Tag
 *     uint32 vTag;
 *     bool checksumOk;
 *     uint16_t crc = 0;
 *     CrcMode crcMode = CRC_MODE_UNDEFINED;
 *     unsigned short headerLength = 12;
 *     abstract SctpChunk *sctpChunks[];
 * }
 * </pre>
 *
 * SctpHeader_Base is only useful if it gets subclassed, and SctpHeader is derived from it.
 * The minimum code to be written for SctpHeader is the following:
 *
 * <pre>
 * class INET_API SctpHeader : public SctpHeader_Base
 * {
 *   private:
 *     void copy(const SctpHeader& other) { ... }

 *   public:
 *     SctpHeader() : SctpHeader_Base() {}
 *     SctpHeader(const SctpHeader& other) : SctpHeader_Base(other) {copy(other);}
 *     SctpHeader& operator=(const SctpHeader& other) {if (this==&other) return *this; SctpHeader_Base::operator=(other); copy(other); return *this;}
 *     virtual SctpHeader *dup() const override {return new SctpHeader(*this);}
 *     // ADD CODE HERE to redefine and implement pure virtual functions from SctpHeader_Base
 * };
 * </pre>
 *
 * The following should go into a .cc (.cpp) file:
 *
 * <pre>
 * Register_Class(SctpHeader)
 * </pre>
 */
class INET_API SctpHeader_Base : public ::inet::TransportHeaderBase
{
  protected:
    uint16_t srcPort = 0;
    uint16_t destPort = 0;
    uint32_t vTag = 0;
    bool checksumOk = false;
    uint16_t crc = 0;
    inet::CrcMode crcMode = CRC_MODE_UNDEFINED;
    unsigned short headerLength = 12;

  private:
    void copy(const SctpHeader_Base& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SctpHeader_Base&);
    // make constructors protected to avoid instantiation
    SctpHeader_Base();
    SctpHeader_Base(const SctpHeader_Base& other);
    // make assignment operator protected to force the user override it
    SctpHeader_Base& operator=(const SctpHeader_Base& other);

  public:
    virtual ~SctpHeader_Base();
    virtual SctpHeader_Base *dup() const override {throw omnetpp::cRuntimeError("You forgot to manually add a dup() function to class SctpHeader");}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint16_t getSrcPort() const;
    virtual void setSrcPort(uint16_t srcPort);
    virtual uint16_t getDestPort() const;
    virtual void setDestPort(uint16_t destPort);
    virtual uint32_t getVTag() const;
    virtual void setVTag(uint32_t vTag);
    virtual bool getChecksumOk() const;
    virtual void setChecksumOk(bool checksumOk);
    virtual uint16_t getCrc() const;
    virtual void setCrc(uint16_t crc);
    virtual inet::CrcMode getCrcMode() const;
    virtual void setCrcMode(inet::CrcMode crcMode);
    virtual unsigned short getHeaderLength() const;
    virtual void setHeaderLength(unsigned short headerLength);
    virtual void setSctpChunksArraySize(size_t size) = 0;
    virtual size_t getSctpChunksArraySize() const = 0;
    virtual const SctpChunk * getSctpChunks(size_t k) const = 0;
    virtual SctpChunk * getSctpChunksForUpdate(size_t k) { handleChange();return const_cast<SctpChunk *>(const_cast<SctpHeader_Base*>(this)->getSctpChunks(k));}
    virtual void setSctpChunks(size_t k, SctpChunk * sctpChunks) = 0;
    virtual void insertSctpChunks(SctpChunk * sctpChunks) = 0;
    virtual void insertSctpChunks(size_t k, SctpChunk * sctpChunks) = 0;
    virtual void eraseSctpChunks(size_t k) = 0;
};

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:45</tt> by nedtool.
 * <pre>
 * class SctpChunk extends cPacket
 * {
 *     // Chunk Type
 *     uint8 sctpChunkType;
 *     uint32 flags;
 *     unsigned short length = 0;
 *     char chunkName[];
 * }
 * </pre>
 */
class INET_API SctpChunk : public ::omnetpp::cPacket
{
  protected:
    uint8_t sctpChunkType = 0;
    uint32_t flags = 0;
    unsigned short length = 0;
    char *chunkName = nullptr;
    size_t chunkName_arraysize = 0;

  private:
    void copy(const SctpChunk& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SctpChunk&);

  public:
    SctpChunk(const char *name=nullptr);
    SctpChunk(const SctpChunk& other);
    virtual ~SctpChunk();
    SctpChunk& operator=(const SctpChunk& other);
    virtual SctpChunk *dup() const override {return new SctpChunk(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint8_t getSctpChunkType() const;
    virtual void setSctpChunkType(uint8_t sctpChunkType);
    virtual uint32_t getFlags() const;
    virtual void setFlags(uint32_t flags);
    virtual unsigned short getLength() const;
    virtual void setLength(unsigned short length);
    virtual void setChunkNameArraySize(size_t size);
    virtual size_t getChunkNameArraySize() const;
    virtual char getChunkName(size_t k) const;
    virtual void setChunkName(size_t k, char chunkName);
    virtual void insertChunkName(char chunkName);
    virtual void insertChunkName(size_t k, char chunkName);
    virtual void eraseChunkName(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SctpChunk& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SctpChunk& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:54</tt> by nedtool.
 * <pre>
 * class SctpInitChunk extends SctpChunk
 * {
 *     // Initiate Tag
 *     uint32 initTag;
 *     // Advertised Receiver Window
 *     uint32 a_rwnd;
 *     // Number of Outbound Streams
 *     uint16 noOutStreams;
 *     // Number of Inbound Streams
 *     uint16 noInStreams;
 *     // Initial TSN
 *     uint32 initTsn;
 *     bool forwardTsn;
 *     bool ipv4Supported;
 *     bool ipv6Supported;
 *     L3Address addresses[];
 *     uint8 unrecognizedParameters[]; //Will be filled by the Parser, if unrecognized Parameters arrive.
 *     uint32 msg_rwnd;
 *     uint16 sctpChunkTypes[]; //Chunk list parameter, i.e. for SCTP AUTH
 *     uint16 sepChunks[]; //Supported extensions parameter, i.e. for StreamReset
 *     uint16 hmacTypes[]; //HMAC Identifier for HMAC algorithm parameter
 *     uint8 random[]; //Random Parameter for SCTP AUTH
 * }
 * </pre>
 */
class INET_API SctpInitChunk : public ::inet::sctp::SctpChunk
{
  protected:
    uint32_t initTag = 0;
    uint32_t a_rwnd = 0;
    uint16_t noOutStreams = 0;
    uint16_t noInStreams = 0;
    uint32_t initTsn = 0;
    bool forwardTsn = false;
    bool ipv4Supported = false;
    bool ipv6Supported = false;
    L3Address *addresses = nullptr;
    size_t addresses_arraysize = 0;
    uint8_t *unrecognizedParameters = nullptr;
    size_t unrecognizedParameters_arraysize = 0;
    uint32_t msg_rwnd = 0;
    uint16_t *sctpChunkTypes = nullptr;
    size_t sctpChunkTypes_arraysize = 0;
    uint16_t *sepChunks = nullptr;
    size_t sepChunks_arraysize = 0;
    uint16_t *hmacTypes = nullptr;
    size_t hmacTypes_arraysize = 0;
    uint8_t *random = nullptr;
    size_t random_arraysize = 0;

  private:
    void copy(const SctpInitChunk& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SctpInitChunk&);

  public:
    SctpInitChunk(const char *name=nullptr);
    SctpInitChunk(const SctpInitChunk& other);
    virtual ~SctpInitChunk();
    SctpInitChunk& operator=(const SctpInitChunk& other);
    virtual SctpInitChunk *dup() const override {return new SctpInitChunk(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint32_t getInitTag() const;
    virtual void setInitTag(uint32_t initTag);
    virtual uint32_t getA_rwnd() const;
    virtual void setA_rwnd(uint32_t a_rwnd);
    virtual uint16_t getNoOutStreams() const;
    virtual void setNoOutStreams(uint16_t noOutStreams);
    virtual uint16_t getNoInStreams() const;
    virtual void setNoInStreams(uint16_t noInStreams);
    virtual uint32_t getInitTsn() const;
    virtual void setInitTsn(uint32_t initTsn);
    virtual bool getForwardTsn() const;
    virtual void setForwardTsn(bool forwardTsn);
    virtual bool getIpv4Supported() const;
    virtual void setIpv4Supported(bool ipv4Supported);
    virtual bool getIpv6Supported() const;
    virtual void setIpv6Supported(bool ipv6Supported);
    virtual void setAddressesArraySize(size_t size);
    virtual size_t getAddressesArraySize() const;
    virtual const L3Address& getAddresses(size_t k) const;
    virtual L3Address& getAddressesForUpdate(size_t k) { return const_cast<L3Address&>(const_cast<SctpInitChunk*>(this)->getAddresses(k));}
    virtual void setAddresses(size_t k, const L3Address& addresses);
    virtual void insertAddresses(const L3Address& addresses);
    virtual void insertAddresses(size_t k, const L3Address& addresses);
    virtual void eraseAddresses(size_t k);
    virtual void setUnrecognizedParametersArraySize(size_t size);
    virtual size_t getUnrecognizedParametersArraySize() const;
    virtual uint8_t getUnrecognizedParameters(size_t k) const;
    virtual void setUnrecognizedParameters(size_t k, uint8_t unrecognizedParameters);
    virtual void insertUnrecognizedParameters(uint8_t unrecognizedParameters);
    virtual void insertUnrecognizedParameters(size_t k, uint8_t unrecognizedParameters);
    virtual void eraseUnrecognizedParameters(size_t k);
    virtual uint32_t getMsg_rwnd() const;
    virtual void setMsg_rwnd(uint32_t msg_rwnd);
    virtual void setSctpChunkTypesArraySize(size_t size);
    virtual size_t getSctpChunkTypesArraySize() const;
    virtual uint16_t getSctpChunkTypes(size_t k) const;
    virtual void setSctpChunkTypes(size_t k, uint16_t sctpChunkTypes);
    virtual void insertSctpChunkTypes(uint16_t sctpChunkTypes);
    virtual void insertSctpChunkTypes(size_t k, uint16_t sctpChunkTypes);
    virtual void eraseSctpChunkTypes(size_t k);
    virtual void setSepChunksArraySize(size_t size);
    virtual size_t getSepChunksArraySize() const;
    virtual uint16_t getSepChunks(size_t k) const;
    virtual void setSepChunks(size_t k, uint16_t sepChunks);
    virtual void insertSepChunks(uint16_t sepChunks);
    virtual void insertSepChunks(size_t k, uint16_t sepChunks);
    virtual void eraseSepChunks(size_t k);
    virtual void setHmacTypesArraySize(size_t size);
    virtual size_t getHmacTypesArraySize() const;
    virtual uint16_t getHmacTypes(size_t k) const;
    virtual void setHmacTypes(size_t k, uint16_t hmacTypes);
    virtual void insertHmacTypes(uint16_t hmacTypes);
    virtual void insertHmacTypes(size_t k, uint16_t hmacTypes);
    virtual void eraseHmacTypes(size_t k);
    virtual void setRandomArraySize(size_t size);
    virtual size_t getRandomArraySize() const;
    virtual uint8_t getRandom(size_t k) const;
    virtual void setRandom(size_t k, uint8_t random);
    virtual void insertRandom(uint8_t random);
    virtual void insertRandom(size_t k, uint8_t random);
    virtual void eraseRandom(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SctpInitChunk& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SctpInitChunk& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:78</tt> by nedtool.
 * <pre>
 * class SctpInitAckChunk extends SctpChunk
 * {
 *     // Initiate Tag
 *     uint32 initTag;
 *     // Advertised Receiver Window
 *     uint32 a_rwnd;
 *     // Number of Outbound Streams
 *     uint16 noOutStreams;
 *     // Number of Inbound Streams
 *     uint16 noInStreams;
 *     // Initial TSN
 *     uint32 initTsn;
 *     bool forwardTsn;
 *     bool ipv4Supported;
 *     bool ipv6Supported;
 *     L3Address addresses[];
 *     char cookie[];
 *     uint8 unrecognizedParameters[];
 *     SctpCookie *stateCookie = nullptr;
 *     uint32 msg_rwnd;
 *     uint8 random[]; //Random Number
 *     uint16 sctpChunkTypes[];
 *     uint16 sepChunks[]; //Supported extensions parameter, i.e. for StreamReset
 *     uint16 hmacTypes[];
 * }
 * </pre>
 */
class INET_API SctpInitAckChunk : public ::inet::sctp::SctpChunk
{
  protected:
    uint32_t initTag = 0;
    uint32_t a_rwnd = 0;
    uint16_t noOutStreams = 0;
    uint16_t noInStreams = 0;
    uint32_t initTsn = 0;
    bool forwardTsn = false;
    bool ipv4Supported = false;
    bool ipv6Supported = false;
    L3Address *addresses = nullptr;
    size_t addresses_arraysize = 0;
    char *cookie = nullptr;
    size_t cookie_arraysize = 0;
    uint8_t *unrecognizedParameters = nullptr;
    size_t unrecognizedParameters_arraysize = 0;
    SctpCookie * stateCookie = nullptr;
    uint32_t msg_rwnd = 0;
    uint8_t *random = nullptr;
    size_t random_arraysize = 0;
    uint16_t *sctpChunkTypes = nullptr;
    size_t sctpChunkTypes_arraysize = 0;
    uint16_t *sepChunks = nullptr;
    size_t sepChunks_arraysize = 0;
    uint16_t *hmacTypes = nullptr;
    size_t hmacTypes_arraysize = 0;

  private:
    void copy(const SctpInitAckChunk& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SctpInitAckChunk&);

  public:
    SctpInitAckChunk(const char *name=nullptr);
    SctpInitAckChunk(const SctpInitAckChunk& other);
    virtual ~SctpInitAckChunk();
    SctpInitAckChunk& operator=(const SctpInitAckChunk& other);
    virtual SctpInitAckChunk *dup() const override {return new SctpInitAckChunk(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint32_t getInitTag() const;
    virtual void setInitTag(uint32_t initTag);
    virtual uint32_t getA_rwnd() const;
    virtual void setA_rwnd(uint32_t a_rwnd);
    virtual uint16_t getNoOutStreams() const;
    virtual void setNoOutStreams(uint16_t noOutStreams);
    virtual uint16_t getNoInStreams() const;
    virtual void setNoInStreams(uint16_t noInStreams);
    virtual uint32_t getInitTsn() const;
    virtual void setInitTsn(uint32_t initTsn);
    virtual bool getForwardTsn() const;
    virtual void setForwardTsn(bool forwardTsn);
    virtual bool getIpv4Supported() const;
    virtual void setIpv4Supported(bool ipv4Supported);
    virtual bool getIpv6Supported() const;
    virtual void setIpv6Supported(bool ipv6Supported);
    virtual void setAddressesArraySize(size_t size);
    virtual size_t getAddressesArraySize() const;
    virtual const L3Address& getAddresses(size_t k) const;
    virtual L3Address& getAddressesForUpdate(size_t k) { return const_cast<L3Address&>(const_cast<SctpInitAckChunk*>(this)->getAddresses(k));}
    virtual void setAddresses(size_t k, const L3Address& addresses);
    virtual void insertAddresses(const L3Address& addresses);
    virtual void insertAddresses(size_t k, const L3Address& addresses);
    virtual void eraseAddresses(size_t k);
    virtual void setCookieArraySize(size_t size);
    virtual size_t getCookieArraySize() const;
    virtual char getCookie(size_t k) const;
    virtual void setCookie(size_t k, char cookie);
    virtual void insertCookie(char cookie);
    virtual void insertCookie(size_t k, char cookie);
    virtual void eraseCookie(size_t k);
    virtual void setUnrecognizedParametersArraySize(size_t size);
    virtual size_t getUnrecognizedParametersArraySize() const;
    virtual uint8_t getUnrecognizedParameters(size_t k) const;
    virtual void setUnrecognizedParameters(size_t k, uint8_t unrecognizedParameters);
    virtual void insertUnrecognizedParameters(uint8_t unrecognizedParameters);
    virtual void insertUnrecognizedParameters(size_t k, uint8_t unrecognizedParameters);
    virtual void eraseUnrecognizedParameters(size_t k);
    virtual const SctpCookie * getStateCookie() const;
    virtual SctpCookie * getStateCookieForUpdate() { return const_cast<SctpCookie *>(const_cast<SctpInitAckChunk*>(this)->getStateCookie());}
    virtual void setStateCookie(SctpCookie * stateCookie);
    virtual uint32_t getMsg_rwnd() const;
    virtual void setMsg_rwnd(uint32_t msg_rwnd);
    virtual void setRandomArraySize(size_t size);
    virtual size_t getRandomArraySize() const;
    virtual uint8_t getRandom(size_t k) const;
    virtual void setRandom(size_t k, uint8_t random);
    virtual void insertRandom(uint8_t random);
    virtual void insertRandom(size_t k, uint8_t random);
    virtual void eraseRandom(size_t k);
    virtual void setSctpChunkTypesArraySize(size_t size);
    virtual size_t getSctpChunkTypesArraySize() const;
    virtual uint16_t getSctpChunkTypes(size_t k) const;
    virtual void setSctpChunkTypes(size_t k, uint16_t sctpChunkTypes);
    virtual void insertSctpChunkTypes(uint16_t sctpChunkTypes);
    virtual void insertSctpChunkTypes(size_t k, uint16_t sctpChunkTypes);
    virtual void eraseSctpChunkTypes(size_t k);
    virtual void setSepChunksArraySize(size_t size);
    virtual size_t getSepChunksArraySize() const;
    virtual uint16_t getSepChunks(size_t k) const;
    virtual void setSepChunks(size_t k, uint16_t sepChunks);
    virtual void insertSepChunks(uint16_t sepChunks);
    virtual void insertSepChunks(size_t k, uint16_t sepChunks);
    virtual void eraseSepChunks(size_t k);
    virtual void setHmacTypesArraySize(size_t size);
    virtual size_t getHmacTypesArraySize() const;
    virtual uint16_t getHmacTypes(size_t k) const;
    virtual void setHmacTypes(size_t k, uint16_t hmacTypes);
    virtual void insertHmacTypes(uint16_t hmacTypes);
    virtual void insertHmacTypes(size_t k, uint16_t hmacTypes);
    virtual void eraseHmacTypes(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SctpInitAckChunk& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SctpInitAckChunk& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:106</tt> by nedtool.
 * <pre>
 * class SctpCookieEchoChunk extends SctpChunk
 * {
 *     char cookie[];
 *     SctpCookie *stateCookie = nullptr;
 *     uint8 unrecognizedParameters[]; //for the serializer to send an Error chunk bundled with a Cookie-Echo
 * }
 * </pre>
 */
class INET_API SctpCookieEchoChunk : public ::inet::sctp::SctpChunk
{
  protected:
    char *cookie = nullptr;
    size_t cookie_arraysize = 0;
    SctpCookie * stateCookie = nullptr;
    uint8_t *unrecognizedParameters = nullptr;
    size_t unrecognizedParameters_arraysize = 0;

  private:
    void copy(const SctpCookieEchoChunk& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SctpCookieEchoChunk&);

  public:
    SctpCookieEchoChunk(const char *name=nullptr);
    SctpCookieEchoChunk(const SctpCookieEchoChunk& other);
    virtual ~SctpCookieEchoChunk();
    SctpCookieEchoChunk& operator=(const SctpCookieEchoChunk& other);
    virtual SctpCookieEchoChunk *dup() const override {return new SctpCookieEchoChunk(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual void setCookieArraySize(size_t size);
    virtual size_t getCookieArraySize() const;
    virtual char getCookie(size_t k) const;
    virtual void setCookie(size_t k, char cookie);
    virtual void insertCookie(char cookie);
    virtual void insertCookie(size_t k, char cookie);
    virtual void eraseCookie(size_t k);
    virtual const SctpCookie * getStateCookie() const;
    virtual SctpCookie * getStateCookieForUpdate() { return const_cast<SctpCookie *>(const_cast<SctpCookieEchoChunk*>(this)->getStateCookie());}
    virtual void setStateCookie(SctpCookie * stateCookie);
    virtual void setUnrecognizedParametersArraySize(size_t size);
    virtual size_t getUnrecognizedParametersArraySize() const;
    virtual uint8_t getUnrecognizedParameters(size_t k) const;
    virtual void setUnrecognizedParameters(size_t k, uint8_t unrecognizedParameters);
    virtual void insertUnrecognizedParameters(uint8_t unrecognizedParameters);
    virtual void insertUnrecognizedParameters(size_t k, uint8_t unrecognizedParameters);
    virtual void eraseUnrecognizedParameters(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SctpCookieEchoChunk& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SctpCookieEchoChunk& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:113</tt> by nedtool.
 * <pre>
 * class SctpCookie extends cNamedObject
 * {
 *     simtime_t creationTime;
 *     uint32 localTag;
 *     uint32 peerTag;
 *     uint8 localTieTag[];
 *     uint8 peerTieTag[];
 *     uint32 length;
 * }
 * </pre>
 */
class INET_API SctpCookie : public ::omnetpp::cNamedObject
{
  protected:
    omnetpp::simtime_t creationTime = SIMTIME_ZERO;
    uint32_t localTag = 0;
    uint32_t peerTag = 0;
    uint8_t *localTieTag = nullptr;
    size_t localTieTag_arraysize = 0;
    uint8_t *peerTieTag = nullptr;
    size_t peerTieTag_arraysize = 0;
    uint32_t length = 0;

  private:
    void copy(const SctpCookie& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SctpCookie&);

  public:
    SctpCookie(const char *name=nullptr);
    SctpCookie(const SctpCookie& other);
    virtual ~SctpCookie();
    SctpCookie& operator=(const SctpCookie& other);
    virtual SctpCookie *dup() const override {return new SctpCookie(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual omnetpp::simtime_t getCreationTime() const;
    virtual void setCreationTime(omnetpp::simtime_t creationTime);
    virtual uint32_t getLocalTag() const;
    virtual void setLocalTag(uint32_t localTag);
    virtual uint32_t getPeerTag() const;
    virtual void setPeerTag(uint32_t peerTag);
    virtual void setLocalTieTagArraySize(size_t size);
    virtual size_t getLocalTieTagArraySize() const;
    virtual uint8_t getLocalTieTag(size_t k) const;
    virtual void setLocalTieTag(size_t k, uint8_t localTieTag);
    virtual void insertLocalTieTag(uint8_t localTieTag);
    virtual void insertLocalTieTag(size_t k, uint8_t localTieTag);
    virtual void eraseLocalTieTag(size_t k);
    virtual void setPeerTieTagArraySize(size_t size);
    virtual size_t getPeerTieTagArraySize() const;
    virtual uint8_t getPeerTieTag(size_t k) const;
    virtual void setPeerTieTag(size_t k, uint8_t peerTieTag);
    virtual void insertPeerTieTag(uint8_t peerTieTag);
    virtual void insertPeerTieTag(size_t k, uint8_t peerTieTag);
    virtual void erasePeerTieTag(size_t k);
    virtual uint32_t getLength() const;
    virtual void setLength(uint32_t length);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SctpCookie& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SctpCookie& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:123</tt> by nedtool.
 * <pre>
 * class SctpCookieAckChunk extends SctpChunk
 * {
 * }
 * </pre>
 */
class INET_API SctpCookieAckChunk : public ::inet::sctp::SctpChunk
{
  protected:

  private:
    void copy(const SctpCookieAckChunk& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SctpCookieAckChunk&);

  public:
    SctpCookieAckChunk(const char *name=nullptr);
    SctpCookieAckChunk(const SctpCookieAckChunk& other);
    virtual ~SctpCookieAckChunk();
    SctpCookieAckChunk& operator=(const SctpCookieAckChunk& other);
    virtual SctpCookieAckChunk *dup() const override {return new SctpCookieAckChunk(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SctpCookieAckChunk& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SctpCookieAckChunk& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:127</tt> by nedtool.
 * <pre>
 * class SctpDataMsg extends cPacket
 * {
 *     // Chunk Flags
 *     bool eBit = 0;
 *     bool bBit = 0;
 *     simtime_t enqueuingTime;
 *     simtime_t expiryTime;
 *     uint32 ppid;
 *     L3Address initialDestination;
 *     uint32 msgNum;
 *     uint16 sid;
 *     bool ordered;
 *     uint32 booksize;
 *     uint32 rtx;
 *     bool fragment;
 *     uint32 prMethod;
 *     uint32 priority;
 *     bool strReset;
 *     bool sackNow;
 * }
 * </pre>
 */
class INET_API SctpDataMsg : public ::omnetpp::cPacket
{
  protected:
    bool eBit = 0;
    bool bBit = 0;
    omnetpp::simtime_t enqueuingTime = SIMTIME_ZERO;
    omnetpp::simtime_t expiryTime = SIMTIME_ZERO;
    uint32_t ppid = 0;
    L3Address initialDestination;
    uint32_t msgNum = 0;
    uint16_t sid = 0;
    bool ordered = false;
    uint32_t booksize = 0;
    uint32_t rtx = 0;
    bool fragment = false;
    uint32_t prMethod = 0;
    uint32_t priority = 0;
    bool strReset = false;
    bool sackNow = false;

  private:
    void copy(const SctpDataMsg& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SctpDataMsg&);

  public:
    SctpDataMsg(const char *name=nullptr);
    SctpDataMsg(const SctpDataMsg& other);
    virtual ~SctpDataMsg();
    SctpDataMsg& operator=(const SctpDataMsg& other);
    virtual SctpDataMsg *dup() const override {return new SctpDataMsg(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual bool getEBit() const;
    virtual void setEBit(bool eBit);
    virtual bool getBBit() const;
    virtual void setBBit(bool bBit);
    virtual omnetpp::simtime_t getEnqueuingTime() const;
    virtual void setEnqueuingTime(omnetpp::simtime_t enqueuingTime);
    virtual omnetpp::simtime_t getExpiryTime() const;
    virtual void setExpiryTime(omnetpp::simtime_t expiryTime);
    virtual uint32_t getPpid() const;
    virtual void setPpid(uint32_t ppid);
    virtual const L3Address& getInitialDestination() const;
    virtual L3Address& getInitialDestinationForUpdate() { return const_cast<L3Address&>(const_cast<SctpDataMsg*>(this)->getInitialDestination());}
    virtual void setInitialDestination(const L3Address& initialDestination);
    virtual uint32_t getMsgNum() const;
    virtual void setMsgNum(uint32_t msgNum);
    virtual uint16_t getSid() const;
    virtual void setSid(uint16_t sid);
    virtual bool getOrdered() const;
    virtual void setOrdered(bool ordered);
    virtual uint32_t getBooksize() const;
    virtual void setBooksize(uint32_t booksize);
    virtual uint32_t getRtx() const;
    virtual void setRtx(uint32_t rtx);
    virtual bool getFragment() const;
    virtual void setFragment(bool fragment);
    virtual uint32_t getPrMethod() const;
    virtual void setPrMethod(uint32_t prMethod);
    virtual uint32_t getPriority() const;
    virtual void setPriority(uint32_t priority);
    virtual bool getStrReset() const;
    virtual void setStrReset(bool strReset);
    virtual bool getSackNow() const;
    virtual void setSackNow(bool sackNow);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SctpDataMsg& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SctpDataMsg& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:148</tt> by nedtool.
 * <pre>
 * class SctpDataChunk extends SctpChunk
 * {
 *     // Chunk Flags
 *     bool eBit = 0;
 *     bool bBit = 0;
 *     bool uBit = 0;
 *     bool iBit = 0;
 *     // Transmission Sequence Number
 *     uint32 tsn;
 *     // Stream identifier
 *     uint16 sid;
 *     // Stream Sequence Number
 *     uint16 ssn;
 *     // Payload Protocol Identifier
 *     uint32 ppid;
 *     simtime_t enqueuingTime;
 *     simtime_t firstSendTime;
 * }
 * </pre>
 */
class INET_API SctpDataChunk : public ::inet::sctp::SctpChunk
{
  protected:
    bool eBit = 0;
    bool bBit = 0;
    bool uBit = 0;
    bool iBit = 0;
    uint32_t tsn = 0;
    uint16_t sid = 0;
    uint16_t ssn = 0;
    uint32_t ppid = 0;
    omnetpp::simtime_t enqueuingTime = SIMTIME_ZERO;
    omnetpp::simtime_t firstSendTime = SIMTIME_ZERO;

  private:
    void copy(const SctpDataChunk& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SctpDataChunk&);

  public:
    SctpDataChunk(const char *name=nullptr);
    SctpDataChunk(const SctpDataChunk& other);
    virtual ~SctpDataChunk();
    SctpDataChunk& operator=(const SctpDataChunk& other);
    virtual SctpDataChunk *dup() const override {return new SctpDataChunk(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual bool getEBit() const;
    virtual void setEBit(bool eBit);
    virtual bool getBBit() const;
    virtual void setBBit(bool bBit);
    virtual bool getUBit() const;
    virtual void setUBit(bool uBit);
    virtual bool getIBit() const;
    virtual void setIBit(bool iBit);
    virtual uint32_t getTsn() const;
    virtual void setTsn(uint32_t tsn);
    virtual uint16_t getSid() const;
    virtual void setSid(uint16_t sid);
    virtual uint16_t getSsn() const;
    virtual void setSsn(uint16_t ssn);
    virtual uint32_t getPpid() const;
    virtual void setPpid(uint32_t ppid);
    virtual omnetpp::simtime_t getEnqueuingTime() const;
    virtual void setEnqueuingTime(omnetpp::simtime_t enqueuingTime);
    virtual omnetpp::simtime_t getFirstSendTime() const;
    virtual void setFirstSendTime(omnetpp::simtime_t firstSendTime);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SctpDataChunk& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SctpDataChunk& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:167</tt> by nedtool.
 * <pre>
 * class SctpForwardTsnChunk extends SctpChunk
 * {
 *     uint32 newCumTsn;
 *     uint16 sid[];
 *     short ssn[]; // set -1 in case of unordered delivery
 * }
 * </pre>
 */
class INET_API SctpForwardTsnChunk : public ::inet::sctp::SctpChunk
{
  protected:
    uint32_t newCumTsn = 0;
    uint16_t *sid = nullptr;
    size_t sid_arraysize = 0;
    short *ssn = nullptr;
    size_t ssn_arraysize = 0;

  private:
    void copy(const SctpForwardTsnChunk& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SctpForwardTsnChunk&);

  public:
    SctpForwardTsnChunk(const char *name=nullptr);
    SctpForwardTsnChunk(const SctpForwardTsnChunk& other);
    virtual ~SctpForwardTsnChunk();
    SctpForwardTsnChunk& operator=(const SctpForwardTsnChunk& other);
    virtual SctpForwardTsnChunk *dup() const override {return new SctpForwardTsnChunk(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint32_t getNewCumTsn() const;
    virtual void setNewCumTsn(uint32_t newCumTsn);
    virtual void setSidArraySize(size_t size);
    virtual size_t getSidArraySize() const;
    virtual uint16_t getSid(size_t k) const;
    virtual void setSid(size_t k, uint16_t sid);
    virtual void insertSid(uint16_t sid);
    virtual void insertSid(size_t k, uint16_t sid);
    virtual void eraseSid(size_t k);
    virtual void setSsnArraySize(size_t size);
    virtual size_t getSsnArraySize() const;
    virtual short getSsn(size_t k) const;
    virtual void setSsn(size_t k, short ssn);
    virtual void insertSsn(short ssn);
    virtual void insertSsn(size_t k, short ssn);
    virtual void eraseSsn(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SctpForwardTsnChunk& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SctpForwardTsnChunk& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:174</tt> by nedtool.
 * <pre>
 * class SctpSackChunk extends SctpChunk
 * {
 *     // Cumulative TSN Ack
 *     uint32 cumTsnAck;
 *     // Advertised Receiver Window Credit
 *     uint32 a_rwnd;
 *     // Number of Gap Ack Blocks
 *     uint16 numGaps;
 *     // Number of Non-Revokable Gap Ack Blocks
 *     uint16 numNrGaps;
 *     // Number of Duplicate TSNs
 *     uint16 numDupTsns;
 *     // Start and End of Gap Ack Blocks
 *     bool isNrSack;
 *     uint32 gapStart[];
 *     uint32 gapStop[];
 *     uint32 dupTsns[];
 *     uint32 sackSeqNum = 0;
 *     uint32 nrGapStart[];
 *     uint32 nrGapStop[];
 *     uint32 msg_rwnd;
 *     uint8 dacPacketsRcvd = 0;
 *     bool nrSubtractRGaps = false;
 * }
 * </pre>
 */
class INET_API SctpSackChunk : public ::inet::sctp::SctpChunk
{
  protected:
    uint32_t cumTsnAck = 0;
    uint32_t a_rwnd = 0;
    uint16_t numGaps = 0;
    uint16_t numNrGaps = 0;
    uint16_t numDupTsns = 0;
    bool isNrSack_ = false;
    uint32_t *gapStart = nullptr;
    size_t gapStart_arraysize = 0;
    uint32_t *gapStop = nullptr;
    size_t gapStop_arraysize = 0;
    uint32_t *dupTsns = nullptr;
    size_t dupTsns_arraysize = 0;
    uint32_t sackSeqNum = 0;
    uint32_t *nrGapStart = nullptr;
    size_t nrGapStart_arraysize = 0;
    uint32_t *nrGapStop = nullptr;
    size_t nrGapStop_arraysize = 0;
    uint32_t msg_rwnd = 0;
    uint8_t dacPacketsRcvd = 0;
    bool nrSubtractRGaps = false;

  private:
    void copy(const SctpSackChunk& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SctpSackChunk&);

  public:
    SctpSackChunk(const char *name=nullptr);
    SctpSackChunk(const SctpSackChunk& other);
    virtual ~SctpSackChunk();
    SctpSackChunk& operator=(const SctpSackChunk& other);
    virtual SctpSackChunk *dup() const override {return new SctpSackChunk(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint32_t getCumTsnAck() const;
    virtual void setCumTsnAck(uint32_t cumTsnAck);
    virtual uint32_t getA_rwnd() const;
    virtual void setA_rwnd(uint32_t a_rwnd);
    virtual uint16_t getNumGaps() const;
    virtual void setNumGaps(uint16_t numGaps);
    virtual uint16_t getNumNrGaps() const;
    virtual void setNumNrGaps(uint16_t numNrGaps);
    virtual uint16_t getNumDupTsns() const;
    virtual void setNumDupTsns(uint16_t numDupTsns);
    virtual bool isNrSack() const;
    virtual void setIsNrSack(bool isNrSack);
    virtual void setGapStartArraySize(size_t size);
    virtual size_t getGapStartArraySize() const;
    virtual uint32_t getGapStart(size_t k) const;
    virtual void setGapStart(size_t k, uint32_t gapStart);
    virtual void insertGapStart(uint32_t gapStart);
    virtual void insertGapStart(size_t k, uint32_t gapStart);
    virtual void eraseGapStart(size_t k);
    virtual void setGapStopArraySize(size_t size);
    virtual size_t getGapStopArraySize() const;
    virtual uint32_t getGapStop(size_t k) const;
    virtual void setGapStop(size_t k, uint32_t gapStop);
    virtual void insertGapStop(uint32_t gapStop);
    virtual void insertGapStop(size_t k, uint32_t gapStop);
    virtual void eraseGapStop(size_t k);
    virtual void setDupTsnsArraySize(size_t size);
    virtual size_t getDupTsnsArraySize() const;
    virtual uint32_t getDupTsns(size_t k) const;
    virtual void setDupTsns(size_t k, uint32_t dupTsns);
    virtual void insertDupTsns(uint32_t dupTsns);
    virtual void insertDupTsns(size_t k, uint32_t dupTsns);
    virtual void eraseDupTsns(size_t k);
    virtual uint32_t getSackSeqNum() const;
    virtual void setSackSeqNum(uint32_t sackSeqNum);
    virtual void setNrGapStartArraySize(size_t size);
    virtual size_t getNrGapStartArraySize() const;
    virtual uint32_t getNrGapStart(size_t k) const;
    virtual void setNrGapStart(size_t k, uint32_t nrGapStart);
    virtual void insertNrGapStart(uint32_t nrGapStart);
    virtual void insertNrGapStart(size_t k, uint32_t nrGapStart);
    virtual void eraseNrGapStart(size_t k);
    virtual void setNrGapStopArraySize(size_t size);
    virtual size_t getNrGapStopArraySize() const;
    virtual uint32_t getNrGapStop(size_t k) const;
    virtual void setNrGapStop(size_t k, uint32_t nrGapStop);
    virtual void insertNrGapStop(uint32_t nrGapStop);
    virtual void insertNrGapStop(size_t k, uint32_t nrGapStop);
    virtual void eraseNrGapStop(size_t k);
    virtual uint32_t getMsg_rwnd() const;
    virtual void setMsg_rwnd(uint32_t msg_rwnd);
    virtual uint8_t getDacPacketsRcvd() const;
    virtual void setDacPacketsRcvd(uint8_t dacPacketsRcvd);
    virtual bool getNrSubtractRGaps() const;
    virtual void setNrSubtractRGaps(bool nrSubtractRGaps);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SctpSackChunk& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SctpSackChunk& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:199</tt> by nedtool.
 * <pre>
 * class SctpAbortChunk extends SctpChunk
 * {
 *     // Chunk Flags
 *     bool T_Bit = 0;
 * }
 * </pre>
 */
class INET_API SctpAbortChunk : public ::inet::sctp::SctpChunk
{
  protected:
    bool T_Bit = 0;

  private:
    void copy(const SctpAbortChunk& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SctpAbortChunk&);

  public:
    SctpAbortChunk(const char *name=nullptr);
    SctpAbortChunk(const SctpAbortChunk& other);
    virtual ~SctpAbortChunk();
    SctpAbortChunk& operator=(const SctpAbortChunk& other);
    virtual SctpAbortChunk *dup() const override {return new SctpAbortChunk(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual bool getT_Bit() const;
    virtual void setT_Bit(bool T_Bit);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SctpAbortChunk& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SctpAbortChunk& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:205</tt> by nedtool.
 * <pre>
 * class SctpHeartbeatChunk extends SctpChunk
 * {
 *     L3Address remoteAddr;
 *     simtime_t timeField;
 *     char info[];
 * }
 * </pre>
 */
class INET_API SctpHeartbeatChunk : public ::inet::sctp::SctpChunk
{
  protected:
    L3Address remoteAddr;
    omnetpp::simtime_t timeField = SIMTIME_ZERO;
    char *info = nullptr;
    size_t info_arraysize = 0;

  private:
    void copy(const SctpHeartbeatChunk& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SctpHeartbeatChunk&);

  public:
    SctpHeartbeatChunk(const char *name=nullptr);
    SctpHeartbeatChunk(const SctpHeartbeatChunk& other);
    virtual ~SctpHeartbeatChunk();
    SctpHeartbeatChunk& operator=(const SctpHeartbeatChunk& other);
    virtual SctpHeartbeatChunk *dup() const override {return new SctpHeartbeatChunk(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const L3Address& getRemoteAddr() const;
    virtual L3Address& getRemoteAddrForUpdate() { return const_cast<L3Address&>(const_cast<SctpHeartbeatChunk*>(this)->getRemoteAddr());}
    virtual void setRemoteAddr(const L3Address& remoteAddr);
    virtual omnetpp::simtime_t getTimeField() const;
    virtual void setTimeField(omnetpp::simtime_t timeField);
    virtual void setInfoArraySize(size_t size);
    virtual size_t getInfoArraySize() const;
    virtual char getInfo(size_t k) const;
    virtual void setInfo(size_t k, char info);
    virtual void insertInfo(char info);
    virtual void insertInfo(size_t k, char info);
    virtual void eraseInfo(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SctpHeartbeatChunk& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SctpHeartbeatChunk& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:212</tt> by nedtool.
 * <pre>
 * class SctpHeartbeatAckChunk extends SctpChunk
 * {
 *     L3Address remoteAddr;
 *     simtime_t timeField;
 *     char info[];
 * }
 * </pre>
 */
class INET_API SctpHeartbeatAckChunk : public ::inet::sctp::SctpChunk
{
  protected:
    L3Address remoteAddr;
    omnetpp::simtime_t timeField = SIMTIME_ZERO;
    char *info = nullptr;
    size_t info_arraysize = 0;

  private:
    void copy(const SctpHeartbeatAckChunk& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SctpHeartbeatAckChunk&);

  public:
    SctpHeartbeatAckChunk(const char *name=nullptr);
    SctpHeartbeatAckChunk(const SctpHeartbeatAckChunk& other);
    virtual ~SctpHeartbeatAckChunk();
    SctpHeartbeatAckChunk& operator=(const SctpHeartbeatAckChunk& other);
    virtual SctpHeartbeatAckChunk *dup() const override {return new SctpHeartbeatAckChunk(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const L3Address& getRemoteAddr() const;
    virtual L3Address& getRemoteAddrForUpdate() { return const_cast<L3Address&>(const_cast<SctpHeartbeatAckChunk*>(this)->getRemoteAddr());}
    virtual void setRemoteAddr(const L3Address& remoteAddr);
    virtual omnetpp::simtime_t getTimeField() const;
    virtual void setTimeField(omnetpp::simtime_t timeField);
    virtual void setInfoArraySize(size_t size);
    virtual size_t getInfoArraySize() const;
    virtual char getInfo(size_t k) const;
    virtual void setInfo(size_t k, char info);
    virtual void insertInfo(char info);
    virtual void insertInfo(size_t k, char info);
    virtual void eraseInfo(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SctpHeartbeatAckChunk& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SctpHeartbeatAckChunk& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:219</tt> by nedtool.
 * <pre>
 * class SctpShutdownChunk extends SctpChunk
 * {
 *     uint32 cumTsnAck;
 * }
 * </pre>
 */
class INET_API SctpShutdownChunk : public ::inet::sctp::SctpChunk
{
  protected:
    uint32_t cumTsnAck = 0;

  private:
    void copy(const SctpShutdownChunk& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SctpShutdownChunk&);

  public:
    SctpShutdownChunk(const char *name=nullptr);
    SctpShutdownChunk(const SctpShutdownChunk& other);
    virtual ~SctpShutdownChunk();
    SctpShutdownChunk& operator=(const SctpShutdownChunk& other);
    virtual SctpShutdownChunk *dup() const override {return new SctpShutdownChunk(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint32_t getCumTsnAck() const;
    virtual void setCumTsnAck(uint32_t cumTsnAck);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SctpShutdownChunk& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SctpShutdownChunk& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:224</tt> by nedtool.
 * <pre>
 * class SctpShutdownAckChunk extends SctpChunk
 * {
 * }
 * </pre>
 */
class INET_API SctpShutdownAckChunk : public ::inet::sctp::SctpChunk
{
  protected:

  private:
    void copy(const SctpShutdownAckChunk& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SctpShutdownAckChunk&);

  public:
    SctpShutdownAckChunk(const char *name=nullptr);
    SctpShutdownAckChunk(const SctpShutdownAckChunk& other);
    virtual ~SctpShutdownAckChunk();
    SctpShutdownAckChunk& operator=(const SctpShutdownAckChunk& other);
    virtual SctpShutdownAckChunk *dup() const override {return new SctpShutdownAckChunk(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SctpShutdownAckChunk& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SctpShutdownAckChunk& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:228</tt> by nedtool.
 * <pre>
 * class SctpShutdownCompleteChunk extends SctpChunk
 * {
 *     bool TBit = 0;
 * }
 * </pre>
 */
class INET_API SctpShutdownCompleteChunk : public ::inet::sctp::SctpChunk
{
  protected:
    bool TBit = 0;

  private:
    void copy(const SctpShutdownCompleteChunk& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SctpShutdownCompleteChunk&);

  public:
    SctpShutdownCompleteChunk(const char *name=nullptr);
    SctpShutdownCompleteChunk(const SctpShutdownCompleteChunk& other);
    virtual ~SctpShutdownCompleteChunk();
    SctpShutdownCompleteChunk& operator=(const SctpShutdownCompleteChunk& other);
    virtual SctpShutdownCompleteChunk *dup() const override {return new SctpShutdownCompleteChunk(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual bool getTBit() const;
    virtual void setTBit(bool TBit);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SctpShutdownCompleteChunk& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SctpShutdownCompleteChunk& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:233</tt> by nedtool.
 * <pre>
 * class SctpErrorChunk extends SctpChunk
 * {
 *     \@customize;
 *     bool TBit = 0;
 *     bool MBit = 0;
 *     abstract SctpParameter *parameters[];
 * }
 * </pre>
 *
 * SctpErrorChunk_Base is only useful if it gets subclassed, and SctpErrorChunk is derived from it.
 * The minimum code to be written for SctpErrorChunk is the following:
 *
 * <pre>
 * class INET_API SctpErrorChunk : public SctpErrorChunk_Base
 * {
 *   private:
 *     void copy(const SctpErrorChunk& other) { ... }

 *   public:
 *     SctpErrorChunk(const char *name=nullptr) : SctpErrorChunk_Base(name) {}
 *     SctpErrorChunk(const SctpErrorChunk& other) : SctpErrorChunk_Base(other) {copy(other);}
 *     SctpErrorChunk& operator=(const SctpErrorChunk& other) {if (this==&other) return *this; SctpErrorChunk_Base::operator=(other); copy(other); return *this;}
 *     virtual SctpErrorChunk *dup() const override {return new SctpErrorChunk(*this);}
 *     // ADD CODE HERE to redefine and implement pure virtual functions from SctpErrorChunk_Base
 * };
 * </pre>
 *
 * The following should go into a .cc (.cpp) file:
 *
 * <pre>
 * Register_Class(SctpErrorChunk)
 * </pre>
 */
class INET_API SctpErrorChunk_Base : public ::inet::sctp::SctpChunk
{
  protected:
    bool TBit = 0;
    bool MBit = 0;

  private:
    void copy(const SctpErrorChunk_Base& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SctpErrorChunk_Base&);
    // make constructors protected to avoid instantiation
    SctpErrorChunk_Base(const char *name=nullptr);
    SctpErrorChunk_Base(const SctpErrorChunk_Base& other);
    // make assignment operator protected to force the user override it
    SctpErrorChunk_Base& operator=(const SctpErrorChunk_Base& other);

  public:
    virtual ~SctpErrorChunk_Base();
    virtual SctpErrorChunk_Base *dup() const override {throw omnetpp::cRuntimeError("You forgot to manually add a dup() function to class SctpErrorChunk");}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual bool getTBit() const;
    virtual void setTBit(bool TBit);
    virtual bool getMBit() const;
    virtual void setMBit(bool MBit);
    virtual void setParametersArraySize(size_t size) = 0;
    virtual size_t getParametersArraySize() const = 0;
    virtual const SctpParameter * getParameters(size_t k) const = 0;
    virtual SctpParameter * getParametersForUpdate(size_t k) { return const_cast<SctpParameter *>(const_cast<SctpErrorChunk_Base*>(this)->getParameters(k));}
    virtual void setParameters(size_t k, SctpParameter * parameters) = 0;
    virtual void insertParameters(SctpParameter * parameters) = 0;
    virtual void insertParameters(size_t k, SctpParameter * parameters) = 0;
    virtual void eraseParameters(size_t k) = 0;
};

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:241</tt> by nedtool.
 * <pre>
 * class SctpParameter extends cPacket
 * {
 *     uint16 parameterType;
 *     char name[];
 * }
 * </pre>
 */
class INET_API SctpParameter : public ::omnetpp::cPacket
{
  protected:
    uint16_t parameterType = 0;
    char *name = nullptr;
    size_t name_arraysize = 0;

  private:
    void copy(const SctpParameter& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SctpParameter&);

  public:
    SctpParameter(const char *name=nullptr);
    SctpParameter(const SctpParameter& other);
    virtual ~SctpParameter();
    SctpParameter& operator=(const SctpParameter& other);
    virtual SctpParameter *dup() const override {return new SctpParameter(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint16_t getParameterType() const;
    virtual void setParameterType(uint16_t parameterType);
    virtual void setNameArraySize(size_t size);
    virtual size_t getNameArraySize() const;
    virtual char getName(size_t k) const;
    virtual void setName(size_t k, char name);
    virtual void insertName(char name);
    virtual void insertName(size_t k, char name);
    virtual void eraseName(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SctpParameter& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SctpParameter& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:247</tt> by nedtool.
 * <pre>
 * class SctpPacketDropChunk extends SctpChunk
 * {
 *     bool cFlag;
 *     bool tFlag;
 *     bool bFlag;
 *     bool mFlag;
 *     uint32 maxRwnd;
 *     uint32 queuedData;
 *     uint16 truncLength;
 * }
 * </pre>
 */
class INET_API SctpPacketDropChunk : public ::inet::sctp::SctpChunk
{
  protected:
    bool cFlag = false;
    bool tFlag = false;
    bool bFlag = false;
    bool mFlag = false;
    uint32_t maxRwnd = 0;
    uint32_t queuedData = 0;
    uint16_t truncLength = 0;

  private:
    void copy(const SctpPacketDropChunk& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SctpPacketDropChunk&);

  public:
    SctpPacketDropChunk(const char *name=nullptr);
    SctpPacketDropChunk(const SctpPacketDropChunk& other);
    virtual ~SctpPacketDropChunk();
    SctpPacketDropChunk& operator=(const SctpPacketDropChunk& other);
    virtual SctpPacketDropChunk *dup() const override {return new SctpPacketDropChunk(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual bool getCFlag() const;
    virtual void setCFlag(bool cFlag);
    virtual bool getTFlag() const;
    virtual void setTFlag(bool tFlag);
    virtual bool getBFlag() const;
    virtual void setBFlag(bool bFlag);
    virtual bool getMFlag() const;
    virtual void setMFlag(bool mFlag);
    virtual uint32_t getMaxRwnd() const;
    virtual void setMaxRwnd(uint32_t maxRwnd);
    virtual uint32_t getQueuedData() const;
    virtual void setQueuedData(uint32_t queuedData);
    virtual uint16_t getTruncLength() const;
    virtual void setTruncLength(uint16_t truncLength);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SctpPacketDropChunk& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SctpPacketDropChunk& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:258</tt> by nedtool.
 * <pre>
 * class SctpStreamResetChunk extends SctpChunk
 * {
 *     \@customize;
 *     abstract SctpParameter *parameters[];
 * }
 * </pre>
 *
 * SctpStreamResetChunk_Base is only useful if it gets subclassed, and SctpStreamResetChunk is derived from it.
 * The minimum code to be written for SctpStreamResetChunk is the following:
 *
 * <pre>
 * class INET_API SctpStreamResetChunk : public SctpStreamResetChunk_Base
 * {
 *   private:
 *     void copy(const SctpStreamResetChunk& other) { ... }

 *   public:
 *     SctpStreamResetChunk(const char *name=nullptr) : SctpStreamResetChunk_Base(name) {}
 *     SctpStreamResetChunk(const SctpStreamResetChunk& other) : SctpStreamResetChunk_Base(other) {copy(other);}
 *     SctpStreamResetChunk& operator=(const SctpStreamResetChunk& other) {if (this==&other) return *this; SctpStreamResetChunk_Base::operator=(other); copy(other); return *this;}
 *     virtual SctpStreamResetChunk *dup() const override {return new SctpStreamResetChunk(*this);}
 *     // ADD CODE HERE to redefine and implement pure virtual functions from SctpStreamResetChunk_Base
 * };
 * </pre>
 *
 * The following should go into a .cc (.cpp) file:
 *
 * <pre>
 * Register_Class(SctpStreamResetChunk)
 * </pre>
 */
class INET_API SctpStreamResetChunk_Base : public ::inet::sctp::SctpChunk
{
  protected:

  private:
    void copy(const SctpStreamResetChunk_Base& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SctpStreamResetChunk_Base&);
    // make constructors protected to avoid instantiation
    SctpStreamResetChunk_Base(const char *name=nullptr);
    SctpStreamResetChunk_Base(const SctpStreamResetChunk_Base& other);
    // make assignment operator protected to force the user override it
    SctpStreamResetChunk_Base& operator=(const SctpStreamResetChunk_Base& other);

  public:
    virtual ~SctpStreamResetChunk_Base();
    virtual SctpStreamResetChunk_Base *dup() const override {throw omnetpp::cRuntimeError("You forgot to manually add a dup() function to class SctpStreamResetChunk");}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual void setParametersArraySize(size_t size) = 0;
    virtual size_t getParametersArraySize() const = 0;
    virtual const SctpParameter * getParameters(size_t k) const = 0;
    virtual SctpParameter * getParametersForUpdate(size_t k) { return const_cast<SctpParameter *>(const_cast<SctpStreamResetChunk_Base*>(this)->getParameters(k));}
    virtual void setParameters(size_t k, SctpParameter * parameters) = 0;
    virtual void insertParameters(SctpParameter * parameters) = 0;
    virtual void insertParameters(size_t k, SctpParameter * parameters) = 0;
    virtual void eraseParameters(size_t k) = 0;
};

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:264</tt> by nedtool.
 * <pre>
 * class SctpOutgoingSsnResetRequestParameter extends SctpParameter
 * {
 *     uint32 srReqSn; //Stream Reset Request Sequence Number: initialized with the initial TSN, then incremented
 *     uint32 srResSn; //Stream Reset Response Sequence Number
 *     uint32 lastTsn; //Senders last assigned TSN
 *     uint16 streamNumbers[];
 * }
 * </pre>
 */
class INET_API SctpOutgoingSsnResetRequestParameter : public ::inet::sctp::SctpParameter
{
  protected:
    uint32_t srReqSn = 0;
    uint32_t srResSn = 0;
    uint32_t lastTsn = 0;
    uint16_t *streamNumbers = nullptr;
    size_t streamNumbers_arraysize = 0;

  private:
    void copy(const SctpOutgoingSsnResetRequestParameter& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SctpOutgoingSsnResetRequestParameter&);

  public:
    SctpOutgoingSsnResetRequestParameter(const char *name=nullptr);
    SctpOutgoingSsnResetRequestParameter(const SctpOutgoingSsnResetRequestParameter& other);
    virtual ~SctpOutgoingSsnResetRequestParameter();
    SctpOutgoingSsnResetRequestParameter& operator=(const SctpOutgoingSsnResetRequestParameter& other);
    virtual SctpOutgoingSsnResetRequestParameter *dup() const override {return new SctpOutgoingSsnResetRequestParameter(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint32_t getSrReqSn() const;
    virtual void setSrReqSn(uint32_t srReqSn);
    virtual uint32_t getSrResSn() const;
    virtual void setSrResSn(uint32_t srResSn);
    virtual uint32_t getLastTsn() const;
    virtual void setLastTsn(uint32_t lastTsn);
    virtual void setStreamNumbersArraySize(size_t size);
    virtual size_t getStreamNumbersArraySize() const;
    virtual uint16_t getStreamNumbers(size_t k) const;
    virtual void setStreamNumbers(size_t k, uint16_t streamNumbers);
    virtual void insertStreamNumbers(uint16_t streamNumbers);
    virtual void insertStreamNumbers(size_t k, uint16_t streamNumbers);
    virtual void eraseStreamNumbers(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SctpOutgoingSsnResetRequestParameter& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SctpOutgoingSsnResetRequestParameter& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:272</tt> by nedtool.
 * <pre>
 * class SctpIncomingSsnResetRequestParameter extends SctpParameter
 * {
 *     \@customize;
 *     uint32 srReqSn; //Stream Reset Request Sequence Number
 *     uint16 streamNumbers[];
 * }
 * </pre>
 *
 * SctpIncomingSsnResetRequestParameter_Base is only useful if it gets subclassed, and SctpIncomingSsnResetRequestParameter is derived from it.
 * The minimum code to be written for SctpIncomingSsnResetRequestParameter is the following:
 *
 * <pre>
 * class INET_API SctpIncomingSsnResetRequestParameter : public SctpIncomingSsnResetRequestParameter_Base
 * {
 *   private:
 *     void copy(const SctpIncomingSsnResetRequestParameter& other) { ... }

 *   public:
 *     SctpIncomingSsnResetRequestParameter(const char *name=nullptr) : SctpIncomingSsnResetRequestParameter_Base(name) {}
 *     SctpIncomingSsnResetRequestParameter(const SctpIncomingSsnResetRequestParameter& other) : SctpIncomingSsnResetRequestParameter_Base(other) {copy(other);}
 *     SctpIncomingSsnResetRequestParameter& operator=(const SctpIncomingSsnResetRequestParameter& other) {if (this==&other) return *this; SctpIncomingSsnResetRequestParameter_Base::operator=(other); copy(other); return *this;}
 *     virtual SctpIncomingSsnResetRequestParameter *dup() const override {return new SctpIncomingSsnResetRequestParameter(*this);}
 *     // ADD CODE HERE to redefine and implement pure virtual functions from SctpIncomingSsnResetRequestParameter_Base
 * };
 * </pre>
 *
 * The following should go into a .cc (.cpp) file:
 *
 * <pre>
 * Register_Class(SctpIncomingSsnResetRequestParameter)
 * </pre>
 */
class INET_API SctpIncomingSsnResetRequestParameter_Base : public ::inet::sctp::SctpParameter
{
  protected:
    uint32_t srReqSn = 0;
    uint16_t *streamNumbers = nullptr;
    size_t streamNumbers_arraysize = 0;

  private:
    void copy(const SctpIncomingSsnResetRequestParameter_Base& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SctpIncomingSsnResetRequestParameter_Base&);
    // make constructors protected to avoid instantiation
    SctpIncomingSsnResetRequestParameter_Base(const char *name=nullptr);
    SctpIncomingSsnResetRequestParameter_Base(const SctpIncomingSsnResetRequestParameter_Base& other);
    // make assignment operator protected to force the user override it
    SctpIncomingSsnResetRequestParameter_Base& operator=(const SctpIncomingSsnResetRequestParameter_Base& other);

  public:
    virtual ~SctpIncomingSsnResetRequestParameter_Base();
    virtual SctpIncomingSsnResetRequestParameter_Base *dup() const override {throw omnetpp::cRuntimeError("You forgot to manually add a dup() function to class SctpIncomingSsnResetRequestParameter");}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint32_t getSrReqSn() const;
    virtual void setSrReqSn(uint32_t srReqSn);
    virtual void setStreamNumbersArraySize(size_t size);
    virtual size_t getStreamNumbersArraySize() const;
    virtual uint16_t getStreamNumbers(size_t k) const;
    virtual void setStreamNumbers(size_t k, uint16_t streamNumbers);
    virtual void insertStreamNumbers(uint16_t streamNumbers);
    virtual void insertStreamNumbers(size_t k, uint16_t streamNumbers);
    virtual void eraseStreamNumbers(size_t k);
};

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:279</tt> by nedtool.
 * <pre>
 * class SctpSsnTsnResetRequestParameter extends SctpParameter
 * {
 *     uint32 srReqSn; //Stream Reset Request Sequence Number
 * }
 * </pre>
 */
class INET_API SctpSsnTsnResetRequestParameter : public ::inet::sctp::SctpParameter
{
  protected:
    uint32_t srReqSn = 0;

  private:
    void copy(const SctpSsnTsnResetRequestParameter& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SctpSsnTsnResetRequestParameter&);

  public:
    SctpSsnTsnResetRequestParameter(const char *name=nullptr);
    SctpSsnTsnResetRequestParameter(const SctpSsnTsnResetRequestParameter& other);
    virtual ~SctpSsnTsnResetRequestParameter();
    SctpSsnTsnResetRequestParameter& operator=(const SctpSsnTsnResetRequestParameter& other);
    virtual SctpSsnTsnResetRequestParameter *dup() const override {return new SctpSsnTsnResetRequestParameter(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint32_t getSrReqSn() const;
    virtual void setSrReqSn(uint32_t srReqSn);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SctpSsnTsnResetRequestParameter& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SctpSsnTsnResetRequestParameter& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:284</tt> by nedtool.
 * <pre>
 * class SctpStreamResetResponseParameter extends SctpParameter
 * {
 *     uint32 srResSn; //Stream Reset Response Sequence Number
 *     uint32 result;
 *     uint32 sendersNextTsn = 0;
 *     uint32 receiversNextTsn = 0;
 * }
 * </pre>
 */
class INET_API SctpStreamResetResponseParameter : public ::inet::sctp::SctpParameter
{
  protected:
    uint32_t srResSn = 0;
    uint32_t result = 0;
    uint32_t sendersNextTsn = 0;
    uint32_t receiversNextTsn = 0;

  private:
    void copy(const SctpStreamResetResponseParameter& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SctpStreamResetResponseParameter&);

  public:
    SctpStreamResetResponseParameter(const char *name=nullptr);
    SctpStreamResetResponseParameter(const SctpStreamResetResponseParameter& other);
    virtual ~SctpStreamResetResponseParameter();
    SctpStreamResetResponseParameter& operator=(const SctpStreamResetResponseParameter& other);
    virtual SctpStreamResetResponseParameter *dup() const override {return new SctpStreamResetResponseParameter(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint32_t getSrResSn() const;
    virtual void setSrResSn(uint32_t srResSn);
    virtual uint32_t getResult() const;
    virtual void setResult(uint32_t result);
    virtual uint32_t getSendersNextTsn() const;
    virtual void setSendersNextTsn(uint32_t sendersNextTsn);
    virtual uint32_t getReceiversNextTsn() const;
    virtual void setReceiversNextTsn(uint32_t receiversNextTsn);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SctpStreamResetResponseParameter& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SctpStreamResetResponseParameter& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:292</tt> by nedtool.
 * <pre>
 * class SctpAddStreamsRequestParameter extends SctpParameter
 * {
 *     uint32 srReqSn; //Stream Reset Request Sequence Number
 *     uint16 numberOfStreams;
 *     uint16 reserved = 0;
 * }
 * </pre>
 */
class INET_API SctpAddStreamsRequestParameter : public ::inet::sctp::SctpParameter
{
  protected:
    uint32_t srReqSn = 0;
    uint16_t numberOfStreams = 0;
    uint16_t reserved = 0;

  private:
    void copy(const SctpAddStreamsRequestParameter& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SctpAddStreamsRequestParameter&);

  public:
    SctpAddStreamsRequestParameter(const char *name=nullptr);
    SctpAddStreamsRequestParameter(const SctpAddStreamsRequestParameter& other);
    virtual ~SctpAddStreamsRequestParameter();
    SctpAddStreamsRequestParameter& operator=(const SctpAddStreamsRequestParameter& other);
    virtual SctpAddStreamsRequestParameter *dup() const override {return new SctpAddStreamsRequestParameter(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint32_t getSrReqSn() const;
    virtual void setSrReqSn(uint32_t srReqSn);
    virtual uint16_t getNumberOfStreams() const;
    virtual void setNumberOfStreams(uint16_t numberOfStreams);
    virtual uint16_t getReserved() const;
    virtual void setReserved(uint16_t reserved);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SctpAddStreamsRequestParameter& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SctpAddStreamsRequestParameter& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:299</tt> by nedtool.
 * <pre>
 * class SctpResetTimer extends cPacket
 * {
 *     uint32 inSN; //Stream Reset Response Sequence Number for Incoming Reset Request
 *     bool inAcked;   // false, when timer is running for the Reset Response Sequence Number, true otherwise
 *     uint32 outSN; //Stream Reset Response Sequence Number for Outgoing Reset Request
 *     bool outAcked;
 * }
 * </pre>
 */
class INET_API SctpResetTimer : public ::omnetpp::cPacket
{
  protected:
    uint32_t inSN = 0;
    bool inAcked = false;
    uint32_t outSN = 0;
    bool outAcked = false;

  private:
    void copy(const SctpResetTimer& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SctpResetTimer&);

  public:
    SctpResetTimer(const char *name=nullptr);
    SctpResetTimer(const SctpResetTimer& other);
    virtual ~SctpResetTimer();
    SctpResetTimer& operator=(const SctpResetTimer& other);
    virtual SctpResetTimer *dup() const override {return new SctpResetTimer(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint32_t getInSN() const;
    virtual void setInSN(uint32_t inSN);
    virtual bool getInAcked() const;
    virtual void setInAcked(bool inAcked);
    virtual uint32_t getOutSN() const;
    virtual void setOutSN(uint32_t outSN);
    virtual bool getOutAcked() const;
    virtual void setOutAcked(bool outAcked);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SctpResetTimer& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SctpResetTimer& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:307</tt> by nedtool.
 * <pre>
 * class SctpAuthenticationChunk extends SctpChunk
 * {
 *     uint16 sharedKey;
 *     uint16 hMacIdentifier;
 *     bool hMacOk;
 *     uint32 HMAC[];
 * }
 * </pre>
 */
class INET_API SctpAuthenticationChunk : public ::inet::sctp::SctpChunk
{
  protected:
    uint16_t sharedKey = 0;
    uint16_t hMacIdentifier = 0;
    bool hMacOk = false;
    uint32_t *HMAC = nullptr;
    size_t HMAC_arraysize = 0;

  private:
    void copy(const SctpAuthenticationChunk& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SctpAuthenticationChunk&);

  public:
    SctpAuthenticationChunk(const char *name=nullptr);
    SctpAuthenticationChunk(const SctpAuthenticationChunk& other);
    virtual ~SctpAuthenticationChunk();
    SctpAuthenticationChunk& operator=(const SctpAuthenticationChunk& other);
    virtual SctpAuthenticationChunk *dup() const override {return new SctpAuthenticationChunk(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint16_t getSharedKey() const;
    virtual void setSharedKey(uint16_t sharedKey);
    virtual uint16_t getHMacIdentifier() const;
    virtual void setHMacIdentifier(uint16_t hMacIdentifier);
    virtual bool getHMacOk() const;
    virtual void setHMacOk(bool hMacOk);
    virtual void setHMACArraySize(size_t size);
    virtual size_t getHMACArraySize() const;
    virtual uint32_t getHMAC(size_t k) const;
    virtual void setHMAC(size_t k, uint32_t HMAC);
    virtual void insertHMAC(uint32_t HMAC);
    virtual void insertHMAC(size_t k, uint32_t HMAC);
    virtual void eraseHMAC(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SctpAuthenticationChunk& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SctpAuthenticationChunk& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:315</tt> by nedtool.
 * <pre>
 * class SctpAsconfChunk extends SctpChunk
 * {
 *     \@customize;
 *     uint32 serialNumber;
 *     L3Address addressParam;
 *     uint32 peerVTag; //for NAT
 *     abstract SctpParameter *asconfParams[];
 * }
 * </pre>
 *
 * SctpAsconfChunk_Base is only useful if it gets subclassed, and SctpAsconfChunk is derived from it.
 * The minimum code to be written for SctpAsconfChunk is the following:
 *
 * <pre>
 * class INET_API SctpAsconfChunk : public SctpAsconfChunk_Base
 * {
 *   private:
 *     void copy(const SctpAsconfChunk& other) { ... }

 *   public:
 *     SctpAsconfChunk(const char *name=nullptr) : SctpAsconfChunk_Base(name) {}
 *     SctpAsconfChunk(const SctpAsconfChunk& other) : SctpAsconfChunk_Base(other) {copy(other);}
 *     SctpAsconfChunk& operator=(const SctpAsconfChunk& other) {if (this==&other) return *this; SctpAsconfChunk_Base::operator=(other); copy(other); return *this;}
 *     virtual SctpAsconfChunk *dup() const override {return new SctpAsconfChunk(*this);}
 *     // ADD CODE HERE to redefine and implement pure virtual functions from SctpAsconfChunk_Base
 * };
 * </pre>
 *
 * The following should go into a .cc (.cpp) file:
 *
 * <pre>
 * Register_Class(SctpAsconfChunk)
 * </pre>
 */
class INET_API SctpAsconfChunk_Base : public ::inet::sctp::SctpChunk
{
  protected:
    uint32_t serialNumber = 0;
    L3Address addressParam;
    uint32_t peerVTag = 0;

  private:
    void copy(const SctpAsconfChunk_Base& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SctpAsconfChunk_Base&);
    // make constructors protected to avoid instantiation
    SctpAsconfChunk_Base(const char *name=nullptr);
    SctpAsconfChunk_Base(const SctpAsconfChunk_Base& other);
    // make assignment operator protected to force the user override it
    SctpAsconfChunk_Base& operator=(const SctpAsconfChunk_Base& other);

  public:
    virtual ~SctpAsconfChunk_Base();
    virtual SctpAsconfChunk_Base *dup() const override {throw omnetpp::cRuntimeError("You forgot to manually add a dup() function to class SctpAsconfChunk");}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint32_t getSerialNumber() const;
    virtual void setSerialNumber(uint32_t serialNumber);
    virtual const L3Address& getAddressParam() const;
    virtual L3Address& getAddressParamForUpdate() { return const_cast<L3Address&>(const_cast<SctpAsconfChunk_Base*>(this)->getAddressParam());}
    virtual void setAddressParam(const L3Address& addressParam);
    virtual uint32_t getPeerVTag() const;
    virtual void setPeerVTag(uint32_t peerVTag);
    virtual void setAsconfParamsArraySize(size_t size) = 0;
    virtual size_t getAsconfParamsArraySize() const = 0;
    virtual const SctpParameter * getAsconfParams(size_t k) const = 0;
    virtual SctpParameter * getAsconfParamsForUpdate(size_t k) { return const_cast<SctpParameter *>(const_cast<SctpAsconfChunk_Base*>(this)->getAsconfParams(k));}
    virtual void setAsconfParams(size_t k, SctpParameter * asconfParams) = 0;
    virtual void insertAsconfParams(SctpParameter * asconfParams) = 0;
    virtual void insertAsconfParams(size_t k, SctpParameter * asconfParams) = 0;
    virtual void eraseAsconfParams(size_t k) = 0;
};

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:324</tt> by nedtool.
 * <pre>
 * class SctpAsconfAckChunk extends SctpChunk
 * {
 *     \@customize;
 *     uint32 serialNumber;
 *     abstract SctpParameter *asconfResponse[];
 * }
 * </pre>
 *
 * SctpAsconfAckChunk_Base is only useful if it gets subclassed, and SctpAsconfAckChunk is derived from it.
 * The minimum code to be written for SctpAsconfAckChunk is the following:
 *
 * <pre>
 * class INET_API SctpAsconfAckChunk : public SctpAsconfAckChunk_Base
 * {
 *   private:
 *     void copy(const SctpAsconfAckChunk& other) { ... }

 *   public:
 *     SctpAsconfAckChunk(const char *name=nullptr) : SctpAsconfAckChunk_Base(name) {}
 *     SctpAsconfAckChunk(const SctpAsconfAckChunk& other) : SctpAsconfAckChunk_Base(other) {copy(other);}
 *     SctpAsconfAckChunk& operator=(const SctpAsconfAckChunk& other) {if (this==&other) return *this; SctpAsconfAckChunk_Base::operator=(other); copy(other); return *this;}
 *     virtual SctpAsconfAckChunk *dup() const override {return new SctpAsconfAckChunk(*this);}
 *     // ADD CODE HERE to redefine and implement pure virtual functions from SctpAsconfAckChunk_Base
 * };
 * </pre>
 *
 * The following should go into a .cc (.cpp) file:
 *
 * <pre>
 * Register_Class(SctpAsconfAckChunk)
 * </pre>
 */
class INET_API SctpAsconfAckChunk_Base : public ::inet::sctp::SctpChunk
{
  protected:
    uint32_t serialNumber = 0;

  private:
    void copy(const SctpAsconfAckChunk_Base& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SctpAsconfAckChunk_Base&);
    // make constructors protected to avoid instantiation
    SctpAsconfAckChunk_Base(const char *name=nullptr);
    SctpAsconfAckChunk_Base(const SctpAsconfAckChunk_Base& other);
    // make assignment operator protected to force the user override it
    SctpAsconfAckChunk_Base& operator=(const SctpAsconfAckChunk_Base& other);

  public:
    virtual ~SctpAsconfAckChunk_Base();
    virtual SctpAsconfAckChunk_Base *dup() const override {throw omnetpp::cRuntimeError("You forgot to manually add a dup() function to class SctpAsconfAckChunk");}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint32_t getSerialNumber() const;
    virtual void setSerialNumber(uint32_t serialNumber);
    virtual void setAsconfResponseArraySize(size_t size) = 0;
    virtual size_t getAsconfResponseArraySize() const = 0;
    virtual const SctpParameter * getAsconfResponse(size_t k) const = 0;
    virtual SctpParameter * getAsconfResponseForUpdate(size_t k) { return const_cast<SctpParameter *>(const_cast<SctpAsconfAckChunk_Base*>(this)->getAsconfResponse(k));}
    virtual void setAsconfResponse(size_t k, SctpParameter * asconfResponse) = 0;
    virtual void insertAsconfResponse(SctpParameter * asconfResponse) = 0;
    virtual void insertAsconfResponse(size_t k, SctpParameter * asconfResponse) = 0;
    virtual void eraseAsconfResponse(size_t k) = 0;
};

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:331</tt> by nedtool.
 * <pre>
 * class SctpAddIPParameter extends SctpParameter
 * {
 *     uint32 requestCorrelationId; //assigned by the sender to identify each request parameter
 *     L3Address addressParam;
 * }
 * </pre>
 */
class INET_API SctpAddIPParameter : public ::inet::sctp::SctpParameter
{
  protected:
    uint32_t requestCorrelationId = 0;
    L3Address addressParam;

  private:
    void copy(const SctpAddIPParameter& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SctpAddIPParameter&);

  public:
    SctpAddIPParameter(const char *name=nullptr);
    SctpAddIPParameter(const SctpAddIPParameter& other);
    virtual ~SctpAddIPParameter();
    SctpAddIPParameter& operator=(const SctpAddIPParameter& other);
    virtual SctpAddIPParameter *dup() const override {return new SctpAddIPParameter(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint32_t getRequestCorrelationId() const;
    virtual void setRequestCorrelationId(uint32_t requestCorrelationId);
    virtual const L3Address& getAddressParam() const;
    virtual L3Address& getAddressParamForUpdate() { return const_cast<L3Address&>(const_cast<SctpAddIPParameter*>(this)->getAddressParam());}
    virtual void setAddressParam(const L3Address& addressParam);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SctpAddIPParameter& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SctpAddIPParameter& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:337</tt> by nedtool.
 * <pre>
 * class SctpDeleteIPParameter extends SctpParameter
 * {
 *     uint32 requestCorrelationId; //assigned by the sender to identify each request parameter
 *     L3Address addressParam;
 * }
 * </pre>
 */
class INET_API SctpDeleteIPParameter : public ::inet::sctp::SctpParameter
{
  protected:
    uint32_t requestCorrelationId = 0;
    L3Address addressParam;

  private:
    void copy(const SctpDeleteIPParameter& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SctpDeleteIPParameter&);

  public:
    SctpDeleteIPParameter(const char *name=nullptr);
    SctpDeleteIPParameter(const SctpDeleteIPParameter& other);
    virtual ~SctpDeleteIPParameter();
    SctpDeleteIPParameter& operator=(const SctpDeleteIPParameter& other);
    virtual SctpDeleteIPParameter *dup() const override {return new SctpDeleteIPParameter(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint32_t getRequestCorrelationId() const;
    virtual void setRequestCorrelationId(uint32_t requestCorrelationId);
    virtual const L3Address& getAddressParam() const;
    virtual L3Address& getAddressParamForUpdate() { return const_cast<L3Address&>(const_cast<SctpDeleteIPParameter*>(this)->getAddressParam());}
    virtual void setAddressParam(const L3Address& addressParam);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SctpDeleteIPParameter& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SctpDeleteIPParameter& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:343</tt> by nedtool.
 * <pre>
 * class SctpSetPrimaryIPParameter extends SctpParameter
 * {
 *     uint32 requestCorrelationId; //assigned by the sender to identify each request parameter
 *     L3Address addressParam;
 * }
 * </pre>
 */
class INET_API SctpSetPrimaryIPParameter : public ::inet::sctp::SctpParameter
{
  protected:
    uint32_t requestCorrelationId = 0;
    L3Address addressParam;

  private:
    void copy(const SctpSetPrimaryIPParameter& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SctpSetPrimaryIPParameter&);

  public:
    SctpSetPrimaryIPParameter(const char *name=nullptr);
    SctpSetPrimaryIPParameter(const SctpSetPrimaryIPParameter& other);
    virtual ~SctpSetPrimaryIPParameter();
    SctpSetPrimaryIPParameter& operator=(const SctpSetPrimaryIPParameter& other);
    virtual SctpSetPrimaryIPParameter *dup() const override {return new SctpSetPrimaryIPParameter(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint32_t getRequestCorrelationId() const;
    virtual void setRequestCorrelationId(uint32_t requestCorrelationId);
    virtual const L3Address& getAddressParam() const;
    virtual L3Address& getAddressParamForUpdate() { return const_cast<L3Address&>(const_cast<SctpSetPrimaryIPParameter*>(this)->getAddressParam());}
    virtual void setAddressParam(const L3Address& addressParam);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SctpSetPrimaryIPParameter& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SctpSetPrimaryIPParameter& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:349</tt> by nedtool.
 * <pre>
 * class SctpSupportedExtensionsParameter extends SctpParameter
 * {
 *     uint16 sctpChunkTypes[];
 * }
 * </pre>
 */
class INET_API SctpSupportedExtensionsParameter : public ::inet::sctp::SctpParameter
{
  protected:
    uint16_t *sctpChunkTypes = nullptr;
    size_t sctpChunkTypes_arraysize = 0;

  private:
    void copy(const SctpSupportedExtensionsParameter& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SctpSupportedExtensionsParameter&);

  public:
    SctpSupportedExtensionsParameter(const char *name=nullptr);
    SctpSupportedExtensionsParameter(const SctpSupportedExtensionsParameter& other);
    virtual ~SctpSupportedExtensionsParameter();
    SctpSupportedExtensionsParameter& operator=(const SctpSupportedExtensionsParameter& other);
    virtual SctpSupportedExtensionsParameter *dup() const override {return new SctpSupportedExtensionsParameter(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual void setSctpChunkTypesArraySize(size_t size);
    virtual size_t getSctpChunkTypesArraySize() const;
    virtual uint16_t getSctpChunkTypes(size_t k) const;
    virtual void setSctpChunkTypes(size_t k, uint16_t sctpChunkTypes);
    virtual void insertSctpChunkTypes(uint16_t sctpChunkTypes);
    virtual void insertSctpChunkTypes(size_t k, uint16_t sctpChunkTypes);
    virtual void eraseSctpChunkTypes(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SctpSupportedExtensionsParameter& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SctpSupportedExtensionsParameter& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:354</tt> by nedtool.
 * <pre>
 * class SctpErrorCauseParameter extends SctpParameter
 * {
 *     uint32 responseCorrelationId;
 *     uint32 errorCauseType;
 * }
 * </pre>
 */
class INET_API SctpErrorCauseParameter : public ::inet::sctp::SctpParameter
{
  protected:
    uint32_t responseCorrelationId = 0;
    uint32_t errorCauseType = 0;

  private:
    void copy(const SctpErrorCauseParameter& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SctpErrorCauseParameter&);

  public:
    SctpErrorCauseParameter(const char *name=nullptr);
    SctpErrorCauseParameter(const SctpErrorCauseParameter& other);
    virtual ~SctpErrorCauseParameter();
    SctpErrorCauseParameter& operator=(const SctpErrorCauseParameter& other);
    virtual SctpErrorCauseParameter *dup() const override {return new SctpErrorCauseParameter(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint32_t getResponseCorrelationId() const;
    virtual void setResponseCorrelationId(uint32_t responseCorrelationId);
    virtual uint32_t getErrorCauseType() const;
    virtual void setErrorCauseType(uint32_t errorCauseType);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SctpErrorCauseParameter& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SctpErrorCauseParameter& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:360</tt> by nedtool.
 * <pre>
 * class SctpSimpleErrorCauseParameter extends SctpParameter
 * {
 *     uint16 value;
 * }
 * </pre>
 */
class INET_API SctpSimpleErrorCauseParameter : public ::inet::sctp::SctpParameter
{
  protected:
    uint16_t value = 0;

  private:
    void copy(const SctpSimpleErrorCauseParameter& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SctpSimpleErrorCauseParameter&);

  public:
    SctpSimpleErrorCauseParameter(const char *name=nullptr);
    SctpSimpleErrorCauseParameter(const SctpSimpleErrorCauseParameter& other);
    virtual ~SctpSimpleErrorCauseParameter();
    SctpSimpleErrorCauseParameter& operator=(const SctpSimpleErrorCauseParameter& other);
    virtual SctpSimpleErrorCauseParameter *dup() const override {return new SctpSimpleErrorCauseParameter(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint16_t getValue() const;
    virtual void setValue(uint16_t value);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SctpSimpleErrorCauseParameter& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SctpSimpleErrorCauseParameter& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:365</tt> by nedtool.
 * <pre>
 * class SctpSuccessIndication extends SctpParameter
 * {
 *     uint32 responseCorrelationId;
 * }
 * </pre>
 */
class INET_API SctpSuccessIndication : public ::inet::sctp::SctpParameter
{
  protected:
    uint32_t responseCorrelationId = 0;

  private:
    void copy(const SctpSuccessIndication& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SctpSuccessIndication&);

  public:
    SctpSuccessIndication(const char *name=nullptr);
    SctpSuccessIndication(const SctpSuccessIndication& other);
    virtual ~SctpSuccessIndication();
    SctpSuccessIndication& operator=(const SctpSuccessIndication& other);
    virtual SctpSuccessIndication *dup() const override {return new SctpSuccessIndication(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint32_t getResponseCorrelationId() const;
    virtual void setResponseCorrelationId(uint32_t responseCorrelationId);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SctpSuccessIndication& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SctpSuccessIndication& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/transportlayer/sctp/SctpHeader.msg:370</tt> by nedtool.
 * <pre>
 * class NatMessage extends cMessage
 * {
 *     bool multi;
 *     uint16 peer1;
 *     L3Address peer1Addresses[];
 *     uint32 portPeer1;
 *     uint16 peer2;
 *     L3Address peer2Addresses[];
 *     uint32 portPeer2;
 * }
 * </pre>
 */
class INET_API NatMessage : public ::omnetpp::cMessage
{
  protected:
    bool multi = false;
    uint16_t peer1 = 0;
    L3Address *peer1Addresses = nullptr;
    size_t peer1Addresses_arraysize = 0;
    uint32_t portPeer1 = 0;
    uint16_t peer2 = 0;
    L3Address *peer2Addresses = nullptr;
    size_t peer2Addresses_arraysize = 0;
    uint32_t portPeer2 = 0;

  private:
    void copy(const NatMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NatMessage&);

  public:
    NatMessage(const char *name=nullptr);
    NatMessage(const NatMessage& other);
    virtual ~NatMessage();
    NatMessage& operator=(const NatMessage& other);
    virtual NatMessage *dup() const override {return new NatMessage(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual bool getMulti() const;
    virtual void setMulti(bool multi);
    virtual uint16_t getPeer1() const;
    virtual void setPeer1(uint16_t peer1);
    virtual void setPeer1AddressesArraySize(size_t size);
    virtual size_t getPeer1AddressesArraySize() const;
    virtual const L3Address& getPeer1Addresses(size_t k) const;
    virtual L3Address& getPeer1AddressesForUpdate(size_t k) { return const_cast<L3Address&>(const_cast<NatMessage*>(this)->getPeer1Addresses(k));}
    virtual void setPeer1Addresses(size_t k, const L3Address& peer1Addresses);
    virtual void insertPeer1Addresses(const L3Address& peer1Addresses);
    virtual void insertPeer1Addresses(size_t k, const L3Address& peer1Addresses);
    virtual void erasePeer1Addresses(size_t k);
    virtual uint32_t getPortPeer1() const;
    virtual void setPortPeer1(uint32_t portPeer1);
    virtual uint16_t getPeer2() const;
    virtual void setPeer2(uint16_t peer2);
    virtual void setPeer2AddressesArraySize(size_t size);
    virtual size_t getPeer2AddressesArraySize() const;
    virtual const L3Address& getPeer2Addresses(size_t k) const;
    virtual L3Address& getPeer2AddressesForUpdate(size_t k) { return const_cast<L3Address&>(const_cast<NatMessage*>(this)->getPeer2Addresses(k));}
    virtual void setPeer2Addresses(size_t k, const L3Address& peer2Addresses);
    virtual void insertPeer2Addresses(const L3Address& peer2Addresses);
    virtual void insertPeer2Addresses(size_t k, const L3Address& peer2Addresses);
    virtual void erasePeer2Addresses(size_t k);
    virtual uint32_t getPortPeer2() const;
    virtual void setPortPeer2(uint32_t portPeer2);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const NatMessage& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, NatMessage& obj) {obj.parsimUnpack(b);}

} // namespace sctp
} // namespace inet

#endif // ifndef __INET__SCTP_SCTPHEADER_M_H

