//
// Generated file, do not edit! Created by nedtool 5.6 from inet/transportlayer/rtp/RtpInnerPacket.msg.
//

#ifndef __INET__RTP_RTPINNERPACKET_M_H
#define __INET__RTP_RTPINNERPACKET_M_H

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0506
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif

// dll export symbol
#ifndef INET_API
#  if defined(INET_EXPORT)
#    define INET_API  OPP_DLLEXPORT
#  elif defined(INET_IMPORT)
#    define INET_API  OPP_DLLIMPORT
#  else
#    define INET_API
#  endif
#endif


namespace inet {
namespace rtp {

class RtpInnerPacket;
} // namespace rtp
} // namespace inet

#include "inet/common/INETDefs_m.h" // import inet.common.INETDefs

#include "inet/networklayer/contract/ipv4/Ipv4Address_m.h" // import inet.networklayer.contract.ipv4.Ipv4Address

#include "inet/transportlayer/rtp/RtpSenderControlMessage_m.h" // import inet.transportlayer.rtp.RtpSenderControlMessage

#include "inet/transportlayer/rtp/RtpSenderStatusMessage_m.h" // import inet.transportlayer.rtp.RtpSenderStatusMessage

// cplusplus {{
#include "inet/common/packet/Packet.h"
#include "inet/transportlayer/rtp/RtpPacket_m.h"
// }}


namespace inet {
namespace rtp {

/**
 * Enum generated from <tt>inet/transportlayer/rtp/RtpInnerPacket.msg:37</tt> by nedtool.
 * <pre>
 * //
 * // This enumeration is a list of all possibly types of
 * // an ~RtpInnerPacket.
 * //
 * enum RtpInpType
 * {
 *     RTP_INP_UNDEF = 0;
 *     RTP_INP_INITIALIZE_PROFILE = 1;
 *     RTP_INP_PROFILE_INITIALIZED = 2;
 *     RTP_INP_INITIALIZE_RTCP = 3;
 *     RTP_INP_RTCP_INITIALIZED = 4;
 *     RTP_INP_CREATE_SENDER_MODULE = 5;
 *     RTP_INP_SENDER_MODULE_CREATED = 6;
 *     RTP_INP_DELETE_SENDER_MODULE = 7;
 *     RTP_INP_SENDER_MODULE_DELETED = 8;
 *     RTP_INP_INITIALIZE_SENDER_MODULE = 9;
 *     RTP_INP_SENDER_MODULE_INITIALIZED = 10;
 *     RTP_INP_SENDER_MODULE_CONTROL = 11;
 *     RTP_INP_SENDER_MODULE_STATUS = 12;
 *     RTP_INP_LEAVE_SESSION = 13;
 *     RTP_INP_SESSION_LEFT = 14;
 *     RTP_INP_DATA_OUT = 15;
 *     RTP_INP_DATA_IN = 16;
 * }
 * </pre>
 */
enum RtpInpType {
    RTP_INP_UNDEF = 0,
    RTP_INP_INITIALIZE_PROFILE = 1,
    RTP_INP_PROFILE_INITIALIZED = 2,
    RTP_INP_INITIALIZE_RTCP = 3,
    RTP_INP_RTCP_INITIALIZED = 4,
    RTP_INP_CREATE_SENDER_MODULE = 5,
    RTP_INP_SENDER_MODULE_CREATED = 6,
    RTP_INP_DELETE_SENDER_MODULE = 7,
    RTP_INP_SENDER_MODULE_DELETED = 8,
    RTP_INP_INITIALIZE_SENDER_MODULE = 9,
    RTP_INP_SENDER_MODULE_INITIALIZED = 10,
    RTP_INP_SENDER_MODULE_CONTROL = 11,
    RTP_INP_SENDER_MODULE_STATUS = 12,
    RTP_INP_LEAVE_SESSION = 13,
    RTP_INP_SESSION_LEFT = 14,
    RTP_INP_DATA_OUT = 15,
    RTP_INP_DATA_IN = 16
};

/**
 * Class generated from <tt>inet/transportlayer/rtp/RtpInnerPacket.msg:61</tt> by nedtool.
 * <pre>
 * //
 * // This class is used for communication between submodules of the RTP layer module.
 * //
 * packet RtpInnerPacket
 * {
 *     // The type of this ~RtpInnerPacket.
 *     RtpInpType type = RTP_INP_UNDEF;
 * 
 *     // The CNAME
 *     string commonName;
 * 
 *     // The MTU
 *     int mtu;
 * 
 *     // The Bandwidth
 *     int bandwidth;
 * 
 *     // The RTCP percentage
 *     int rtcpPercentage;
 * 
 *     // The Ipv4 address
 *     Ipv4Address address = Ipv4Address::UNSPECIFIED_ADDRESS;
 * 
 *     // The port number
 *     int port = PORT_UNDEF;
 * 
 *     // The SSRC identifier
 *     uint32 ssrc;
 * 
 *     // The payload type
 *     int payloadType;
 * 
 *     // The file name
 *     string fileName;
 * 
 *     // The clock rate
 *     int clockRate;
 * 
 *     // The RTP time stamp base
 *     int timeStampBase;
 * 
 *     // The RTP sequence number base
 *     int sequenceNumberBase;
 * }
 * </pre>
 */
class INET_API RtpInnerPacket : public ::omnetpp::cPacket
{
  protected:
    inet::rtp::RtpInpType type = RTP_INP_UNDEF;
    omnetpp::opp_string commonName;
    int mtu = 0;
    int bandwidth = 0;
    int rtcpPercentage = 0;
    Ipv4Address address = Ipv4Address::UNSPECIFIED_ADDRESS;
    int port = PORT_UNDEF;
    uint32_t ssrc = 0;
    int payloadType = 0;
    omnetpp::opp_string fileName;
    int clockRate = 0;
    int timeStampBase = 0;
    int sequenceNumberBase = 0;

  private:
    void copy(const RtpInnerPacket& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const RtpInnerPacket&);

  public:
    RtpInnerPacket(const char *name=nullptr, short kind=0);
    RtpInnerPacket(const RtpInnerPacket& other);
    virtual ~RtpInnerPacket();
    RtpInnerPacket& operator=(const RtpInnerPacket& other);
    virtual RtpInnerPacket *dup() const override {return new RtpInnerPacket(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual inet::rtp::RtpInpType getType() const;
    virtual void setType(inet::rtp::RtpInpType type);
    virtual const char * getCommonName() const;
    virtual void setCommonName(const char * commonName);
    virtual int getMtu() const;
    virtual void setMtu(int mtu);
    virtual int getBandwidth() const;
    virtual void setBandwidth(int bandwidth);
    virtual int getRtcpPercentage() const;
    virtual void setRtcpPercentage(int rtcpPercentage);
    virtual const Ipv4Address& getAddress() const;
    virtual Ipv4Address& getAddressForUpdate() { return const_cast<Ipv4Address&>(const_cast<RtpInnerPacket*>(this)->getAddress());}
    virtual void setAddress(const Ipv4Address& address);
    virtual int getPort() const;
    virtual void setPort(int port);
    virtual uint32_t getSsrc() const;
    virtual void setSsrc(uint32_t ssrc);
    virtual int getPayloadType() const;
    virtual void setPayloadType(int payloadType);
    virtual const char * getFileName() const;
    virtual void setFileName(const char * fileName);
    virtual int getClockRate() const;
    virtual void setClockRate(int clockRate);
    virtual int getTimeStampBase() const;
    virtual void setTimeStampBase(int timeStampBase);
    virtual int getSequenceNumberBase() const;
    virtual void setSequenceNumberBase(int sequenceNumberBase);

  public:
    /**
     * Writes a short info about this RtpInnerPacket into the given string.
     */
    virtual std::string str() const override;

    /**
     * Writes a longer info about this RtpInnerPacket into the given output stream.
     */
    virtual void dump(std::ostream& os) const;

    /**
     * Called by the rtp module after creating the profile module. It
     * informes the profile about the maximum size an rtp packet can have.
     */
    virtual void setInitializeProfilePkt(int mtu);

    /**
     * Called by the profile module after it has received the initializeProfile()
     * message. It informs the rtp module about the percentage of the available
     * bandwidth to be used by rtcp and the preferred port for this profile.
     */
    virtual void setProfileInitializedPkt(int rtcpPercentage, int port);

    /**
     * Called by the rtp module to inform the rtcp module about mandatory
     * information for starting the rtp session.
     */
    virtual void setInitializeRTCPPkt(const char *commonName, int mtu, int bandwidth,
            int rtcpPercentage, Ipv4Address address, int port);

    /**
     * Called by the rtcp module after it has waited for half an rtcp interval
     * for incoming messages from other session participants. It informs the rtp
     * module which later informs the rtp application about the ssrc identifier
     */
    virtual void setRtcpInitializedPkt(uint32 ssrc);

    virtual void setCreateSenderModulePkt(uint32 ssrc, int payloadType, const char *fileName);
    virtual void setSenderModuleCreatedPkt(uint32 ssrc);

    virtual void setDeleteSenderModulePkt(uint32 ssrc);
    virtual void setSenderModuleDeletedPkt(uint32 ssrc);

    virtual void setInitializeSenderModulePkt(uint32 ssrc, const char *fileName, int mtu);
    virtual void setSenderModuleInitializedPkt(uint32 ssrc, int payloadType, int clockRate,
            int timeStampBase, int sequenceNumberBase);

    virtual void setSenderModuleControlPkt(uint32 ssrc, RtpSenderControlMessage *msg);
    virtual void setSenderModuleStatusPkt(uint32 ssrc, RtpSenderStatusMessage *msg);

    /**
     * Called by the rtp module to inform the rtcp module that the session
     * should be left.
     */
    virtual void setLeaveSessionPkt();

    /**
     * Called by the rtcp module when the rtcp bye packet has been sent
     * to the network.
     */
    virtual void setSessionLeftPkt();

    /**
     * Capsulates the outgoing RtpPacket into this RtpInnerPacket to transport
     * it within the rtp layer.
     */
    virtual void setDataOutPkt(Packet *packet);

    /**
     * Capsulates the incoming RtpPacket into this RtpInnerPacket to transport
     * it within the rtp layer.
     */
    virtual void setDataInPkt(Packet *packet, Ipv4Address address, int port);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const RtpInnerPacket& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, RtpInnerPacket& obj) {obj.parsimUnpack(b);}

} // namespace rtp
} // namespace inet

#endif // ifndef __INET__RTP_RTPINNERPACKET_M_H

