//
// Generated file, do not edit! Created by nedtool 5.6 from inet/routing/pim/PimPacket.msg.
//

#ifndef __INET_PIMPACKET_M_H
#define __INET_PIMPACKET_M_H

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0506
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif

// dll export symbol
#ifndef INET_API
#  if defined(INET_EXPORT)
#    define INET_API  OPP_DLLEXPORT
#  elif defined(INET_IMPORT)
#    define INET_API  OPP_DLLIMPORT
#  else
#    define INET_API
#  endif
#endif


namespace inet {

class HelloOption;
class HoldtimeOption;
class LanPruneDelayOption;
class DrPriorityOption;
class GenerationIdOption;
struct EncodedAddress;
class JoinPruneGroup;
class PimPacket;
class PimHello;
class PimJoinPrune;
class PimAssert;
class PimGraft;
class PimStateRefresh;
class PimRegister;
class PimRegisterStop;
} // namespace inet

#include "inet/common/INETDefs_m.h" // import inet.common.INETDefs

#include "inet/common/Units_m.h" // import inet.common.Units

#include "inet/common/packet/chunk/Chunk_m.h" // import inet.common.packet.chunk.Chunk

#include "inet/networklayer/contract/ipv4/Ipv4Address_m.h" // import inet.networklayer.contract.ipv4.Ipv4Address


namespace inet {

// cplusplus {{
const B PIM_HEADER_LENGTH = B(4);
const B ENCODED_UNICODE_ADDRESS_LENGTH = B(6); // Ipv4 only
const B ENCODED_GROUP_ADDRESS_LENGTH = B(8); // Ipv4 only
const B ENCODED_SOURCE_ADDRESS_LENGTH = B(8); // Ipv4 only
// }}

/**
 * Enum generated from <tt>inet/routing/pim/PimPacket.msg:36</tt> by nedtool.
 * <pre>
 * enum PimPacketType
 * {
 *     Hello = 0;
 *     Register = 1;
 *     RegisterStop = 2;
 *     JoinPrune = 3;
 *     Bootstrap = 4;
 *     Assert = 5;
 *     Graft = 6;
 *     GraftAck = 7;
 *     CandidateRPAdvertisement = 8;
 *     StateRefresh = 9;
 * }
 * </pre>
 */
enum PimPacketType {
    Hello = 0,
    Register = 1,
    RegisterStop = 2,
    JoinPrune = 3,
    Bootstrap = 4,
    Assert = 5,
    Graft = 6,
    GraftAck = 7,
    CandidateRPAdvertisement = 8,
    StateRefresh = 9
};

/**
 * Enum generated from <tt>inet/routing/pim/PimPacket.msg:50</tt> by nedtool.
 * <pre>
 * enum PimHelloOptionType
 * {
 *     Holdtime = 1;
 *     LANPruneDelay = 2;
 *     DRPriority = 19;
 *     GenerationID = 20;
 *     StateRefreshCapable = 21;
 *     AddressList = 24;
 * }
 * </pre>
 */
enum PimHelloOptionType {
    Holdtime = 1,
    LANPruneDelay = 2,
    DRPriority = 19,
    GenerationID = 20,
    StateRefreshCapable = 21,
    AddressList = 24
};

/**
 * Class generated from <tt>inet/routing/pim/PimPacket.msg:60</tt> by nedtool.
 * <pre>
 * class HelloOption extends cObject
 * {
 *     PimHelloOptionType type;
 * }
 * </pre>
 */
class INET_API HelloOption : public ::omnetpp::cObject
{
  protected:
    inet::PimHelloOptionType type = static_cast<inet::PimHelloOptionType>(-1);

  private:
    void copy(const HelloOption& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const HelloOption&);

  public:
    HelloOption();
    HelloOption(const HelloOption& other);
    virtual ~HelloOption();
    HelloOption& operator=(const HelloOption& other);
    virtual HelloOption *dup() const override {return new HelloOption(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual inet::PimHelloOptionType getType() const;
    virtual void setType(inet::PimHelloOptionType type);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const HelloOption& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, HelloOption& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/routing/pim/PimPacket.msg:65</tt> by nedtool.
 * <pre>
 * class HoldtimeOption extends HelloOption
 * {
 *     type = Holdtime;
 *     uint16_t holdTime;
 * }
 * </pre>
 */
class INET_API HoldtimeOption : public ::inet::HelloOption
{
  protected:
    uint16_t holdTime = 0;

  private:
    void copy(const HoldtimeOption& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const HoldtimeOption&);

  public:
    HoldtimeOption();
    HoldtimeOption(const HoldtimeOption& other);
    virtual ~HoldtimeOption();
    HoldtimeOption& operator=(const HoldtimeOption& other);
    virtual HoldtimeOption *dup() const override {return new HoldtimeOption(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint16_t getHoldTime() const;
    virtual void setHoldTime(uint16_t holdTime);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const HoldtimeOption& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, HoldtimeOption& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/routing/pim/PimPacket.msg:71</tt> by nedtool.
 * <pre>
 * class LanPruneDelayOption extends HelloOption
 * {
 *     type = LANPruneDelay;
 *     uint16_t propagationDelay;
 *     uint16_t overrideInterval;
 * }
 * </pre>
 */
class INET_API LanPruneDelayOption : public ::inet::HelloOption
{
  protected:
    uint16_t propagationDelay = 0;
    uint16_t overrideInterval = 0;

  private:
    void copy(const LanPruneDelayOption& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const LanPruneDelayOption&);

  public:
    LanPruneDelayOption();
    LanPruneDelayOption(const LanPruneDelayOption& other);
    virtual ~LanPruneDelayOption();
    LanPruneDelayOption& operator=(const LanPruneDelayOption& other);
    virtual LanPruneDelayOption *dup() const override {return new LanPruneDelayOption(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint16_t getPropagationDelay() const;
    virtual void setPropagationDelay(uint16_t propagationDelay);
    virtual uint16_t getOverrideInterval() const;
    virtual void setOverrideInterval(uint16_t overrideInterval);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const LanPruneDelayOption& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, LanPruneDelayOption& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/routing/pim/PimPacket.msg:78</tt> by nedtool.
 * <pre>
 * class DrPriorityOption extends HelloOption
 * {
 *     type = DRPriority;
 *     uint32_t priority;
 * }
 * </pre>
 */
class INET_API DrPriorityOption : public ::inet::HelloOption
{
  protected:
    uint32_t priority = 0;

  private:
    void copy(const DrPriorityOption& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const DrPriorityOption&);

  public:
    DrPriorityOption();
    DrPriorityOption(const DrPriorityOption& other);
    virtual ~DrPriorityOption();
    DrPriorityOption& operator=(const DrPriorityOption& other);
    virtual DrPriorityOption *dup() const override {return new DrPriorityOption(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint32_t getPriority() const;
    virtual void setPriority(uint32_t priority);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const DrPriorityOption& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, DrPriorityOption& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/routing/pim/PimPacket.msg:84</tt> by nedtool.
 * <pre>
 * class GenerationIdOption extends HelloOption
 * {
 *     type = GenerationID;
 *     uint32_t generationID;
 * }
 * 
 * //class AddressListOption extends HelloOption
 * //{
 * //    Ipv4Address secondaryAddresses[];
 * //}
 * </pre>
 */
class INET_API GenerationIdOption : public ::inet::HelloOption
{
  protected:
    uint32_t generationID = 0;

  private:
    void copy(const GenerationIdOption& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const GenerationIdOption&);

  public:
    GenerationIdOption();
    GenerationIdOption(const GenerationIdOption& other);
    virtual ~GenerationIdOption();
    GenerationIdOption& operator=(const GenerationIdOption& other);
    virtual GenerationIdOption *dup() const override {return new GenerationIdOption(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint32_t getGenerationID() const;
    virtual void setGenerationID(uint32_t generationID);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const GenerationIdOption& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, GenerationIdOption& obj) {obj.parsimUnpack(b);}

/**
 * Struct generated from inet/routing/pim/PimPacket.msg:95 by nedtool.
 */
struct INET_API EncodedAddress
{
    EncodedAddress();
    Ipv4Address IPaddress;
    bool S;
    bool W;
    bool R;
};

// helpers for local use
void INET_API __doPacking(omnetpp::cCommBuffer *b, const EncodedAddress& a);
void INET_API __doUnpacking(omnetpp::cCommBuffer *b, EncodedAddress& a);

inline void doParsimPacking(omnetpp::cCommBuffer *b, const EncodedAddress& obj) { __doPacking(b, obj); }
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, EncodedAddress& obj) { __doUnpacking(b, obj); }

/**
 * Class generated from <tt>inet/routing/pim/PimPacket.msg:105</tt> by nedtool.
 * <pre>
 * // Record for Join/Prune message
 * // in structure it is not possible to use dynamic arrays, iit is needed to use class
 * class JoinPruneGroup extends cObject
 * {
 *     Ipv4Address groupAddress;
 *     EncodedAddress joinedSourceAddress[];
 *     EncodedAddress prunedSourceAddress[];
 * }
 * </pre>
 */
class INET_API JoinPruneGroup : public ::omnetpp::cObject
{
  protected:
    Ipv4Address groupAddress;
    EncodedAddress *joinedSourceAddress = nullptr;
    size_t joinedSourceAddress_arraysize = 0;
    EncodedAddress *prunedSourceAddress = nullptr;
    size_t prunedSourceAddress_arraysize = 0;

  private:
    void copy(const JoinPruneGroup& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const JoinPruneGroup&);

  public:
    JoinPruneGroup();
    JoinPruneGroup(const JoinPruneGroup& other);
    virtual ~JoinPruneGroup();
    JoinPruneGroup& operator=(const JoinPruneGroup& other);
    virtual JoinPruneGroup *dup() const override {return new JoinPruneGroup(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const Ipv4Address& getGroupAddress() const;
    virtual Ipv4Address& getGroupAddressForUpdate() { return const_cast<Ipv4Address&>(const_cast<JoinPruneGroup*>(this)->getGroupAddress());}
    virtual void setGroupAddress(const Ipv4Address& groupAddress);
    virtual void setJoinedSourceAddressArraySize(size_t size);
    virtual size_t getJoinedSourceAddressArraySize() const;
    virtual const EncodedAddress& getJoinedSourceAddress(size_t k) const;
    virtual EncodedAddress& getJoinedSourceAddressForUpdate(size_t k) { return const_cast<EncodedAddress&>(const_cast<JoinPruneGroup*>(this)->getJoinedSourceAddress(k));}
    virtual void setJoinedSourceAddress(size_t k, const EncodedAddress& joinedSourceAddress);
    virtual void insertJoinedSourceAddress(const EncodedAddress& joinedSourceAddress);
    virtual void insertJoinedSourceAddress(size_t k, const EncodedAddress& joinedSourceAddress);
    virtual void eraseJoinedSourceAddress(size_t k);
    virtual void setPrunedSourceAddressArraySize(size_t size);
    virtual size_t getPrunedSourceAddressArraySize() const;
    virtual const EncodedAddress& getPrunedSourceAddress(size_t k) const;
    virtual EncodedAddress& getPrunedSourceAddressForUpdate(size_t k) { return const_cast<EncodedAddress&>(const_cast<JoinPruneGroup*>(this)->getPrunedSourceAddress(k));}
    virtual void setPrunedSourceAddress(size_t k, const EncodedAddress& prunedSourceAddress);
    virtual void insertPrunedSourceAddress(const EncodedAddress& prunedSourceAddress);
    virtual void insertPrunedSourceAddress(size_t k, const EncodedAddress& prunedSourceAddress);
    virtual void erasePrunedSourceAddress(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const JoinPruneGroup& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, JoinPruneGroup& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/routing/pim/PimPacket.msg:114</tt> by nedtool.
 * <pre>
 * ///////////////////////////////////////////////////////////////////////////////////////////////
 * // Header
 * class PimPacket extends FieldsChunk
 * {
 *     short version = 2;
 *     PimPacketType type;
 * }
 * </pre>
 */
class INET_API PimPacket : public ::inet::FieldsChunk
{
  protected:
    short version = 2;
    inet::PimPacketType type = static_cast<inet::PimPacketType>(-1);

  private:
    void copy(const PimPacket& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const PimPacket&);

  public:
    PimPacket();
    PimPacket(const PimPacket& other);
    virtual ~PimPacket();
    PimPacket& operator=(const PimPacket& other);
    virtual PimPacket *dup() const override {return new PimPacket(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual short getVersion() const;
    virtual void setVersion(short version);
    virtual inet::PimPacketType getType() const;
    virtual void setType(inet::PimPacketType type);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const PimPacket& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, PimPacket& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/routing/pim/PimPacket.msg:122</tt> by nedtool.
 * <pre>
 * // Hello message
 * // DM, SM
 * class PimHello extends PimPacket
 * {
 *     type = Hello;
 *     HelloOption *options[] \@owned \@allowReplace;
 * }
 * </pre>
 */
class INET_API PimHello : public ::inet::PimPacket
{
  protected:
    HelloOption * *options = nullptr;
    size_t options_arraysize = 0;

  private:
    void copy(const PimHello& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const PimHello&);

  public:
    PimHello();
    PimHello(const PimHello& other);
    virtual ~PimHello();
    PimHello& operator=(const PimHello& other);
    virtual PimHello *dup() const override {return new PimHello(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual void setOptionsArraySize(size_t size);
    virtual size_t getOptionsArraySize() const;
    virtual const HelloOption * getOptions(size_t k) const;
    virtual HelloOption * getOptionsForUpdate(size_t k) { handleChange();return const_cast<HelloOption *>(const_cast<PimHello*>(this)->getOptions(k));}
    virtual HelloOption * dropOptions(size_t k);
    virtual void setOptions(size_t k, HelloOption * options);
    virtual void insertOptions(HelloOption * options);
    virtual void insertOptions(size_t k, HelloOption * options);
    virtual void eraseOptions(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const PimHello& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, PimHello& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/routing/pim/PimPacket.msg:130</tt> by nedtool.
 * <pre>
 * // Join/Prune message
 * // DM, SM
 * class PimJoinPrune extends PimPacket
 * {
 *     type = JoinPrune;
 *     Ipv4Address upstreamNeighborAddress;
 *     int holdTime;
 *     //int                numGroups;
 *     JoinPruneGroup joinPruneGroups[];
 * }
 * </pre>
 */
class INET_API PimJoinPrune : public ::inet::PimPacket
{
  protected:
    Ipv4Address upstreamNeighborAddress;
    int holdTime = 0;
    JoinPruneGroup *joinPruneGroups = nullptr;
    size_t joinPruneGroups_arraysize = 0;

  private:
    void copy(const PimJoinPrune& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const PimJoinPrune&);

  public:
    PimJoinPrune();
    PimJoinPrune(const PimJoinPrune& other);
    virtual ~PimJoinPrune();
    PimJoinPrune& operator=(const PimJoinPrune& other);
    virtual PimJoinPrune *dup() const override {return new PimJoinPrune(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const Ipv4Address& getUpstreamNeighborAddress() const;
    virtual Ipv4Address& getUpstreamNeighborAddressForUpdate() { handleChange();return const_cast<Ipv4Address&>(const_cast<PimJoinPrune*>(this)->getUpstreamNeighborAddress());}
    virtual void setUpstreamNeighborAddress(const Ipv4Address& upstreamNeighborAddress);
    virtual int getHoldTime() const;
    virtual void setHoldTime(int holdTime);
    virtual void setJoinPruneGroupsArraySize(size_t size);
    virtual size_t getJoinPruneGroupsArraySize() const;
    virtual const JoinPruneGroup& getJoinPruneGroups(size_t k) const;
    virtual JoinPruneGroup& getJoinPruneGroupsForUpdate(size_t k) { handleChange();return const_cast<JoinPruneGroup&>(const_cast<PimJoinPrune*>(this)->getJoinPruneGroups(k));}
    virtual void setJoinPruneGroups(size_t k, const JoinPruneGroup& joinPruneGroups);
    virtual void insertJoinPruneGroups(const JoinPruneGroup& joinPruneGroups);
    virtual void insertJoinPruneGroups(size_t k, const JoinPruneGroup& joinPruneGroups);
    virtual void eraseJoinPruneGroups(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const PimJoinPrune& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, PimJoinPrune& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/routing/pim/PimPacket.msg:141</tt> by nedtool.
 * <pre>
 * // Assert message
 * // DM, SM
 * class PimAssert extends PimPacket
 * {
 *     type = Assert;
 *     Ipv4Address groupAddress;
 *     Ipv4Address sourceAddress;
 *     bool R;
 *     int metric;
 *     int metricPreference;
 * }
 * </pre>
 */
class INET_API PimAssert : public ::inet::PimPacket
{
  protected:
    Ipv4Address groupAddress;
    Ipv4Address sourceAddress;
    bool R = false;
    int metric = 0;
    int metricPreference = 0;

  private:
    void copy(const PimAssert& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const PimAssert&);

  public:
    PimAssert();
    PimAssert(const PimAssert& other);
    virtual ~PimAssert();
    PimAssert& operator=(const PimAssert& other);
    virtual PimAssert *dup() const override {return new PimAssert(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const Ipv4Address& getGroupAddress() const;
    virtual Ipv4Address& getGroupAddressForUpdate() { handleChange();return const_cast<Ipv4Address&>(const_cast<PimAssert*>(this)->getGroupAddress());}
    virtual void setGroupAddress(const Ipv4Address& groupAddress);
    virtual const Ipv4Address& getSourceAddress() const;
    virtual Ipv4Address& getSourceAddressForUpdate() { handleChange();return const_cast<Ipv4Address&>(const_cast<PimAssert*>(this)->getSourceAddress());}
    virtual void setSourceAddress(const Ipv4Address& sourceAddress);
    virtual bool getR() const;
    virtual void setR(bool R);
    virtual int getMetric() const;
    virtual void setMetric(int metric);
    virtual int getMetricPreference() const;
    virtual void setMetricPreference(int metricPreference);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const PimAssert& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, PimAssert& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/routing/pim/PimPacket.msg:153</tt> by nedtool.
 * <pre>
 * // Graft message, only message send by unicast
 * // DM
 * class PimGraft extends PimJoinPrune
 * {
 *     type = Graft;
 *     holdTime = 0;
 * }
 * 
 * // GraftAck message
 * // DM
 * // create a PimGraft, then set type = GraftAck
 * </pre>
 */
class INET_API PimGraft : public ::inet::PimJoinPrune
{
  protected:

  private:
    void copy(const PimGraft& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const PimGraft&);

  public:
    PimGraft();
    PimGraft(const PimGraft& other);
    virtual ~PimGraft();
    PimGraft& operator=(const PimGraft& other);
    virtual PimGraft *dup() const override {return new PimGraft(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const PimGraft& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, PimGraft& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/routing/pim/PimPacket.msg:165</tt> by nedtool.
 * <pre>
 * // State Refresh message
 * // DM
 * class PimStateRefresh extends PimPacket
 * {
 *     type = StateRefresh;
 *     Ipv4Address groupAddress;
 *     Ipv4Address sourceAddress;
 *     Ipv4Address originatorAddress;
 *     int metric;
 *     int metricPreference;
 *     short maskLen;
 *     short ttl;
 *     bool P;
 *     int interval;
 * }
 * </pre>
 */
class INET_API PimStateRefresh : public ::inet::PimPacket
{
  protected:
    Ipv4Address groupAddress;
    Ipv4Address sourceAddress;
    Ipv4Address originatorAddress;
    int metric = 0;
    int metricPreference = 0;
    short maskLen = 0;
    short ttl = 0;
    bool P = false;
    int interval = 0;

  private:
    void copy(const PimStateRefresh& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const PimStateRefresh&);

  public:
    PimStateRefresh();
    PimStateRefresh(const PimStateRefresh& other);
    virtual ~PimStateRefresh();
    PimStateRefresh& operator=(const PimStateRefresh& other);
    virtual PimStateRefresh *dup() const override {return new PimStateRefresh(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const Ipv4Address& getGroupAddress() const;
    virtual Ipv4Address& getGroupAddressForUpdate() { handleChange();return const_cast<Ipv4Address&>(const_cast<PimStateRefresh*>(this)->getGroupAddress());}
    virtual void setGroupAddress(const Ipv4Address& groupAddress);
    virtual const Ipv4Address& getSourceAddress() const;
    virtual Ipv4Address& getSourceAddressForUpdate() { handleChange();return const_cast<Ipv4Address&>(const_cast<PimStateRefresh*>(this)->getSourceAddress());}
    virtual void setSourceAddress(const Ipv4Address& sourceAddress);
    virtual const Ipv4Address& getOriginatorAddress() const;
    virtual Ipv4Address& getOriginatorAddressForUpdate() { handleChange();return const_cast<Ipv4Address&>(const_cast<PimStateRefresh*>(this)->getOriginatorAddress());}
    virtual void setOriginatorAddress(const Ipv4Address& originatorAddress);
    virtual int getMetric() const;
    virtual void setMetric(int metric);
    virtual int getMetricPreference() const;
    virtual void setMetricPreference(int metricPreference);
    virtual short getMaskLen() const;
    virtual void setMaskLen(short maskLen);
    virtual short getTtl() const;
    virtual void setTtl(short ttl);
    virtual bool getP() const;
    virtual void setP(bool P);
    virtual int getInterval() const;
    virtual void setInterval(int interval);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const PimStateRefresh& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, PimStateRefresh& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/routing/pim/PimPacket.msg:180</tt> by nedtool.
 * <pre>
 * // Register message
 * // SM
 * class PimRegister extends PimPacket
 * {
 *     type = Register;
 *     bool B;
 *     bool N;
 * }
 * </pre>
 */
class INET_API PimRegister : public ::inet::PimPacket
{
  protected:
    bool B = false;
    bool N = false;

  private:
    void copy(const PimRegister& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const PimRegister&);

  public:
    PimRegister();
    PimRegister(const PimRegister& other);
    virtual ~PimRegister();
    PimRegister& operator=(const PimRegister& other);
    virtual PimRegister *dup() const override {return new PimRegister(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual bool getB() const;
    virtual void setB(bool B);
    virtual bool getN() const;
    virtual void setN(bool N);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const PimRegister& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, PimRegister& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/routing/pim/PimPacket.msg:189</tt> by nedtool.
 * <pre>
 * // Register-Stop message
 * // SM
 * class PimRegisterStop extends PimPacket
 * {
 *     type = RegisterStop;
 *     Ipv4Address groupAddress;
 *     Ipv4Address sourceAddress;
 * }
 * </pre>
 */
class INET_API PimRegisterStop : public ::inet::PimPacket
{
  protected:
    Ipv4Address groupAddress;
    Ipv4Address sourceAddress;

  private:
    void copy(const PimRegisterStop& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const PimRegisterStop&);

  public:
    PimRegisterStop();
    PimRegisterStop(const PimRegisterStop& other);
    virtual ~PimRegisterStop();
    PimRegisterStop& operator=(const PimRegisterStop& other);
    virtual PimRegisterStop *dup() const override {return new PimRegisterStop(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const Ipv4Address& getGroupAddress() const;
    virtual Ipv4Address& getGroupAddressForUpdate() { handleChange();return const_cast<Ipv4Address&>(const_cast<PimRegisterStop*>(this)->getGroupAddress());}
    virtual void setGroupAddress(const Ipv4Address& groupAddress);
    virtual const Ipv4Address& getSourceAddress() const;
    virtual Ipv4Address& getSourceAddressForUpdate() { handleChange();return const_cast<Ipv4Address&>(const_cast<PimRegisterStop*>(this)->getSourceAddress());}
    virtual void setSourceAddress(const Ipv4Address& sourceAddress);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const PimRegisterStop& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, PimRegisterStop& obj) {obj.parsimUnpack(b);}

} // namespace inet

#endif // ifndef __INET_PIMPACKET_M_H

