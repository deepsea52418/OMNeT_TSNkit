//
// Generated file, do not edit! Created by nedtool 5.6 from inet/routing/bgpv4/bgpmessage/BgpHeader.msg.
//

#ifndef __INET__BGP_BGPHEADER_M_H
#define __INET__BGP_BGPHEADER_M_H

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0506
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif

// dll export symbol
#ifndef INET_API
#  if defined(INET_EXPORT)
#    define INET_API  OPP_DLLEXPORT
#  elif defined(INET_IMPORT)
#    define INET_API  OPP_DLLIMPORT
#  else
#    define INET_API
#  endif
#endif


namespace inet {
namespace bgp {

class BgpAsPathSegment;
class BgpHeader;
class BgpKeepAliveMessage;
struct BgpParameterValues;
struct BgpOptionalParameters;
class BgpOpenMessage;
struct BgpUpdateAttributeFlags;
struct BgpUpdateAttributeType;
class BgpUpdatePathAttributes;
class BgpUpdatePathAttributesOrigin;
class BgpUpdatePathAttributesAsPath;
class BgpUpdatePathAttributesNextHop;
class BgpUpdatePathAttributesLocalPref;
class BgpUpdatePathAttributesAtomicAggregate;
struct BgpUpdateWithdrawnRoutes;
struct BgpUpdateNlri;
class BgpUpdatePathAttributeList;
class BgpUpdateMessage;
} // namespace bgp
} // namespace inet

#include "inet/common/INETDefs_m.h" // import inet.common.INETDefs

#include "inet/common/Units_m.h" // import inet.common.Units

#include "inet/common/packet/chunk/Chunk_m.h" // import inet.common.packet.chunk.Chunk

#include "inet/networklayer/contract/ipv4/Ipv4Address_m.h" // import inet.networklayer.contract.ipv4.Ipv4Address

#include "inet/routing/bgpv4/BgpCommon_m.h" // import inet.routing.bgpv4.BgpCommon


namespace inet {
namespace bgp {

// cplusplus {{
const B BGP_HEADER_OCTETS = B(19);
const B BGP_OPEN_OCTETS = B(10);
const B BGP_EMPTY_UPDATE_OCTETS = B(4); // UnfeasibleRoutesLength (2) + TotalPathAttributeLength (2)
// }}

/**
 * Class generated from <tt>inet/routing/bgpv4/bgpmessage/BgpHeader.msg:36</tt> by nedtool.
 * <pre>
 * //
 * // Represents a BGPv4 AS_PATH path attribute (RFC 4271 Section 4.3)
 * //
 * class BgpAsPathSegment extends cObject
 * {
 *     BgpPathSegmentType type;
 *     unsigned char length;
 *     unsigned short asValue[];
 * }
 * </pre>
 */
class INET_API BgpAsPathSegment : public ::omnetpp::cObject
{
  protected:
    inet::bgp::BgpPathSegmentType type = static_cast<inet::bgp::BgpPathSegmentType>(-1);
    unsigned char length = 0;
    unsigned short *asValue = nullptr;
    size_t asValue_arraysize = 0;

  private:
    void copy(const BgpAsPathSegment& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const BgpAsPathSegment&);

  public:
    BgpAsPathSegment();
    BgpAsPathSegment(const BgpAsPathSegment& other);
    virtual ~BgpAsPathSegment();
    BgpAsPathSegment& operator=(const BgpAsPathSegment& other);
    virtual BgpAsPathSegment *dup() const override {return new BgpAsPathSegment(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual inet::bgp::BgpPathSegmentType getType() const;
    virtual void setType(inet::bgp::BgpPathSegmentType type);
    virtual unsigned char getLength() const;
    virtual void setLength(unsigned char length);
    virtual void setAsValueArraySize(size_t size);
    virtual size_t getAsValueArraySize() const;
    virtual unsigned short getAsValue(size_t k) const;
    virtual void setAsValue(size_t k, unsigned short asValue);
    virtual void insertAsValue(unsigned short asValue);
    virtual void insertAsValue(size_t k, unsigned short asValue);
    virtual void eraseAsValue(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const BgpAsPathSegment& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, BgpAsPathSegment& obj) {obj.parsimUnpack(b);}

/**
 * Enum generated from <tt>inet/routing/bgpv4/bgpmessage/BgpHeader.msg:47</tt> by nedtool.
 * <pre>
 * //
 * // BGPv4 message types
 * //
 * enum BgpType
 * {
 *     BGP_OPEN = 1;
 *     BGP_UPDATE = 2;
 *     BGP_NOTIFICATION = 3;
 *     BGP_KEEPALIVE = 4;
 * }
 * </pre>
 */
enum BgpType {
    BGP_OPEN = 1,
    BGP_UPDATE = 2,
    BGP_NOTIFICATION = 3,
    BGP_KEEPALIVE = 4
};

/**
 * Class generated from <tt>inet/routing/bgpv4/bgpmessage/BgpHeader.msg:63</tt> by nedtool.
 * <pre>
 * //
 * // Represents a BGPv4 message header.
 * //
 * // Header fields modeled:
 * //   - Marker: 16 octets (authentication)
 * //   - Length: 2 octets  (total size of the message)
 * //   - Type: 1 octet
 * //
 * class BgpHeader extends FieldsChunk
 * {
 *     chunkLength = BGP_HEADER_OCTETS;
 *     BgpType type;
 * }
 * </pre>
 */
class INET_API BgpHeader : public ::inet::FieldsChunk
{
  protected:
    inet::bgp::BgpType type = static_cast<inet::bgp::BgpType>(-1);

  private:
    void copy(const BgpHeader& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const BgpHeader&);

  public:
    BgpHeader();
    BgpHeader(const BgpHeader& other);
    virtual ~BgpHeader();
    BgpHeader& operator=(const BgpHeader& other);
    virtual BgpHeader *dup() const override {return new BgpHeader(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual inet::bgp::BgpType getType() const;
    virtual void setType(inet::bgp::BgpType type);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const BgpHeader& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, BgpHeader& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/routing/bgpv4/bgpmessage/BgpHeader.msg:75</tt> by nedtool.
 * <pre>
 * //
 * // Represents a BGPv4 KEEPALIVE message.
 * //
 * // KEEPALIVE messages are exchanged as often as necessary between systems
 * // to avoid exceeding the BGP Hold Timer (constant defined in BgpOpen).
 * //
 * class BgpKeepAliveMessage extends BgpHeader
 * {
 *     type = BGP_KEEPALIVE;
 * }
 * </pre>
 */
class INET_API BgpKeepAliveMessage : public ::inet::bgp::BgpHeader
{
  protected:

  private:
    void copy(const BgpKeepAliveMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const BgpKeepAliveMessage&);

  public:
    BgpKeepAliveMessage();
    BgpKeepAliveMessage(const BgpKeepAliveMessage& other);
    virtual ~BgpKeepAliveMessage();
    BgpKeepAliveMessage& operator=(const BgpKeepAliveMessage& other);
    virtual BgpKeepAliveMessage *dup() const override {return new BgpKeepAliveMessage(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const BgpKeepAliveMessage& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, BgpKeepAliveMessage& obj) {obj.parsimUnpack(b);}

/**
 * Struct generated from inet/routing/bgpv4/bgpmessage/BgpHeader.msg:80 by nedtool.
 */
struct INET_API BgpParameterValues
{
    BgpParameterValues();
    short authCode;
    long authenticationData;
};

// helpers for local use
void INET_API __doPacking(omnetpp::cCommBuffer *b, const BgpParameterValues& a);
void INET_API __doUnpacking(omnetpp::cCommBuffer *b, BgpParameterValues& a);

inline void doParsimPacking(omnetpp::cCommBuffer *b, const BgpParameterValues& obj) { __doPacking(b, obj); }
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, BgpParameterValues& obj) { __doUnpacking(b, obj); }

/**
 * Struct generated from inet/routing/bgpv4/bgpmessage/BgpHeader.msg:86 by nedtool.
 */
struct INET_API BgpOptionalParameters
{
    BgpOptionalParameters();
    short parameterType;
    unsigned short parameterLength;
    BgpParameterValues parameterValues;
};

// helpers for local use
void INET_API __doPacking(omnetpp::cCommBuffer *b, const BgpOptionalParameters& a);
void INET_API __doUnpacking(omnetpp::cCommBuffer *b, BgpOptionalParameters& a);

inline void doParsimPacking(omnetpp::cCommBuffer *b, const BgpOptionalParameters& obj) { __doPacking(b, obj); }
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, BgpOptionalParameters& obj) { __doUnpacking(b, obj); }

/**
 * Class generated from <tt>inet/routing/bgpv4/bgpmessage/BgpHeader.msg:110</tt> by nedtool.
 * <pre>
 * //
 * // Represents a BGPv4 OPEN message.
 * //
 * // Fields modelled:
 * // - Version: 1 octet (BGP version)
 * // - My Autonomous system: 2 octets  (AS of the sender)
 * // - Hold Time: 2 octets (nbr de secondes que l'emetteur propose pour le compteur de renetue)
 * // - BGP Identifier: 4 octets
 * // - Optional Param Length: 1 octet (if = 0, no optional parameters)
 * // - Optional Parameters:
 * //    - Parameter Type
 * //    - Parameter Length
 * //    - Parameter Values (variable size)
 * //    - Auth code
 * //    - Authentication Data
 * //
 * class BgpOpenMessage extends BgpHeader
 * {
 *     type = BGP_OPEN;
 *     chunkLength = BGP_HEADER_OCTETS + BGP_OPEN_OCTETS;
 * 
 *     char version = 4;
 *     unsigned short myAS;
 *     simtime_t holdTime;
 *     Ipv4Address BGPIdentifier;
 *     BgpOptionalParameters optionalParameters[];
 * }
 * </pre>
 */
class INET_API BgpOpenMessage : public ::inet::bgp::BgpHeader
{
  protected:
    char version = 4;
    unsigned short myAS = 0;
    omnetpp::simtime_t holdTime = SIMTIME_ZERO;
    Ipv4Address BGPIdentifier;
    BgpOptionalParameters *optionalParameters = nullptr;
    size_t optionalParameters_arraysize = 0;

  private:
    void copy(const BgpOpenMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const BgpOpenMessage&);

  public:
    BgpOpenMessage();
    BgpOpenMessage(const BgpOpenMessage& other);
    virtual ~BgpOpenMessage();
    BgpOpenMessage& operator=(const BgpOpenMessage& other);
    virtual BgpOpenMessage *dup() const override {return new BgpOpenMessage(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual char getVersion() const;
    virtual void setVersion(char version);
    virtual unsigned short getMyAS() const;
    virtual void setMyAS(unsigned short myAS);
    virtual omnetpp::simtime_t getHoldTime() const;
    virtual void setHoldTime(omnetpp::simtime_t holdTime);
    virtual const Ipv4Address& getBGPIdentifier() const;
    virtual Ipv4Address& getBGPIdentifierForUpdate() { handleChange();return const_cast<Ipv4Address&>(const_cast<BgpOpenMessage*>(this)->getBGPIdentifier());}
    virtual void setBGPIdentifier(const Ipv4Address& BGPIdentifier);
    virtual void setOptionalParametersArraySize(size_t size);
    virtual size_t getOptionalParametersArraySize() const;
    virtual const BgpOptionalParameters& getOptionalParameters(size_t k) const;
    virtual BgpOptionalParameters& getOptionalParametersForUpdate(size_t k) { handleChange();return const_cast<BgpOptionalParameters&>(const_cast<BgpOpenMessage*>(this)->getOptionalParameters(k));}
    virtual void setOptionalParameters(size_t k, const BgpOptionalParameters& optionalParameters);
    virtual void insertOptionalParameters(const BgpOptionalParameters& optionalParameters);
    virtual void insertOptionalParameters(size_t k, const BgpOptionalParameters& optionalParameters);
    virtual void eraseOptionalParameters(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const BgpOpenMessage& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, BgpOpenMessage& obj) {obj.parsimUnpack(b);}

/**
 * Enum generated from <tt>inet/routing/bgpv4/bgpmessage/BgpHeader.msg:122</tt> by nedtool.
 * <pre>
 * enum BgpUpdateAttributeTypeCode
 * {
 *     ORIGIN = 1;
 *     AS_PATH = 2;
 *     NEXT_HOP = 3;
 *     LOCAL_PREF = 5;
 *     ATOMIC_AGGREGATE = 6;
 * }
 * </pre>
 */
enum BgpUpdateAttributeTypeCode {
    ORIGIN = 1,
    AS_PATH = 2,
    NEXT_HOP = 3,
    LOCAL_PREF = 5,
    ATOMIC_AGGREGATE = 6
};

/**
 * Struct generated from inet/routing/bgpv4/bgpmessage/BgpHeader.msg:131 by nedtool.
 */
struct INET_API BgpUpdateAttributeFlags
{
    BgpUpdateAttributeFlags();
    bool optionalBit;
    bool transitiveBit;
    bool partialBit;
    bool estendedLengthBit;
};

// helpers for local use
void INET_API __doPacking(omnetpp::cCommBuffer *b, const BgpUpdateAttributeFlags& a);
void INET_API __doUnpacking(omnetpp::cCommBuffer *b, BgpUpdateAttributeFlags& a);

inline void doParsimPacking(omnetpp::cCommBuffer *b, const BgpUpdateAttributeFlags& obj) { __doPacking(b, obj); }
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, BgpUpdateAttributeFlags& obj) { __doUnpacking(b, obj); }

/**
 * Struct generated from inet/routing/bgpv4/bgpmessage/BgpHeader.msg:139 by nedtool.
 */
struct INET_API BgpUpdateAttributeType
{
    BgpUpdateAttributeType();
    BgpUpdateAttributeFlags flags;
    inet::bgp::BgpUpdateAttributeTypeCode typeCode;
};

// helpers for local use
void INET_API __doPacking(omnetpp::cCommBuffer *b, const BgpUpdateAttributeType& a);
void INET_API __doUnpacking(omnetpp::cCommBuffer *b, BgpUpdateAttributeType& a);

inline void doParsimPacking(omnetpp::cCommBuffer *b, const BgpUpdateAttributeType& obj) { __doPacking(b, obj); }
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, BgpUpdateAttributeType& obj) { __doUnpacking(b, obj); }

/**
 * Class generated from <tt>inet/routing/bgpv4/bgpmessage/BgpHeader.msg:145</tt> by nedtool.
 * <pre>
 * class BgpUpdatePathAttributes extends cObject
 * {
 *     BgpUpdateAttributeType type; // 2 octets
 *     unsigned short length; // 2 octets
 * }
 * </pre>
 */
class INET_API BgpUpdatePathAttributes : public ::omnetpp::cObject
{
  protected:
    BgpUpdateAttributeType type;
    unsigned short length = 0;

  private:
    void copy(const BgpUpdatePathAttributes& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const BgpUpdatePathAttributes&);

  public:
    BgpUpdatePathAttributes();
    BgpUpdatePathAttributes(const BgpUpdatePathAttributes& other);
    virtual ~BgpUpdatePathAttributes();
    BgpUpdatePathAttributes& operator=(const BgpUpdatePathAttributes& other);
    virtual BgpUpdatePathAttributes *dup() const override {return new BgpUpdatePathAttributes(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const BgpUpdateAttributeType& getType() const;
    virtual BgpUpdateAttributeType& getTypeForUpdate() { return const_cast<BgpUpdateAttributeType&>(const_cast<BgpUpdatePathAttributes*>(this)->getType());}
    virtual void setType(const BgpUpdateAttributeType& type);
    virtual unsigned short getLength() const;
    virtual void setLength(unsigned short length);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const BgpUpdatePathAttributes& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, BgpUpdatePathAttributes& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/routing/bgpv4/bgpmessage/BgpHeader.msg:152</tt> by nedtool.
 * <pre>
 * // ORIGIN (RFC4271 Section 4.3, Type code 1):
 * class BgpUpdatePathAttributesOrigin extends BgpUpdatePathAttributes
 * {
 *     BgpSessionType value;
 * }
 * </pre>
 */
class INET_API BgpUpdatePathAttributesOrigin : public ::inet::bgp::BgpUpdatePathAttributes
{
  protected:
    inet::bgp::BgpSessionType value = static_cast<inet::bgp::BgpSessionType>(-1);

  private:
    void copy(const BgpUpdatePathAttributesOrigin& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const BgpUpdatePathAttributesOrigin&);

  public:
    BgpUpdatePathAttributesOrigin();
    BgpUpdatePathAttributesOrigin(const BgpUpdatePathAttributesOrigin& other);
    virtual ~BgpUpdatePathAttributesOrigin();
    BgpUpdatePathAttributesOrigin& operator=(const BgpUpdatePathAttributesOrigin& other);
    virtual BgpUpdatePathAttributesOrigin *dup() const override {return new BgpUpdatePathAttributesOrigin(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual inet::bgp::BgpSessionType getValue() const;
    virtual void setValue(inet::bgp::BgpSessionType value);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const BgpUpdatePathAttributesOrigin& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, BgpUpdatePathAttributesOrigin& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/routing/bgpv4/bgpmessage/BgpHeader.msg:158</tt> by nedtool.
 * <pre>
 * // AS_PATH (RFC4271 Section 4.3, Type code 2):
 * class BgpUpdatePathAttributesAsPath extends BgpUpdatePathAttributes
 * {
 *     BgpAsPathSegment value[];
 * }
 * </pre>
 */
class INET_API BgpUpdatePathAttributesAsPath : public ::inet::bgp::BgpUpdatePathAttributes
{
  protected:
    BgpAsPathSegment *value = nullptr;
    size_t value_arraysize = 0;

  private:
    void copy(const BgpUpdatePathAttributesAsPath& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const BgpUpdatePathAttributesAsPath&);

  public:
    BgpUpdatePathAttributesAsPath();
    BgpUpdatePathAttributesAsPath(const BgpUpdatePathAttributesAsPath& other);
    virtual ~BgpUpdatePathAttributesAsPath();
    BgpUpdatePathAttributesAsPath& operator=(const BgpUpdatePathAttributesAsPath& other);
    virtual BgpUpdatePathAttributesAsPath *dup() const override {return new BgpUpdatePathAttributesAsPath(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual void setValueArraySize(size_t size);
    virtual size_t getValueArraySize() const;
    virtual const BgpAsPathSegment& getValue(size_t k) const;
    virtual BgpAsPathSegment& getValueForUpdate(size_t k) { return const_cast<BgpAsPathSegment&>(const_cast<BgpUpdatePathAttributesAsPath*>(this)->getValue(k));}
    virtual void setValue(size_t k, const BgpAsPathSegment& value);
    virtual void insertValue(const BgpAsPathSegment& value);
    virtual void insertValue(size_t k, const BgpAsPathSegment& value);
    virtual void eraseValue(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const BgpUpdatePathAttributesAsPath& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, BgpUpdatePathAttributesAsPath& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/routing/bgpv4/bgpmessage/BgpHeader.msg:164</tt> by nedtool.
 * <pre>
 * //NEXT_HOP (RFC4271 Section 4.3, Type code 3):
 * class BgpUpdatePathAttributesNextHop extends BgpUpdatePathAttributes
 * {
 *     Ipv4Address value;
 * }
 * </pre>
 */
class INET_API BgpUpdatePathAttributesNextHop : public ::inet::bgp::BgpUpdatePathAttributes
{
  protected:
    Ipv4Address value;

  private:
    void copy(const BgpUpdatePathAttributesNextHop& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const BgpUpdatePathAttributesNextHop&);

  public:
    BgpUpdatePathAttributesNextHop();
    BgpUpdatePathAttributesNextHop(const BgpUpdatePathAttributesNextHop& other);
    virtual ~BgpUpdatePathAttributesNextHop();
    BgpUpdatePathAttributesNextHop& operator=(const BgpUpdatePathAttributesNextHop& other);
    virtual BgpUpdatePathAttributesNextHop *dup() const override {return new BgpUpdatePathAttributesNextHop(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const Ipv4Address& getValue() const;
    virtual Ipv4Address& getValueForUpdate() { return const_cast<Ipv4Address&>(const_cast<BgpUpdatePathAttributesNextHop*>(this)->getValue());}
    virtual void setValue(const Ipv4Address& value);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const BgpUpdatePathAttributesNextHop& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, BgpUpdatePathAttributesNextHop& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/routing/bgpv4/bgpmessage/BgpHeader.msg:170</tt> by nedtool.
 * <pre>
 * //LOCAL_PREF (RFC4271 Section 4.3, Type code 5):
 * class BgpUpdatePathAttributesLocalPref extends BgpUpdatePathAttributes
 * {
 *     unsigned int value;
 * }
 * </pre>
 */
class INET_API BgpUpdatePathAttributesLocalPref : public ::inet::bgp::BgpUpdatePathAttributes
{
  protected:
    unsigned int value = 0;

  private:
    void copy(const BgpUpdatePathAttributesLocalPref& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const BgpUpdatePathAttributesLocalPref&);

  public:
    BgpUpdatePathAttributesLocalPref();
    BgpUpdatePathAttributesLocalPref(const BgpUpdatePathAttributesLocalPref& other);
    virtual ~BgpUpdatePathAttributesLocalPref();
    BgpUpdatePathAttributesLocalPref& operator=(const BgpUpdatePathAttributesLocalPref& other);
    virtual BgpUpdatePathAttributesLocalPref *dup() const override {return new BgpUpdatePathAttributesLocalPref(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual unsigned int getValue() const;
    virtual void setValue(unsigned int value);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const BgpUpdatePathAttributesLocalPref& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, BgpUpdatePathAttributesLocalPref& obj) {obj.parsimUnpack(b);}

/**
 * Enum generated from <tt>inet/routing/bgpv4/bgpmessage/BgpHeader.msg:176</tt> by nedtool.
 * <pre>
 * //ATOMIC_AGGREGATE (RFC4271 Section 4.3, Type code 6):
 * enum BgpUpdateAtomicAggregateValues
 * {
 *     NO_SPECIFIC_ROUTE = 0;
 *     SPECIFIC_ROUTE = 1;
 * }
 * </pre>
 */
enum BgpUpdateAtomicAggregateValues {
    NO_SPECIFIC_ROUTE = 0,
    SPECIFIC_ROUTE = 1
};

/**
 * Class generated from <tt>inet/routing/bgpv4/bgpmessage/BgpHeader.msg:182</tt> by nedtool.
 * <pre>
 * class BgpUpdatePathAttributesAtomicAggregate extends BgpUpdatePathAttributes
 * {
 *     BgpUpdateAtomicAggregateValues value;
 * }
 * </pre>
 */
class INET_API BgpUpdatePathAttributesAtomicAggregate : public ::inet::bgp::BgpUpdatePathAttributes
{
  protected:
    inet::bgp::BgpUpdateAtomicAggregateValues value = static_cast<inet::bgp::BgpUpdateAtomicAggregateValues>(-1);

  private:
    void copy(const BgpUpdatePathAttributesAtomicAggregate& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const BgpUpdatePathAttributesAtomicAggregate&);

  public:
    BgpUpdatePathAttributesAtomicAggregate();
    BgpUpdatePathAttributesAtomicAggregate(const BgpUpdatePathAttributesAtomicAggregate& other);
    virtual ~BgpUpdatePathAttributesAtomicAggregate();
    BgpUpdatePathAttributesAtomicAggregate& operator=(const BgpUpdatePathAttributesAtomicAggregate& other);
    virtual BgpUpdatePathAttributesAtomicAggregate *dup() const override {return new BgpUpdatePathAttributesAtomicAggregate(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual inet::bgp::BgpUpdateAtomicAggregateValues getValue() const;
    virtual void setValue(inet::bgp::BgpUpdateAtomicAggregateValues value);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const BgpUpdatePathAttributesAtomicAggregate& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, BgpUpdatePathAttributesAtomicAggregate& obj) {obj.parsimUnpack(b);}

/**
 * Struct generated from inet/routing/bgpv4/bgpmessage/BgpHeader.msg:187 by nedtool.
 */
struct INET_API BgpUpdateWithdrawnRoutes
{
    BgpUpdateWithdrawnRoutes();
    unsigned char length;
    Ipv4Address prefix;
};

// helpers for local use
void INET_API __doPacking(omnetpp::cCommBuffer *b, const BgpUpdateWithdrawnRoutes& a);
void INET_API __doUnpacking(omnetpp::cCommBuffer *b, BgpUpdateWithdrawnRoutes& a);

inline void doParsimPacking(omnetpp::cCommBuffer *b, const BgpUpdateWithdrawnRoutes& obj) { __doPacking(b, obj); }
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, BgpUpdateWithdrawnRoutes& obj) { __doUnpacking(b, obj); }

/**
 * Struct generated from inet/routing/bgpv4/bgpmessage/BgpHeader.msg:193 by nedtool.
 */
struct INET_API BgpUpdateNlri
{
    BgpUpdateNlri();
    unsigned char length;
    Ipv4Address prefix;
};

// helpers for local use
void INET_API __doPacking(omnetpp::cCommBuffer *b, const BgpUpdateNlri& a);
void INET_API __doUnpacking(omnetpp::cCommBuffer *b, BgpUpdateNlri& a);

inline void doParsimPacking(omnetpp::cCommBuffer *b, const BgpUpdateNlri& obj) { __doPacking(b, obj); }
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, BgpUpdateNlri& obj) { __doUnpacking(b, obj); }

/**
 * Class generated from <tt>inet/routing/bgpv4/bgpmessage/BgpHeader.msg:203</tt> by nedtool.
 * <pre>
 * //
 * // Represents the list of path attributes in a BGPv4 UPDATE message.
 * // See RFC 4271, section 4.3
 * //
 * class BgpUpdatePathAttributeList extends cObject
 * {
 *     BgpUpdatePathAttributesOrigin origin; // mandatory attribute
 *     BgpUpdatePathAttributesAsPath asPath[]; // mandatory attribute
 *     BgpUpdatePathAttributesNextHop nextHop; // mandatory attribute
 *     BgpUpdatePathAttributesLocalPref localPref[]; // optional attribute
 *     BgpUpdatePathAttributesAtomicAggregate atomicAggregate[]; // optional attribute
 * }
 * </pre>
 */
class INET_API BgpUpdatePathAttributeList : public ::omnetpp::cObject
{
  protected:
    BgpUpdatePathAttributesOrigin origin;
    BgpUpdatePathAttributesAsPath *asPath = nullptr;
    size_t asPath_arraysize = 0;
    BgpUpdatePathAttributesNextHop nextHop;
    BgpUpdatePathAttributesLocalPref *localPref = nullptr;
    size_t localPref_arraysize = 0;
    BgpUpdatePathAttributesAtomicAggregate *atomicAggregate = nullptr;
    size_t atomicAggregate_arraysize = 0;

  private:
    void copy(const BgpUpdatePathAttributeList& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const BgpUpdatePathAttributeList&);

  public:
    BgpUpdatePathAttributeList();
    BgpUpdatePathAttributeList(const BgpUpdatePathAttributeList& other);
    virtual ~BgpUpdatePathAttributeList();
    BgpUpdatePathAttributeList& operator=(const BgpUpdatePathAttributeList& other);
    virtual BgpUpdatePathAttributeList *dup() const override {return new BgpUpdatePathAttributeList(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const BgpUpdatePathAttributesOrigin& getOrigin() const;
    virtual BgpUpdatePathAttributesOrigin& getOriginForUpdate() { return const_cast<BgpUpdatePathAttributesOrigin&>(const_cast<BgpUpdatePathAttributeList*>(this)->getOrigin());}
    virtual void setOrigin(const BgpUpdatePathAttributesOrigin& origin);
    virtual void setAsPathArraySize(size_t size);
    virtual size_t getAsPathArraySize() const;
    virtual const BgpUpdatePathAttributesAsPath& getAsPath(size_t k) const;
    virtual BgpUpdatePathAttributesAsPath& getAsPathForUpdate(size_t k) { return const_cast<BgpUpdatePathAttributesAsPath&>(const_cast<BgpUpdatePathAttributeList*>(this)->getAsPath(k));}
    virtual void setAsPath(size_t k, const BgpUpdatePathAttributesAsPath& asPath);
    virtual void insertAsPath(const BgpUpdatePathAttributesAsPath& asPath);
    virtual void insertAsPath(size_t k, const BgpUpdatePathAttributesAsPath& asPath);
    virtual void eraseAsPath(size_t k);
    virtual const BgpUpdatePathAttributesNextHop& getNextHop() const;
    virtual BgpUpdatePathAttributesNextHop& getNextHopForUpdate() { return const_cast<BgpUpdatePathAttributesNextHop&>(const_cast<BgpUpdatePathAttributeList*>(this)->getNextHop());}
    virtual void setNextHop(const BgpUpdatePathAttributesNextHop& nextHop);
    virtual void setLocalPrefArraySize(size_t size);
    virtual size_t getLocalPrefArraySize() const;
    virtual const BgpUpdatePathAttributesLocalPref& getLocalPref(size_t k) const;
    virtual BgpUpdatePathAttributesLocalPref& getLocalPrefForUpdate(size_t k) { return const_cast<BgpUpdatePathAttributesLocalPref&>(const_cast<BgpUpdatePathAttributeList*>(this)->getLocalPref(k));}
    virtual void setLocalPref(size_t k, const BgpUpdatePathAttributesLocalPref& localPref);
    virtual void insertLocalPref(const BgpUpdatePathAttributesLocalPref& localPref);
    virtual void insertLocalPref(size_t k, const BgpUpdatePathAttributesLocalPref& localPref);
    virtual void eraseLocalPref(size_t k);
    virtual void setAtomicAggregateArraySize(size_t size);
    virtual size_t getAtomicAggregateArraySize() const;
    virtual const BgpUpdatePathAttributesAtomicAggregate& getAtomicAggregate(size_t k) const;
    virtual BgpUpdatePathAttributesAtomicAggregate& getAtomicAggregateForUpdate(size_t k) { return const_cast<BgpUpdatePathAttributesAtomicAggregate&>(const_cast<BgpUpdatePathAttributeList*>(this)->getAtomicAggregate(k));}
    virtual void setAtomicAggregate(size_t k, const BgpUpdatePathAttributesAtomicAggregate& atomicAggregate);
    virtual void insertAtomicAggregate(const BgpUpdatePathAttributesAtomicAggregate& atomicAggregate);
    virtual void insertAtomicAggregate(size_t k, const BgpUpdatePathAttributesAtomicAggregate& atomicAggregate);
    virtual void eraseAtomicAggregate(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const BgpUpdatePathAttributeList& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, BgpUpdatePathAttributeList& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/routing/bgpv4/bgpmessage/BgpHeader.msg:227</tt> by nedtool.
 * <pre>
 * //
 * // Represents a BGPv4 UPDATE message.
 * //
 * // BGP UPDATE fields modelled:
 * //   - Unfeasible routes length: 2 octets (number of withdrawn routes)
 * //   - Withdrawn routes : variable size  (list of IP prefixes of unfeasible routes)
 * //   - Total Path Attributes Length: 1 octet (if = 0, no Path Attributes)
 * //   - Path Attributes:
 * //     - Attribute Type (2 octets)
 * //     - Attribute Length
 * //     - Attribute Values (variable size)
 * // - Network Layer Reachability Information: (variable size)
 * //    - Length : 1 octet
 * //    - prefix : variable size (contains the IP prefix; Ipv4: 4 octets)
 * //
 * class BgpUpdateMessage extends BgpHeader
 * {
 *     \@customize;     // update chunkLength when changed   //FIXME setNLRI() always increment length with 5 bytes
 *     type = BGP_UPDATE;
 *     chunkLength = BGP_HEADER_OCTETS + BGP_EMPTY_UPDATE_OCTETS;
 * 
 *     BgpUpdateWithdrawnRoutes withdrawnRoutes[];
 *     BgpUpdatePathAttributeList pathAttributeList[]; // optional field (size is either 0 or 1)
 *     BgpUpdateNlri NLRI;
 * }
 * </pre>
 *
 * BgpUpdateMessage_Base is only useful if it gets subclassed, and BgpUpdateMessage is derived from it.
 * The minimum code to be written for BgpUpdateMessage is the following:
 *
 * <pre>
 * class INET_API BgpUpdateMessage : public BgpUpdateMessage_Base
 * {
 *   private:
 *     void copy(const BgpUpdateMessage& other) { ... }

 *   public:
 *     BgpUpdateMessage() : BgpUpdateMessage_Base() {}
 *     BgpUpdateMessage(const BgpUpdateMessage& other) : BgpUpdateMessage_Base(other) {copy(other);}
 *     BgpUpdateMessage& operator=(const BgpUpdateMessage& other) {if (this==&other) return *this; BgpUpdateMessage_Base::operator=(other); copy(other); return *this;}
 *     virtual BgpUpdateMessage *dup() const override {return new BgpUpdateMessage(*this);}
 *     // ADD CODE HERE to redefine and implement pure virtual functions from BgpUpdateMessage_Base
 * };
 * </pre>
 *
 * The following should go into a .cc (.cpp) file:
 *
 * <pre>
 * Register_Class(BgpUpdateMessage)
 * </pre>
 */
class INET_API BgpUpdateMessage_Base : public ::inet::bgp::BgpHeader
{
  protected:
    BgpUpdateWithdrawnRoutes *withdrawnRoutes = nullptr;
    size_t withdrawnRoutes_arraysize = 0;
    BgpUpdatePathAttributeList *pathAttributeList = nullptr;
    size_t pathAttributeList_arraysize = 0;
    BgpUpdateNlri NLRI;

  private:
    void copy(const BgpUpdateMessage_Base& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const BgpUpdateMessage_Base&);
    // make constructors protected to avoid instantiation
    BgpUpdateMessage_Base();
    BgpUpdateMessage_Base(const BgpUpdateMessage_Base& other);
    // make assignment operator protected to force the user override it
    BgpUpdateMessage_Base& operator=(const BgpUpdateMessage_Base& other);

  public:
    virtual ~BgpUpdateMessage_Base();
    virtual BgpUpdateMessage_Base *dup() const override {throw omnetpp::cRuntimeError("You forgot to manually add a dup() function to class BgpUpdateMessage");}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual void setWithdrawnRoutesArraySize(size_t size);
    virtual size_t getWithdrawnRoutesArraySize() const;
    virtual const BgpUpdateWithdrawnRoutes& getWithdrawnRoutes(size_t k) const;
    virtual BgpUpdateWithdrawnRoutes& getWithdrawnRoutesForUpdate(size_t k) { handleChange();return const_cast<BgpUpdateWithdrawnRoutes&>(const_cast<BgpUpdateMessage_Base*>(this)->getWithdrawnRoutes(k));}
    virtual void setWithdrawnRoutes(size_t k, const BgpUpdateWithdrawnRoutes& withdrawnRoutes);
    virtual void insertWithdrawnRoutes(const BgpUpdateWithdrawnRoutes& withdrawnRoutes);
    virtual void insertWithdrawnRoutes(size_t k, const BgpUpdateWithdrawnRoutes& withdrawnRoutes);
    virtual void eraseWithdrawnRoutes(size_t k);
    virtual void setPathAttributeListArraySize(size_t size);
    virtual size_t getPathAttributeListArraySize() const;
    virtual const BgpUpdatePathAttributeList& getPathAttributeList(size_t k) const;
    virtual BgpUpdatePathAttributeList& getPathAttributeListForUpdate(size_t k) { handleChange();return const_cast<BgpUpdatePathAttributeList&>(const_cast<BgpUpdateMessage_Base*>(this)->getPathAttributeList(k));}
    virtual void setPathAttributeList(size_t k, const BgpUpdatePathAttributeList& pathAttributeList);
    virtual void insertPathAttributeList(const BgpUpdatePathAttributeList& pathAttributeList);
    virtual void insertPathAttributeList(size_t k, const BgpUpdatePathAttributeList& pathAttributeList);
    virtual void erasePathAttributeList(size_t k);
    virtual const BgpUpdateNlri& getNLRI() const;
    virtual BgpUpdateNlri& getNLRIForUpdate() { handleChange();return const_cast<BgpUpdateNlri&>(const_cast<BgpUpdateMessage_Base*>(this)->getNLRI());}
    virtual void setNLRI(const BgpUpdateNlri& NLRI);
};

} // namespace bgp
} // namespace inet

#endif // ifndef __INET__BGP_BGPHEADER_M_H

