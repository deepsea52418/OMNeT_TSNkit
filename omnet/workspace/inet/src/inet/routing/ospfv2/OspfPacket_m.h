//
// Generated file, do not edit! Created by nedtool 5.6 from inet/routing/ospfv2/OspfPacket.msg.
//

#ifndef __INET__OSPF_OSPFPACKET_M_H
#define __INET__OSPF_OSPFPACKET_M_H

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0506
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif

// dll export symbol
#ifndef INET_API
#  if defined(INET_EXPORT)
#    define INET_API  OPP_DLLEXPORT
#  elif defined(INET_IMPORT)
#    define INET_API  OPP_DLLIMPORT
#  else
#    define INET_API
#  endif
#endif


namespace inet {
namespace ospf {

struct OspfOptions;
class OspfPacket;
class OspfHelloPacket;
class OspfLsaHeader;
class OspfLsa;
struct TosData;
class Link;
class OspfRouterLsa;
class OspfNetworkLsa;
class OspfSummaryLsa;
struct ExternalTosInfo;
class OspfAsExternalLsaContents;
class OspfAsExternalLsa;
struct OspfDdOptions;
class OspfDatabaseDescriptionPacket;
struct LsaRequest;
class OspfLinkStateRequestPacket;
class OspfLinkStateUpdatePacket;
class OspfLinkStateAcknowledgementPacket;
} // namespace ospf
} // namespace inet

#include "inet/common/INETDefs_m.h" // import inet.common.INETDefs

#include "inet/common/packet/chunk/Chunk_m.h" // import inet.common.packet.chunk.Chunk

#include "inet/networklayer/contract/ipv4/Ipv4Address_m.h" // import inet.networklayer.contract.ipv4.Ipv4Address

#include "inet/transportlayer/common/CrcMode_m.h" // import inet.transportlayer.common.CrcMode


namespace inet {
namespace ospf {

/**
 * Enum generated from <tt>inet/routing/ospfv2/OspfPacket.msg:26</tt> by nedtool.
 * <pre>
 * enum OspfPacketType
 * {
 *     HELLO_PACKET = 1;
 *     DATABASE_DESCRIPTION_PACKET = 2;
 *     LINKSTATE_REQUEST_PACKET = 3;
 *     LINKSTATE_UPDATE_PACKET = 4;
 *     LINKSTATE_ACKNOWLEDGEMENT_PACKET = 5;
 * }
 * </pre>
 */
enum OspfPacketType {
    HELLO_PACKET = 1,
    DATABASE_DESCRIPTION_PACKET = 2,
    LINKSTATE_REQUEST_PACKET = 3,
    LINKSTATE_UPDATE_PACKET = 4,
    LINKSTATE_ACKNOWLEDGEMENT_PACKET = 5
};

/**
 * Struct generated from inet/routing/ospfv2/OspfPacket.msg:36 by nedtool.
 */
struct INET_API OspfOptions
{
    OspfOptions();
    bool unused_1;
    bool E_ExternalRoutingCapability;
    bool MC_MulticastForwarding;
    bool NP_Type7LSA;
    bool EA_ForwardExternalLSAs;
    bool DC_DemandCircuits;
    bool unused_2;
    bool unused_3;
};

// helpers for local use
void INET_API __doPacking(omnetpp::cCommBuffer *b, const OspfOptions& a);
void INET_API __doUnpacking(omnetpp::cCommBuffer *b, OspfOptions& a);

inline void doParsimPacking(omnetpp::cCommBuffer *b, const OspfOptions& obj) { __doPacking(b, obj); }
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, OspfOptions& obj) { __doUnpacking(b, obj); }

/**
 * Class generated from <tt>inet/routing/ospfv2/OspfPacket.msg:51</tt> by nedtool.
 * <pre>
 * //
 * // Represents an OSPF packet header
 * //
 * class OspfPacket extends FieldsChunk
 * {
 *     char version = 2;
 *     OspfPacketType type = HELLO_PACKET;
 * 
 *     Ipv4Address routerID;
 *     Ipv4Address areaID;
 * 
 *     uint16_t crc = 0;
 *     CrcMode crcMode = CRC_MODE_UNDEFINED;
 * 
 *     short authenticationType = 0;
 *     char authentication[8];
 * }
 * </pre>
 */
class INET_API OspfPacket : public ::inet::FieldsChunk
{
  protected:
    char version = 2;
    inet::ospf::OspfPacketType type = HELLO_PACKET;
    Ipv4Address routerID;
    Ipv4Address areaID;
    uint16_t crc = 0;
    inet::CrcMode crcMode = CRC_MODE_UNDEFINED;
    short authenticationType = 0;
    char authentication[8] = {0};

  private:
    void copy(const OspfPacket& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const OspfPacket&);

  public:
    OspfPacket();
    OspfPacket(const OspfPacket& other);
    virtual ~OspfPacket();
    OspfPacket& operator=(const OspfPacket& other);
    virtual OspfPacket *dup() const override {return new OspfPacket(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual char getVersion() const;
    virtual void setVersion(char version);
    virtual inet::ospf::OspfPacketType getType() const;
    virtual void setType(inet::ospf::OspfPacketType type);
    virtual const Ipv4Address& getRouterID() const;
    virtual Ipv4Address& getRouterIDForUpdate() { handleChange();return const_cast<Ipv4Address&>(const_cast<OspfPacket*>(this)->getRouterID());}
    virtual void setRouterID(const Ipv4Address& routerID);
    virtual const Ipv4Address& getAreaID() const;
    virtual Ipv4Address& getAreaIDForUpdate() { handleChange();return const_cast<Ipv4Address&>(const_cast<OspfPacket*>(this)->getAreaID());}
    virtual void setAreaID(const Ipv4Address& areaID);
    virtual uint16_t getCrc() const;
    virtual void setCrc(uint16_t crc);
    virtual inet::CrcMode getCrcMode() const;
    virtual void setCrcMode(inet::CrcMode crcMode);
    virtual short getAuthenticationType() const;
    virtual void setAuthenticationType(short authenticationType);
    virtual size_t getAuthenticationArraySize() const;
    virtual char getAuthentication(size_t k) const;
    virtual void setAuthentication(size_t k, char authentication);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const OspfPacket& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, OspfPacket& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/routing/ospfv2/OspfPacket.msg:69</tt> by nedtool.
 * <pre>
 * //
 * // Represents an OSPF Hello packet
 * //
 * class OspfHelloPacket extends OspfPacket
 * {
 *     Ipv4Address networkMask;
 * 
 *     short helloInterval = 5;
 * 
 *     OspfOptions options;
 * 
 *     char routerPriority = 0;
 *     long routerDeadInterval = 0;
 * 
 *     Ipv4Address designatedRouter;
 *     Ipv4Address backupDesignatedRouter;
 *     Ipv4Address neighbor[];
 * }
 * </pre>
 */
class INET_API OspfHelloPacket : public ::inet::ospf::OspfPacket
{
  protected:
    Ipv4Address networkMask;
    short helloInterval = 5;
    OspfOptions options;
    char routerPriority = 0;
    long routerDeadInterval = 0;
    Ipv4Address designatedRouter;
    Ipv4Address backupDesignatedRouter;
    Ipv4Address *neighbor = nullptr;
    size_t neighbor_arraysize = 0;

  private:
    void copy(const OspfHelloPacket& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const OspfHelloPacket&);

  public:
    OspfHelloPacket();
    OspfHelloPacket(const OspfHelloPacket& other);
    virtual ~OspfHelloPacket();
    OspfHelloPacket& operator=(const OspfHelloPacket& other);
    virtual OspfHelloPacket *dup() const override {return new OspfHelloPacket(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const Ipv4Address& getNetworkMask() const;
    virtual Ipv4Address& getNetworkMaskForUpdate() { handleChange();return const_cast<Ipv4Address&>(const_cast<OspfHelloPacket*>(this)->getNetworkMask());}
    virtual void setNetworkMask(const Ipv4Address& networkMask);
    virtual short getHelloInterval() const;
    virtual void setHelloInterval(short helloInterval);
    virtual const OspfOptions& getOptions() const;
    virtual OspfOptions& getOptionsForUpdate() { handleChange();return const_cast<OspfOptions&>(const_cast<OspfHelloPacket*>(this)->getOptions());}
    virtual void setOptions(const OspfOptions& options);
    virtual char getRouterPriority() const;
    virtual void setRouterPriority(char routerPriority);
    virtual long getRouterDeadInterval() const;
    virtual void setRouterDeadInterval(long routerDeadInterval);
    virtual const Ipv4Address& getDesignatedRouter() const;
    virtual Ipv4Address& getDesignatedRouterForUpdate() { handleChange();return const_cast<Ipv4Address&>(const_cast<OspfHelloPacket*>(this)->getDesignatedRouter());}
    virtual void setDesignatedRouter(const Ipv4Address& designatedRouter);
    virtual const Ipv4Address& getBackupDesignatedRouter() const;
    virtual Ipv4Address& getBackupDesignatedRouterForUpdate() { handleChange();return const_cast<Ipv4Address&>(const_cast<OspfHelloPacket*>(this)->getBackupDesignatedRouter());}
    virtual void setBackupDesignatedRouter(const Ipv4Address& backupDesignatedRouter);
    virtual void setNeighborArraySize(size_t size);
    virtual size_t getNeighborArraySize() const;
    virtual const Ipv4Address& getNeighbor(size_t k) const;
    virtual Ipv4Address& getNeighborForUpdate(size_t k) { handleChange();return const_cast<Ipv4Address&>(const_cast<OspfHelloPacket*>(this)->getNeighbor(k));}
    virtual void setNeighbor(size_t k, const Ipv4Address& neighbor);
    virtual void insertNeighbor(const Ipv4Address& neighbor);
    virtual void insertNeighbor(size_t k, const Ipv4Address& neighbor);
    virtual void eraseNeighbor(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const OspfHelloPacket& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, OspfHelloPacket& obj) {obj.parsimUnpack(b);}

/**
 * Enum generated from <tt>inet/routing/ospfv2/OspfPacket.msg:86</tt> by nedtool.
 * <pre>
 * enum LsaType
 * {
 *     ROUTERLSA_TYPE = 1;
 *     NETWORKLSA_TYPE = 2;
 *     SUMMARYLSA_NETWORKS_TYPE = 3;
 *     SUMMARYLSA_ASBOUNDARYROUTERS_TYPE = 4;
 *     AS_EXTERNAL_LSA_TYPE = 5;
 * }
 * </pre>
 */
enum LsaType {
    ROUTERLSA_TYPE = 1,
    NETWORKLSA_TYPE = 2,
    SUMMARYLSA_NETWORKS_TYPE = 3,
    SUMMARYLSA_ASBOUNDARYROUTERS_TYPE = 4,
    AS_EXTERNAL_LSA_TYPE = 5
};

/**
 * Class generated from <tt>inet/routing/ospfv2/OspfPacket.msg:98</tt> by nedtool.
 * <pre>
 * //
 * // Represents an OSPF LSA header
 * //
 * class OspfLsaHeader extends cObject
 * {
 *     unsigned short lsAge = 0;
 *     OspfOptions lsOptions;
 *     LsaType lsType = ROUTERLSA_TYPE;
 *     Ipv4Address linkStateID;
 *     Ipv4Address advertisingRouter;
 *     long lsSequenceNumber = 0;
 *     uint16_t lsCrc = 0;
 *     unsigned short lsaLength = 0;
 * }
 * </pre>
 */
class INET_API OspfLsaHeader : public ::omnetpp::cObject
{
  protected:
    unsigned short lsAge = 0;
    OspfOptions lsOptions;
    inet::ospf::LsaType lsType = ROUTERLSA_TYPE;
    Ipv4Address linkStateID;
    Ipv4Address advertisingRouter;
    long lsSequenceNumber = 0;
    uint16_t lsCrc = 0;
    unsigned short lsaLength = 0;

  private:
    void copy(const OspfLsaHeader& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const OspfLsaHeader&);

  public:
    OspfLsaHeader();
    OspfLsaHeader(const OspfLsaHeader& other);
    virtual ~OspfLsaHeader();
    OspfLsaHeader& operator=(const OspfLsaHeader& other);
    virtual OspfLsaHeader *dup() const override {return new OspfLsaHeader(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual unsigned short getLsAge() const;
    virtual void setLsAge(unsigned short lsAge);
    virtual const OspfOptions& getLsOptions() const;
    virtual OspfOptions& getLsOptionsForUpdate() { return const_cast<OspfOptions&>(const_cast<OspfLsaHeader*>(this)->getLsOptions());}
    virtual void setLsOptions(const OspfOptions& lsOptions);
    virtual inet::ospf::LsaType getLsType() const;
    virtual void setLsType(inet::ospf::LsaType lsType);
    virtual const Ipv4Address& getLinkStateID() const;
    virtual Ipv4Address& getLinkStateIDForUpdate() { return const_cast<Ipv4Address&>(const_cast<OspfLsaHeader*>(this)->getLinkStateID());}
    virtual void setLinkStateID(const Ipv4Address& linkStateID);
    virtual const Ipv4Address& getAdvertisingRouter() const;
    virtual Ipv4Address& getAdvertisingRouterForUpdate() { return const_cast<Ipv4Address&>(const_cast<OspfLsaHeader*>(this)->getAdvertisingRouter());}
    virtual void setAdvertisingRouter(const Ipv4Address& advertisingRouter);
    virtual long getLsSequenceNumber() const;
    virtual void setLsSequenceNumber(long lsSequenceNumber);
    virtual uint16_t getLsCrc() const;
    virtual void setLsCrc(uint16_t lsCrc);
    virtual unsigned short getLsaLength() const;
    virtual void setLsaLength(unsigned short lsaLength);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const OspfLsaHeader& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, OspfLsaHeader& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/routing/ospfv2/OspfPacket.msg:113</tt> by nedtool.
 * <pre>
 * //
 * // common ancestor type for all LSAs
 * //
 * class OspfLsa extends cObject
 * {
 *     OspfLsaHeader header;
 * }
 * </pre>
 */
class INET_API OspfLsa : public ::omnetpp::cObject
{
  protected:
    OspfLsaHeader header;

  private:
    void copy(const OspfLsa& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const OspfLsa&);

  public:
    OspfLsa();
    OspfLsa(const OspfLsa& other);
    virtual ~OspfLsa();
    OspfLsa& operator=(const OspfLsa& other);
    virtual OspfLsa *dup() const override {return new OspfLsa(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const OspfLsaHeader& getHeader() const;
    virtual OspfLsaHeader& getHeaderForUpdate() { return const_cast<OspfLsaHeader&>(const_cast<OspfLsa*>(this)->getHeader());}
    virtual void setHeader(const OspfLsaHeader& header);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const OspfLsa& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, OspfLsa& obj) {obj.parsimUnpack(b);}

/**
 * Enum generated from <tt>inet/routing/ospfv2/OspfPacket.msg:118</tt> by nedtool.
 * <pre>
 * enum LinkType
 * {
 *     POINTTOPOINT_LINK = 1;
 *     TRANSIT_LINK = 2;
 *     STUB_LINK = 3;
 *     VIRTUAL_LINK = 4;
 * }
 * </pre>
 */
enum LinkType {
    POINTTOPOINT_LINK = 1,
    TRANSIT_LINK = 2,
    STUB_LINK = 3,
    VIRTUAL_LINK = 4
};

/**
 * Struct generated from inet/routing/ospfv2/OspfPacket.msg:126 by nedtool.
 */
struct INET_API TosData
{
    TosData();
    unsigned char tos;
    unsigned char tosMetric[3];
};

// helpers for local use
void INET_API __doPacking(omnetpp::cCommBuffer *b, const TosData& a);
void INET_API __doUnpacking(omnetpp::cCommBuffer *b, TosData& a);

inline void doParsimPacking(omnetpp::cCommBuffer *b, const TosData& obj) { __doPacking(b, obj); }
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, TosData& obj) { __doUnpacking(b, obj); }

/**
 * Class generated from <tt>inet/routing/ospfv2/OspfPacket.msg:132</tt> by nedtool.
 * <pre>
 * class Link extends cObject
 * {
 *     Ipv4Address linkID;
 *     unsigned long linkData = 0;
 *     LinkType type = POINTTOPOINT_LINK;
 *     unsigned char numberOfTOS = 0;
 *     unsigned long linkCost = 1;
 *     TosData tosData[];
 * }
 * </pre>
 */
class INET_API Link : public ::omnetpp::cObject
{
  protected:
    Ipv4Address linkID;
    unsigned long linkData = 0;
    inet::ospf::LinkType type = POINTTOPOINT_LINK;
    unsigned char numberOfTOS = 0;
    unsigned long linkCost = 1;
    TosData *tosData = nullptr;
    size_t tosData_arraysize = 0;

  private:
    void copy(const Link& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Link&);

  public:
    Link();
    Link(const Link& other);
    virtual ~Link();
    Link& operator=(const Link& other);
    virtual Link *dup() const override {return new Link(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const Ipv4Address& getLinkID() const;
    virtual Ipv4Address& getLinkIDForUpdate() { return const_cast<Ipv4Address&>(const_cast<Link*>(this)->getLinkID());}
    virtual void setLinkID(const Ipv4Address& linkID);
    virtual unsigned long getLinkData() const;
    virtual void setLinkData(unsigned long linkData);
    virtual inet::ospf::LinkType getType() const;
    virtual void setType(inet::ospf::LinkType type);
    virtual unsigned char getNumberOfTOS() const;
    virtual void setNumberOfTOS(unsigned char numberOfTOS);
    virtual unsigned long getLinkCost() const;
    virtual void setLinkCost(unsigned long linkCost);
    virtual void setTosDataArraySize(size_t size);
    virtual size_t getTosDataArraySize() const;
    virtual const TosData& getTosData(size_t k) const;
    virtual TosData& getTosDataForUpdate(size_t k) { return const_cast<TosData&>(const_cast<Link*>(this)->getTosData(k));}
    virtual void setTosData(size_t k, const TosData& tosData);
    virtual void insertTosData(const TosData& tosData);
    virtual void insertTosData(size_t k, const TosData& tosData);
    virtual void eraseTosData(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Link& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Link& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/routing/ospfv2/OspfPacket.msg:145</tt> by nedtool.
 * <pre>
 * //
 * // Represents an OSPF Router LSA
 * //
 * class OspfRouterLsa extends OspfLsa
 * {
 *     bool V_VirtualLinkEndpoint = false;
 *     bool E_ASBoundaryRouter = false;
 *     bool B_AreaBorderRouter = false;
 *     unsigned short numberOfLinks = 0;
 *     Link links[];
 * }
 * </pre>
 */
class INET_API OspfRouterLsa : public ::inet::ospf::OspfLsa
{
  protected:
    bool V_VirtualLinkEndpoint = false;
    bool E_ASBoundaryRouter = false;
    bool B_AreaBorderRouter = false;
    unsigned short numberOfLinks = 0;
    Link *links = nullptr;
    size_t links_arraysize = 0;

  private:
    void copy(const OspfRouterLsa& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const OspfRouterLsa&);

  public:
    OspfRouterLsa();
    OspfRouterLsa(const OspfRouterLsa& other);
    virtual ~OspfRouterLsa();
    OspfRouterLsa& operator=(const OspfRouterLsa& other);
    virtual OspfRouterLsa *dup() const override {return new OspfRouterLsa(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual bool getV_VirtualLinkEndpoint() const;
    virtual void setV_VirtualLinkEndpoint(bool V_VirtualLinkEndpoint);
    virtual bool getE_ASBoundaryRouter() const;
    virtual void setE_ASBoundaryRouter(bool E_ASBoundaryRouter);
    virtual bool getB_AreaBorderRouter() const;
    virtual void setB_AreaBorderRouter(bool B_AreaBorderRouter);
    virtual unsigned short getNumberOfLinks() const;
    virtual void setNumberOfLinks(unsigned short numberOfLinks);
    virtual void setLinksArraySize(size_t size);
    virtual size_t getLinksArraySize() const;
    virtual const Link& getLinks(size_t k) const;
    virtual Link& getLinksForUpdate(size_t k) { return const_cast<Link&>(const_cast<OspfRouterLsa*>(this)->getLinks(k));}
    virtual void setLinks(size_t k, const Link& links);
    virtual void insertLinks(const Link& links);
    virtual void insertLinks(size_t k, const Link& links);
    virtual void eraseLinks(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const OspfRouterLsa& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, OspfRouterLsa& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/routing/ospfv2/OspfPacket.msg:157</tt> by nedtool.
 * <pre>
 * //
 * // Represents an OSPF Network LSA
 * //
 * class OspfNetworkLsa extends OspfLsa
 * {
 *     Ipv4Address networkMask;
 *     Ipv4Address attachedRouters[];
 * }
 * </pre>
 */
class INET_API OspfNetworkLsa : public ::inet::ospf::OspfLsa
{
  protected:
    Ipv4Address networkMask;
    Ipv4Address *attachedRouters = nullptr;
    size_t attachedRouters_arraysize = 0;

  private:
    void copy(const OspfNetworkLsa& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const OspfNetworkLsa&);

  public:
    OspfNetworkLsa();
    OspfNetworkLsa(const OspfNetworkLsa& other);
    virtual ~OspfNetworkLsa();
    OspfNetworkLsa& operator=(const OspfNetworkLsa& other);
    virtual OspfNetworkLsa *dup() const override {return new OspfNetworkLsa(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const Ipv4Address& getNetworkMask() const;
    virtual Ipv4Address& getNetworkMaskForUpdate() { return const_cast<Ipv4Address&>(const_cast<OspfNetworkLsa*>(this)->getNetworkMask());}
    virtual void setNetworkMask(const Ipv4Address& networkMask);
    virtual void setAttachedRoutersArraySize(size_t size);
    virtual size_t getAttachedRoutersArraySize() const;
    virtual const Ipv4Address& getAttachedRouters(size_t k) const;
    virtual Ipv4Address& getAttachedRoutersForUpdate(size_t k) { return const_cast<Ipv4Address&>(const_cast<OspfNetworkLsa*>(this)->getAttachedRouters(k));}
    virtual void setAttachedRouters(size_t k, const Ipv4Address& attachedRouters);
    virtual void insertAttachedRouters(const Ipv4Address& attachedRouters);
    virtual void insertAttachedRouters(size_t k, const Ipv4Address& attachedRouters);
    virtual void eraseAttachedRouters(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const OspfNetworkLsa& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, OspfNetworkLsa& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/routing/ospfv2/OspfPacket.msg:166</tt> by nedtool.
 * <pre>
 * //
 * // Represents an OSPF Summary LSA
 * //
 * class OspfSummaryLsa extends OspfLsa
 * {
 *     Ipv4Address networkMask;
 *     unsigned long routeCost = 1;
 *     TosData tosData[];
 * }
 * </pre>
 */
class INET_API OspfSummaryLsa : public ::inet::ospf::OspfLsa
{
  protected:
    Ipv4Address networkMask;
    unsigned long routeCost = 1;
    TosData *tosData = nullptr;
    size_t tosData_arraysize = 0;

  private:
    void copy(const OspfSummaryLsa& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const OspfSummaryLsa&);

  public:
    OspfSummaryLsa();
    OspfSummaryLsa(const OspfSummaryLsa& other);
    virtual ~OspfSummaryLsa();
    OspfSummaryLsa& operator=(const OspfSummaryLsa& other);
    virtual OspfSummaryLsa *dup() const override {return new OspfSummaryLsa(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const Ipv4Address& getNetworkMask() const;
    virtual Ipv4Address& getNetworkMaskForUpdate() { return const_cast<Ipv4Address&>(const_cast<OspfSummaryLsa*>(this)->getNetworkMask());}
    virtual void setNetworkMask(const Ipv4Address& networkMask);
    virtual unsigned long getRouteCost() const;
    virtual void setRouteCost(unsigned long routeCost);
    virtual void setTosDataArraySize(size_t size);
    virtual size_t getTosDataArraySize() const;
    virtual const TosData& getTosData(size_t k) const;
    virtual TosData& getTosDataForUpdate(size_t k) { return const_cast<TosData&>(const_cast<OspfSummaryLsa*>(this)->getTosData(k));}
    virtual void setTosData(size_t k, const TosData& tosData);
    virtual void insertTosData(const TosData& tosData);
    virtual void insertTosData(size_t k, const TosData& tosData);
    virtual void eraseTosData(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const OspfSummaryLsa& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, OspfSummaryLsa& obj) {obj.parsimUnpack(b);}

/**
 * Struct generated from inet/routing/ospfv2/OspfPacket.msg:173 by nedtool.
 */
struct INET_API ExternalTosInfo
{
    ExternalTosInfo();
    TosData tosData;
    bool E_ExternalMetricType;
    Ipv4Address forwardingAddress;
    long externalRouteTag;
};

// helpers for local use
void INET_API __doPacking(omnetpp::cCommBuffer *b, const ExternalTosInfo& a);
void INET_API __doUnpacking(omnetpp::cCommBuffer *b, ExternalTosInfo& a);

inline void doParsimPacking(omnetpp::cCommBuffer *b, const ExternalTosInfo& obj) { __doPacking(b, obj); }
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, ExternalTosInfo& obj) { __doUnpacking(b, obj); }

/**
 * Class generated from <tt>inet/routing/ospfv2/OspfPacket.msg:184</tt> by nedtool.
 * <pre>
 * //
 * // Represents the contents of an OSPF AS External LSA
 * //
 * class OspfAsExternalLsaContents extends cObject
 * {
 *     Ipv4Address networkMask;
 *     bool E_ExternalMetricType = false;
 *     unsigned long routeCost = 1;
 *     Ipv4Address forwardingAddress;
 *     long externalRouteTag = 0;
 *     ExternalTosInfo externalTOSInfo[];
 * }
 * </pre>
 */
class INET_API OspfAsExternalLsaContents : public ::omnetpp::cObject
{
  protected:
    Ipv4Address networkMask;
    bool E_ExternalMetricType = false;
    unsigned long routeCost = 1;
    Ipv4Address forwardingAddress;
    long externalRouteTag = 0;
    ExternalTosInfo *externalTOSInfo = nullptr;
    size_t externalTOSInfo_arraysize = 0;

  private:
    void copy(const OspfAsExternalLsaContents& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const OspfAsExternalLsaContents&);

  public:
    OspfAsExternalLsaContents();
    OspfAsExternalLsaContents(const OspfAsExternalLsaContents& other);
    virtual ~OspfAsExternalLsaContents();
    OspfAsExternalLsaContents& operator=(const OspfAsExternalLsaContents& other);
    virtual OspfAsExternalLsaContents *dup() const override {return new OspfAsExternalLsaContents(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const Ipv4Address& getNetworkMask() const;
    virtual Ipv4Address& getNetworkMaskForUpdate() { return const_cast<Ipv4Address&>(const_cast<OspfAsExternalLsaContents*>(this)->getNetworkMask());}
    virtual void setNetworkMask(const Ipv4Address& networkMask);
    virtual bool getE_ExternalMetricType() const;
    virtual void setE_ExternalMetricType(bool E_ExternalMetricType);
    virtual unsigned long getRouteCost() const;
    virtual void setRouteCost(unsigned long routeCost);
    virtual const Ipv4Address& getForwardingAddress() const;
    virtual Ipv4Address& getForwardingAddressForUpdate() { return const_cast<Ipv4Address&>(const_cast<OspfAsExternalLsaContents*>(this)->getForwardingAddress());}
    virtual void setForwardingAddress(const Ipv4Address& forwardingAddress);
    virtual long getExternalRouteTag() const;
    virtual void setExternalRouteTag(long externalRouteTag);
    virtual void setExternalTOSInfoArraySize(size_t size);
    virtual size_t getExternalTOSInfoArraySize() const;
    virtual const ExternalTosInfo& getExternalTOSInfo(size_t k) const;
    virtual ExternalTosInfo& getExternalTOSInfoForUpdate(size_t k) { return const_cast<ExternalTosInfo&>(const_cast<OspfAsExternalLsaContents*>(this)->getExternalTOSInfo(k));}
    virtual void setExternalTOSInfo(size_t k, const ExternalTosInfo& externalTOSInfo);
    virtual void insertExternalTOSInfo(const ExternalTosInfo& externalTOSInfo);
    virtual void insertExternalTOSInfo(size_t k, const ExternalTosInfo& externalTOSInfo);
    virtual void eraseExternalTOSInfo(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const OspfAsExternalLsaContents& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, OspfAsExternalLsaContents& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/routing/ospfv2/OspfPacket.msg:197</tt> by nedtool.
 * <pre>
 * //
 * // Represents an OSPF AS External LSA
 * //
 * class OspfAsExternalLsa extends OspfLsa
 * {
 *     OspfAsExternalLsaContents contents;
 * }
 * </pre>
 */
class INET_API OspfAsExternalLsa : public ::inet::ospf::OspfLsa
{
  protected:
    OspfAsExternalLsaContents contents;

  private:
    void copy(const OspfAsExternalLsa& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const OspfAsExternalLsa&);

  public:
    OspfAsExternalLsa();
    OspfAsExternalLsa(const OspfAsExternalLsa& other);
    virtual ~OspfAsExternalLsa();
    OspfAsExternalLsa& operator=(const OspfAsExternalLsa& other);
    virtual OspfAsExternalLsa *dup() const override {return new OspfAsExternalLsa(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const OspfAsExternalLsaContents& getContents() const;
    virtual OspfAsExternalLsaContents& getContentsForUpdate() { return const_cast<OspfAsExternalLsaContents&>(const_cast<OspfAsExternalLsa*>(this)->getContents());}
    virtual void setContents(const OspfAsExternalLsaContents& contents);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const OspfAsExternalLsa& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, OspfAsExternalLsa& obj) {obj.parsimUnpack(b);}

/**
 * Struct generated from inet/routing/ospfv2/OspfPacket.msg:204 by nedtool.
 */
struct INET_API OspfDdOptions
{
    OspfDdOptions();
    bool unused_1;
    bool unused_2;
    bool unused_3;
    bool unused_4;
    bool unused_5;
    bool I_Init;
    bool M_More;
    bool MS_MasterSlave;
};

// helpers for local use
void INET_API __doPacking(omnetpp::cCommBuffer *b, const OspfDdOptions& a);
void INET_API __doUnpacking(omnetpp::cCommBuffer *b, OspfDdOptions& a);

inline void doParsimPacking(omnetpp::cCommBuffer *b, const OspfDdOptions& obj) { __doPacking(b, obj); }
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, OspfDdOptions& obj) { __doUnpacking(b, obj); }

/**
 * Class generated from <tt>inet/routing/ospfv2/OspfPacket.msg:219</tt> by nedtool.
 * <pre>
 * //
 * // Represents an OSPF Database Description packet
 * //
 * class OspfDatabaseDescriptionPacket extends OspfPacket
 * {
 *     unsigned short interfaceMTU;
 *     OspfOptions options;
 *     OspfDdOptions ddOptions;
 *     unsigned long ddSequenceNumber;
 *     OspfLsaHeader lsaHeaders[];
 * }
 * </pre>
 */
class INET_API OspfDatabaseDescriptionPacket : public ::inet::ospf::OspfPacket
{
  protected:
    unsigned short interfaceMTU = 0;
    OspfOptions options;
    OspfDdOptions ddOptions;
    unsigned long ddSequenceNumber = 0;
    OspfLsaHeader *lsaHeaders = nullptr;
    size_t lsaHeaders_arraysize = 0;

  private:
    void copy(const OspfDatabaseDescriptionPacket& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const OspfDatabaseDescriptionPacket&);

  public:
    OspfDatabaseDescriptionPacket();
    OspfDatabaseDescriptionPacket(const OspfDatabaseDescriptionPacket& other);
    virtual ~OspfDatabaseDescriptionPacket();
    OspfDatabaseDescriptionPacket& operator=(const OspfDatabaseDescriptionPacket& other);
    virtual OspfDatabaseDescriptionPacket *dup() const override {return new OspfDatabaseDescriptionPacket(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual unsigned short getInterfaceMTU() const;
    virtual void setInterfaceMTU(unsigned short interfaceMTU);
    virtual const OspfOptions& getOptions() const;
    virtual OspfOptions& getOptionsForUpdate() { handleChange();return const_cast<OspfOptions&>(const_cast<OspfDatabaseDescriptionPacket*>(this)->getOptions());}
    virtual void setOptions(const OspfOptions& options);
    virtual const OspfDdOptions& getDdOptions() const;
    virtual OspfDdOptions& getDdOptionsForUpdate() { handleChange();return const_cast<OspfDdOptions&>(const_cast<OspfDatabaseDescriptionPacket*>(this)->getDdOptions());}
    virtual void setDdOptions(const OspfDdOptions& ddOptions);
    virtual unsigned long getDdSequenceNumber() const;
    virtual void setDdSequenceNumber(unsigned long ddSequenceNumber);
    virtual void setLsaHeadersArraySize(size_t size);
    virtual size_t getLsaHeadersArraySize() const;
    virtual const OspfLsaHeader& getLsaHeaders(size_t k) const;
    virtual OspfLsaHeader& getLsaHeadersForUpdate(size_t k) { handleChange();return const_cast<OspfLsaHeader&>(const_cast<OspfDatabaseDescriptionPacket*>(this)->getLsaHeaders(k));}
    virtual void setLsaHeaders(size_t k, const OspfLsaHeader& lsaHeaders);
    virtual void insertLsaHeaders(const OspfLsaHeader& lsaHeaders);
    virtual void insertLsaHeaders(size_t k, const OspfLsaHeader& lsaHeaders);
    virtual void eraseLsaHeaders(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const OspfDatabaseDescriptionPacket& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, OspfDatabaseDescriptionPacket& obj) {obj.parsimUnpack(b);}

/**
 * Struct generated from inet/routing/ospfv2/OspfPacket.msg:228 by nedtool.
 */
struct INET_API LsaRequest
{
    LsaRequest();
    unsigned long lsType;
    Ipv4Address linkStateID;
    Ipv4Address advertisingRouter;
};

// helpers for local use
void INET_API __doPacking(omnetpp::cCommBuffer *b, const LsaRequest& a);
void INET_API __doUnpacking(omnetpp::cCommBuffer *b, LsaRequest& a);

inline void doParsimPacking(omnetpp::cCommBuffer *b, const LsaRequest& obj) { __doPacking(b, obj); }
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, LsaRequest& obj) { __doUnpacking(b, obj); }

/**
 * Class generated from <tt>inet/routing/ospfv2/OspfPacket.msg:238</tt> by nedtool.
 * <pre>
 * //
 * // Represents an OSPF Link State Request packet
 * //
 * class OspfLinkStateRequestPacket extends OspfPacket
 * {
 *     LsaRequest requests[];
 * }
 * </pre>
 */
class INET_API OspfLinkStateRequestPacket : public ::inet::ospf::OspfPacket
{
  protected:
    LsaRequest *requests = nullptr;
    size_t requests_arraysize = 0;

  private:
    void copy(const OspfLinkStateRequestPacket& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const OspfLinkStateRequestPacket&);

  public:
    OspfLinkStateRequestPacket();
    OspfLinkStateRequestPacket(const OspfLinkStateRequestPacket& other);
    virtual ~OspfLinkStateRequestPacket();
    OspfLinkStateRequestPacket& operator=(const OspfLinkStateRequestPacket& other);
    virtual OspfLinkStateRequestPacket *dup() const override {return new OspfLinkStateRequestPacket(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual void setRequestsArraySize(size_t size);
    virtual size_t getRequestsArraySize() const;
    virtual const LsaRequest& getRequests(size_t k) const;
    virtual LsaRequest& getRequestsForUpdate(size_t k) { handleChange();return const_cast<LsaRequest&>(const_cast<OspfLinkStateRequestPacket*>(this)->getRequests(k));}
    virtual void setRequests(size_t k, const LsaRequest& requests);
    virtual void insertRequests(const LsaRequest& requests);
    virtual void insertRequests(size_t k, const LsaRequest& requests);
    virtual void eraseRequests(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const OspfLinkStateRequestPacket& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, OspfLinkStateRequestPacket& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/routing/ospfv2/OspfPacket.msg:246</tt> by nedtool.
 * <pre>
 * //
 * // Represents an OSPF Link State Update packet
 * //
 * class OspfLinkStateUpdatePacket extends OspfPacket
 * {
 *     unsigned long numberOfLSAs;
 *     OspfRouterLsa routerLSAs[];
 *     OspfNetworkLsa networkLSAs[];
 *     OspfSummaryLsa summaryLSAs[];
 *     OspfAsExternalLsa asExternalLSAs[];
 * }
 * </pre>
 */
class INET_API OspfLinkStateUpdatePacket : public ::inet::ospf::OspfPacket
{
  protected:
    unsigned long numberOfLSAs = 0;
    OspfRouterLsa *routerLSAs = nullptr;
    size_t routerLSAs_arraysize = 0;
    OspfNetworkLsa *networkLSAs = nullptr;
    size_t networkLSAs_arraysize = 0;
    OspfSummaryLsa *summaryLSAs = nullptr;
    size_t summaryLSAs_arraysize = 0;
    OspfAsExternalLsa *asExternalLSAs = nullptr;
    size_t asExternalLSAs_arraysize = 0;

  private:
    void copy(const OspfLinkStateUpdatePacket& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const OspfLinkStateUpdatePacket&);

  public:
    OspfLinkStateUpdatePacket();
    OspfLinkStateUpdatePacket(const OspfLinkStateUpdatePacket& other);
    virtual ~OspfLinkStateUpdatePacket();
    OspfLinkStateUpdatePacket& operator=(const OspfLinkStateUpdatePacket& other);
    virtual OspfLinkStateUpdatePacket *dup() const override {return new OspfLinkStateUpdatePacket(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual unsigned long getNumberOfLSAs() const;
    virtual void setNumberOfLSAs(unsigned long numberOfLSAs);
    virtual void setRouterLSAsArraySize(size_t size);
    virtual size_t getRouterLSAsArraySize() const;
    virtual const OspfRouterLsa& getRouterLSAs(size_t k) const;
    virtual OspfRouterLsa& getRouterLSAsForUpdate(size_t k) { handleChange();return const_cast<OspfRouterLsa&>(const_cast<OspfLinkStateUpdatePacket*>(this)->getRouterLSAs(k));}
    virtual void setRouterLSAs(size_t k, const OspfRouterLsa& routerLSAs);
    virtual void insertRouterLSAs(const OspfRouterLsa& routerLSAs);
    virtual void insertRouterLSAs(size_t k, const OspfRouterLsa& routerLSAs);
    virtual void eraseRouterLSAs(size_t k);
    virtual void setNetworkLSAsArraySize(size_t size);
    virtual size_t getNetworkLSAsArraySize() const;
    virtual const OspfNetworkLsa& getNetworkLSAs(size_t k) const;
    virtual OspfNetworkLsa& getNetworkLSAsForUpdate(size_t k) { handleChange();return const_cast<OspfNetworkLsa&>(const_cast<OspfLinkStateUpdatePacket*>(this)->getNetworkLSAs(k));}
    virtual void setNetworkLSAs(size_t k, const OspfNetworkLsa& networkLSAs);
    virtual void insertNetworkLSAs(const OspfNetworkLsa& networkLSAs);
    virtual void insertNetworkLSAs(size_t k, const OspfNetworkLsa& networkLSAs);
    virtual void eraseNetworkLSAs(size_t k);
    virtual void setSummaryLSAsArraySize(size_t size);
    virtual size_t getSummaryLSAsArraySize() const;
    virtual const OspfSummaryLsa& getSummaryLSAs(size_t k) const;
    virtual OspfSummaryLsa& getSummaryLSAsForUpdate(size_t k) { handleChange();return const_cast<OspfSummaryLsa&>(const_cast<OspfLinkStateUpdatePacket*>(this)->getSummaryLSAs(k));}
    virtual void setSummaryLSAs(size_t k, const OspfSummaryLsa& summaryLSAs);
    virtual void insertSummaryLSAs(const OspfSummaryLsa& summaryLSAs);
    virtual void insertSummaryLSAs(size_t k, const OspfSummaryLsa& summaryLSAs);
    virtual void eraseSummaryLSAs(size_t k);
    virtual void setAsExternalLSAsArraySize(size_t size);
    virtual size_t getAsExternalLSAsArraySize() const;
    virtual const OspfAsExternalLsa& getAsExternalLSAs(size_t k) const;
    virtual OspfAsExternalLsa& getAsExternalLSAsForUpdate(size_t k) { handleChange();return const_cast<OspfAsExternalLsa&>(const_cast<OspfLinkStateUpdatePacket*>(this)->getAsExternalLSAs(k));}
    virtual void setAsExternalLSAs(size_t k, const OspfAsExternalLsa& asExternalLSAs);
    virtual void insertAsExternalLSAs(const OspfAsExternalLsa& asExternalLSAs);
    virtual void insertAsExternalLSAs(size_t k, const OspfAsExternalLsa& asExternalLSAs);
    virtual void eraseAsExternalLSAs(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const OspfLinkStateUpdatePacket& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, OspfLinkStateUpdatePacket& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>inet/routing/ospfv2/OspfPacket.msg:258</tt> by nedtool.
 * <pre>
 * //
 * // Represents an OSPF Link State Acknowledgement packet
 * //
 * class OspfLinkStateAcknowledgementPacket extends OspfPacket
 * {
 *     OspfLsaHeader lsaHeaders[];
 * }
 * </pre>
 */
class INET_API OspfLinkStateAcknowledgementPacket : public ::inet::ospf::OspfPacket
{
  protected:
    OspfLsaHeader *lsaHeaders = nullptr;
    size_t lsaHeaders_arraysize = 0;

  private:
    void copy(const OspfLinkStateAcknowledgementPacket& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const OspfLinkStateAcknowledgementPacket&);

  public:
    OspfLinkStateAcknowledgementPacket();
    OspfLinkStateAcknowledgementPacket(const OspfLinkStateAcknowledgementPacket& other);
    virtual ~OspfLinkStateAcknowledgementPacket();
    OspfLinkStateAcknowledgementPacket& operator=(const OspfLinkStateAcknowledgementPacket& other);
    virtual OspfLinkStateAcknowledgementPacket *dup() const override {return new OspfLinkStateAcknowledgementPacket(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual void setLsaHeadersArraySize(size_t size);
    virtual size_t getLsaHeadersArraySize() const;
    virtual const OspfLsaHeader& getLsaHeaders(size_t k) const;
    virtual OspfLsaHeader& getLsaHeadersForUpdate(size_t k) { handleChange();return const_cast<OspfLsaHeader&>(const_cast<OspfLinkStateAcknowledgementPacket*>(this)->getLsaHeaders(k));}
    virtual void setLsaHeaders(size_t k, const OspfLsaHeader& lsaHeaders);
    virtual void insertLsaHeaders(const OspfLsaHeader& lsaHeaders);
    virtual void insertLsaHeaders(size_t k, const OspfLsaHeader& lsaHeaders);
    virtual void eraseLsaHeaders(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const OspfLinkStateAcknowledgementPacket& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, OspfLinkStateAcknowledgementPacket& obj) {obj.parsimUnpack(b);}

} // namespace ospf
} // namespace inet

#endif // ifndef __INET__OSPF_OSPFPACKET_M_H

